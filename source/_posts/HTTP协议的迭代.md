---
title: HTTP协议的迭代（HTTP：应用层）
date: 2024-03-09 19:28:38
tags:
categories:
- 计算机网络
---

## 一、从浏览器输入URL到页面显示的过程

### 1.1 URL到显示的全过程

<img src="URL_to_display.png">

- **URL解析**：浏览器解析URL，得到服务器的域名（www.baidu.com）和端口号，以及请求资源的路径
    - 在**缓存**中**找得到**该域名对应的IP地址：直接访问服务器发送请求
    - 在**缓存**中**找不得到**该域名：发起**DNS迭代查询**，得到服务器的IP地址
- **DNS域名解析**：**客户端**发起**迭代查询**；**DNS服务器**之间通过**递归查询**得到域名对应的IP地址
    - 浏览器 ---> 本地DNS
    - 本地DNS ---> 根DNS ---> 向本地DNS**返回顶级DNS**的IP地址
    - 本地DNS ---> 顶级DNS ---> 向本地DNS**返回权威DNS**的IP地址
    - 本地DNS ---> 权威DNS ---> 向本地DNS**返回域名对应的IP地址**
- **客户端发起TCP连接**：三次握手
- **客户端发送HTTP请求**：请求报文
- **服务器发送HTTP响应**：响应**报文**与**状态码**
- **浏览器解析渲染页面**：解析HTML、CSS、JS等文件
- **客户端发起断开TCP连接**：四次挥手

### 1.2 DNS域名解析

<img src="DNS.png">

- **DNS域名解析**：**客户端**发起**迭代查询**；**DNS服务器**之间通过**递归查询**得到域名对应的IP地址
    - 浏览器 ---> 本地DNS
    - 本地DNS ---> 根DNS ---> 向本地DNS**返回顶级DNS**的IP地址
    - 本地DNS ---> 顶级DNS ---> 向本地DNS**返回权威DNS**的IP地址
    - 本地DNS ---> 权威DNS ---> 向本地DNS**返回域名对应的IP地址**

DNS域名解析过程如下：

<img src="DNS2.png">

**DNS可能出现的一些网络攻击问题：**

- **DNS劫持**：黑客劫持DNS服务器并**篡改解析结果**，使用户访问的网站**跳转到恶意网站**
  - 解决：换个**DNS服务器**，躲过被劫持的**DNS服务器**
- **DNS污染**：黑客监听某些DNS查询，并伪装成目标服务器返回虚假结果（禁用google就是通过DNS污染实现的）
  - 解决：直接在本机绑定hosts绕过DNS，或者更换成没被污染的DNS服务器

### 1.3 正向代理和反向代理

- **正向代理**：代理客户端，**向服务端隐藏客户端**的真实IP地址
  - 如平时通过VPN访问外网使用的技术就是正向代理
- **反向代理**：代理服务器，**向客户端隐藏服务器**的真实IP地址
  - 如Nginx就是一个反向代理服务器

## 二、HTTP协议的特点

### 2.1 Web构建的技术

<img src="Web_build.png">

### 2.2 HTTP1：HTTP1.0与HTTP1.1

<img src="HTTP1.png">

### 2.3 HTTP2

<img src="HTTP2.png">

HTTP2的很大特点是采用了**stream**技术，可以**同时发送多个请求**，并且**不需要按照顺序来发送**，这样可以**提高传输效率**，并且**减少延迟**。

stream中一个TCP连接可以有多个stream，每个stream都有一个唯一的标识符;一个stream中可以有多个message；每个message可以有多个frame。frame是HTTP2的最小单位。

<img src="HTTP2_stream.png">

### 2.4 HTTP3

HTTP3是基于UDP的，使用了**QUIC**协议，可以**减少延迟**，并且**提高传输效率**。

<img src="HTTP3.png">

### 2.5 HTTP1~HTTP3的应用层到链路层的区别

<img src="HTTP1~HTTP3.jpg">

## 三、HTTP缓存

客户端中存储缓存副本，**有效的缓存副本**在下一次可以**直接使用**而**不需要再次请求服务器**

HTTP实现缓存的方式有：强制缓存和协商缓存

- 强缓存：通过**Cache-Control**和**Expires**字段设置**缓存时间**，当缓存时间**未过期**时，直接使用缓存，**不需要与服务器通信**
- 协商缓存：通过**Last-Modified**和**Etag**字段，向服务器**发送请求**，服务器**判断资源是否能直接使用缓存**

HTTP实现缓存的方式如下：

<img src="HTTP_cache.png">

其中HTTP协商缓存的流程图如下：

<img src="HTTP_cache_2.jpg">

## 四、HTTPS

HTTPS是在HTTP的基础上加入了**SSL/TLS**协议，可以**保证数据传输的安全性**。具有数据加密、校验、身份认证等特点。

<img src="HTTPS.png">

<img src="SSL.png">

### 4.1 对称加密

对称加密是指**加密**和**解密**使用的是**同一个密钥**，加密和解密的速度非常快，但是密钥的安全是一个问题。

密钥安全问题是指：**密钥的传输**和**存储**是一个问题，如果**密钥被泄露**，那么加密的数据也就不安全了。

所以如果要安全使用对称加密，我们需要有一个保证密钥被安全传输到双方的措施，这个措施我们后面会讲，就是通过**非对称加密**对密钥进行加密，然后将加密后的密钥传输给对方，这样才能保证后续通信过程中的**密钥安全**。

### 4.2 非对称加密RSA

非对称加密是指加密和解密使用的是**不同的密钥**，加密使用的是**公钥**，解密使用的是**私钥**。

#### RSA加密过程（公钥对密文进行加密）如下：

<img src="RSA_public.png">

也就是说RSA加密是对明文进行`E`次方后求对`N`的余数，得到密文。

从公式可以知道，`E`和`N`是公钥，所有人都可以获得，并通过公钥对信息进行加密，所以我们用`(E,N)`来表示公钥。

<img src="RSA_public_key.png">

神奇的点在于，只有拥有对应**私钥**的才能对密文进行解密，得到明文。（一般私钥都在服务端处保存）

#### RSA解密过程（私钥对密文进行解密）如下：

<img src="RSA_private.png">

也就是说RSA解密是对密文进行`D`次方后求对`N`的余数，得到明文，所以我们用`(D,N)`来表示私钥。

<img src="RSA_private_key.png">

#### 生成密钥对的过程

生成密钥对需要求`N`、`L`、`E`、`D`的值

- 求`N`的值：`N`是两个大质数`p`和`1`的乘积，当`p`和`q`都是大质数时，`N`的值很难被分解，也就是基本不可能从公钥`N`的值反推出`p`和`q`的值（所以不能反推出私钥的值）
    - `N = p * q`
- 求`L`的值：`L`是`p-1`和`q-1`的最小公倍数
    - `L = LCM(p-1, q-1)`
- 求`E`的值：`E`是一个小于`L`的数，且`E`和`L`的最大公约数为1
- 求`D`的值：`D`是`E`的逆元，即`E * D % L = 1`

求完之后，我们就得到了公钥`(E,N)`和私钥`(D,N)`。

**我们只需要记得私钥`D`的值是几乎不可能被通过公钥反推回来的就行，且通过公钥加密的密文只有对应的私钥才能解密。**

RSA神奇的点就在于，**私钥**可以**解密公钥**加密的密文，而**公钥**可以解密**私钥**加密的密文。但是由于公钥是公开的，所以我们一般不用私钥进行加密（不然所有拥有公钥的都能解密数据了），只有在**数字签名**的时候才会用到私钥进行加密。

#### 采用RSA除了加密外，还可以用于数字签名

数字签名其实是加密的反过程，是为了**验证服务端的身份**（也就是说数据是不是从服务端发送过来的）

最主要的过程是：**服务端**用**私钥**对数据进行**加密**（这里说加密其实不准确，我们可以称为**签名**），然后**客户端**用**公钥**对数据进行**解密**（这里说法也不准确，应该称为**验证签名**），如果解密后的数据和原数据一样（通过同步送过来的**哈希值**来判断是否一样），那么就说明数据是从服务端发送过来的。

数字签名的过程如下：
- 服务端用私钥对**原始消息的哈希值**进行签名
- 发送给客户端：**原始消息**和**签名**
- 客户端用公钥对**签名**进行解密，并计算同步发送过来的**原始消息的哈希值**，如果**解密后的哈希值**和**同步发送过来的哈希值**一样，那么就说明数据是从服务端发送过来的

<img src="RSA_sign.jpg">

### 4.3 HTTPS采用的混合加密模式

HTTPS采用的是**混合加密模式**，即**对称加密**和**非对称加密**结合使用。

- **非对称加密**：用于**传输对称加密的密钥**
    - 服务端发送自己的**数字证书**给客户端，请求**身份认证**
    - 客户端用CA认证过的服务端的**公钥**对服务端的**数字证书**进行验证（防止中间人发送伪造的证书来伪造服务端）
    - 客户端验证通过后用**公钥**对自己随机生成的**对称加密的密钥**进行加密，然后发送给服务端
    - 由于只有服务端有**私钥**，所以只有服务端能解密得到**对称加密的密钥**，所以此时只有服务端能解开并得到**对称加密的密钥**
- **对称加密**：客户端和服务端验证完并获取安全的**对称加密的密钥**后，就用于后续的**传输数据**

为什么要采用混合加密模式呢？

因为**对称加密**的速度很快，但是**密钥安全**是个问题，所以我们首次建立TLS连接的时候，采用**非对称加密**用于**传输对称加密的密钥**，可以确保**密钥的安全**。然后后面正常通信的时候使用这个**安全的密钥**，就可以保证在安全情况下进行快速通信。

<img src="RSA_mix.jpg">

### 4.4 HTTPS的数字证书

数字证书是由权威的CA机构颁发的，用于**证明服务端身份**的一种证书。

如果没有权威公开的CA机构颁发的数字证书，那么就会出现**中间人攻击**，即中间人有自己的公钥和私钥，然后伪造了一个数字证书，客户端用伪造的公钥验证通过后，就会误认为是服务端发送的数据，这样就会出现中间人攻击**安全问题**。

而如果通过**CA的私钥对服务器的公钥**进行数字签名，那么这个证书就是只能由权威的CA公钥进行解密验证，所以客户端可以用CA的公钥验证服务端发来的数字证书，验证通过后才会从发来的数据中获取服务端的**公钥**。SSL/TLS建立安全连接的过程如下：

<img src="RSA_certificate.jpg">

CA能确保数据安全的图解：

<img src="RSA_certificate_2.png">

# 五、RPC

## 5.1 RPC的通信流程

RPC是一种**远程调用**框架，目的是使得**调用远程服务**和**调用本地**一样简单，而开发者更专注于业务开发，不需要考虑**网络编程**等细节。

RPC实现的主要流程为：

前提：服务提供端向**注册中心**注册接口服务

- **注册中心**根据**服务名**找到**服务提供端**的**IP地址**和**端口号**
- **Netty客户端**将数据**序列化**成**二进制格式**然后请求网络调用
- **服务端**在TCP通道中接收数据，将**二进制数据**反序列后分割成**接口地址和参数对象**，然后通过**反射**找到接口然后执行调用
- **服务端**处理完接口后将结果**序列化**成**二进制数据**返回给**Netty客户端**
- **Netty客户端**接收到**二进制数据**后将数据**反序列化**成**结果对象**

<img src="RPCStructure.png" width="70%">

## 5.2 RPC与HTTP的区别

- 1）RPC和HTTP都是基于TCP封装的协议

- 2）**RPC适用于C/S模式**，比如PC上用的**电脑管家等软件、公司内部微服务通信**只需要跟自家的服务器通信；而**HTTP适用于B/S模式**，比如**浏览器**需要和**其他公司的服务器**通信，这时候就需要一个统一的协议也就是HTTP了。

- 3）**RPC域名获取**时一般都是有**专门的中间服务**去获取，而**HTTP**更统一于使用**DNS**去获取域名

- 4）**RPC**跟**HTTP1.1**一样保持的长连接，此外，**RPC**实现**连接池**来复用连接（不少编程语言在HTTP中也会用连接池复用）

- 5）**RPC**一般通过Protobuf实现序列化，而**HTTP**一般通过JSON实现序列化，Protobuf序列化后的数据量更小，传输效率更高

因此不难看出，RPC定制化程度比HTTP更高