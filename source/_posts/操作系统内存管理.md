---
title: 操作系统内存管理
date: 2024-05-17 21:48:29
tags:
categories:
- 操作系统
---

# 一、虚拟内存

## 1.1 为什么要有虚拟内存？

在单片机中是没有操作系统的，所以**CPU**会直接操作**物理内存**，而内存又是有限的，因此单片机中只能跑一个程序

而为了能够同时运行多个程序，我们需要**操作系统**，操作系统会为每个程序分配一块**虚拟内存（可以实现进程间的内存隔离、解决物理内存不够的问题）**，这样每个程序都认为自己在独占物理内存，实际上是**共享物理内存**

最终每个进程的**虚拟内存**落盘到**物理内存**会通过**页表**来映射实现

CPU中存的是程序对应的**虚拟地址**信息，然后通过**CPU中的MMU（内存管理单元，负责把虚拟地址映射成物理地址）**映射成**物理地址**，进而再通过地址总线去访问**物理内存**

<img src="VirtualMemory.png" width="70%">

## 1.2 虚拟内存

当一个程序运行时，会允许**一部分加载到实际的物理内存**，而暂时不用的部分则会存放在**磁盘（外存）**上

当执行到该进程的某部分代码出现**缺页**时，操作系统会产生一个**缺页异常**，并由用户态进入**内核态**将**磁盘**上的相关数据加载到**物理内存**中，然后再返回用户态继续执行

这种技术就是**虚拟内存**技术，可以根据**页的大小**（Linux下一般为**4KB**）将程序进行分割，然后不连续地加载到**物理内存**中

## 1.3 内存分页

在**内存分页**前还有**内存分段**，**内存分段**是将程序分为**代码段、数据段、堆栈段**等，它的好处是能产生连续的空间，但是**内存分段**会导致**内存碎片**问题，也就是大小不一的**内存块**会导致**内存**的**利用率**不高

因此衍生出了**内存分页**的方式，将程序**按照固定大小的页**进行分割，这种紧密的页表排列不会有**外碎片**的产生，很好地利用了宝贵的物理内存空间。但是由于最小单位是**页**，当不足一页时会补全一页，导致**内部碎片**的产生

在**虚拟内存**和**物理内存**之间通过存储在**MMU**中的**页表**进行映射

<img src="MemoryPage.png" width="70%">


在单级分页中，会把**虚拟地址**分为
- **页号**：用于索引**页表**中的**页表项**，用于查找**物理内存**中对应页的**物理地址**
- **页内偏移**：用于定位**页**中的具体**字节**。偏移是相对量，所以在**虚拟内存**和**物理内存**中的偏移是一样的

所以通过**页表**拿到**物理地址**后，再加上**页内偏移**就能得到具体的**物理地址**

<img src="PageTable.png" width="70%">

在这种单级分页下
- **虚拟内存的页大小 == 物理内存的页大小**
- 而每个**页表项**有4byte(32位系统下)

假设**内存大小**为**2^nbit**，每个**页表项**的大小为**2^mbit**，则表示总共有**2^n/2^m = 2^(n-m)页数**，因此需要有**2^(n-m)个页表项**，也就是**有(n-m)bit**来记录对应的**页号**

<img src="PageTableSize.png" width="70%">

<img src="AddrSwap.png" width="80%">

因此**页表**的大小是**逻辑空间页数**乘以**页表项的大小(一个页表项占多少bits)**，这种单级分页的方式会导致**页表**过大，因此在实际操作系统中会采用**多级页表**的方式

## 1.4 多级页表

单级页表无法定位到某个**进程**，因此需要给整个逻辑空间的**虚拟地址空间**都分配**页表（放在CPU中）**，这样会导致**页表**过大(且每个进程都有自己的页表)，CPU无法放下，可以选择将**页表**放在**内存**中，而将经常访问的**页表**放在**CPU的TLB中**中

而**二级页表**的方式是通过将**页号分为两部分**
- 第一部分用于**索引一级页表**，通过**一级页表**找到**二级页表**的**物理地址**
- 第二部分用于**索引二级页表**，通过**二级页表**找到**实际物理地址**

这样的话，**页表**的大小就变成了**一级页表的大小 + 二级页表的大小**，而**一级页表中不存在的页**则不会占用**二级页表**的空间，这样就减小了**总页表**的大小（页表还是放在**内核态空间**中）

在分级的机制下，假设只有 `20%` 的一级页表项被用到了，那么页表占用的内存空间就只有 `4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB`，这对比单级页表的 `4MB` 是不是一个巨大的节约？

## 1.5 页的换入换出

当程序运行时，**内存空间不够**时：
- 操作系统会将**正在运行的某个进程中不常用的页**从**物理内存**中**换出**到**磁盘(外存)**上
- 然后将**需要的页**从**磁盘**上**换入**到**物理内存**中

<img src="PageSwap.png" width="70%">

# 二、内存分配（malloc）

在文章[内存池设计](https://akirazheng.github.io/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/#/4-1-2-malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6)中已经有详细的介绍，这里就不再赘述

# 三、mmap

`mmap`在文章[浅聊一下mmap延申的内存映射问题](https://akirazheng.github.io/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/#/%E5%85%AD%E3%80%81%E6%B5%85%E8%81%8A%E4%B8%80%E4%B8%8Bmmap%E5%BB%B6%E7%94%B3%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98)中已经有详细的介绍，这里就不再赘述




> 参考：[内存管理](https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98)