---
title: 设计模式5：模板方法
date: 2024-02-10 14:44:03
tags:
categories:
- 设计模式
---

## 前言

> [本文中所有设计模式Github代码](https://github.com/AkiraZheng/designPattern/tree/master/designPattern)
其中本文**模板方法**相关代码在`TemplateMethodPattern.h`文件中

## 一、模板方法基础

### 1. 模板方法的提出

> 对于某项具体任务，模板方法模式常常拥有**稳定的整体操作结构**，但各个**子步骤**的具体实现可能**各不相同**（改变的）。那么如何在稳定的操作结构前提下，灵活**应变各个子步骤的变化**或者晚期实现需求？

### 2. 模板方法的设计思想&&代码实现（C++）

已知在程序开发中，框架开发人员（程序库开发人员）常常会提供一些**稳定的操作结构和方法**，而一些可变的具体的操作步骤则由**应用开发人员**来实现。这种情况下，框架开发人员可以使用**模板方法模式**来实现

#### 2.1 模板方法使用场景示例

假设我们需要设定一系列**步骤step1~step5**来实现某项功能，其中**step1、step3、step5**的实现是**稳定的**，可以在**程序库lib开发**中实现

但是**step2和step4**的实现是**不稳定**的，需要在**应用开发**中实现

而**整体的step1~step5**的步骤顺序和使用框架是**稳定**的

<img src='step.png'>

#### 2.2 未使用模板方法的代码实现思路

当我们没有采用模板方法模式时，我们会在**程序库lib开发**中提供**step1、step3、step5**的**稳定**实现，然后在**应用开发**中提供**step2和step4**的**不稳定**实现。最后在main程序中实现**step1~step5**的调用来实现具体功能

```c++
// 程序库开发人员
#include <iostream>
using namespace std;

class Library{
public:
    void step1(){
        cout << "Library::step1()" << endl;
    }
    void step3(){
        cout << "Library::step3()" << endl;
    }
    void step5(){
        cout << "Library::step5()" << endl;
    }
};
```
```c++
// 应用程序开发人员
class Application
{
public:
    bool step2(){
        cout << "Application::step2()" << endl;
        //...
        return true;
    }
    void step4(){
        cout << "Application::step4()" << endl;
    }
};

int main(){
    Library lib;
    Application app;

    lib.step1();

    if(app.step2()){//step2的实现是不稳定的
        lib.step3();
    }

    for(int i = 0; i < 4; i++){
        app.step4();//step4的实现是不稳定的
    }

    lib.step5();

    return 0;
}
```
这种方法属于**早绑定**的实现方式，在**结构化**的设计思维，也就是**晚实现的应用程序人员开发程序**去调用**更早实现的lib库**

<img src="early_bind.png">

这种实现方法是有缺点的：对于稳定的**step1~step5**的调用是**分散**的，**不利于维护**

#### 2.3 使用模板方法的代码实现思路

解决上述问题的方法思路是：

将**稳定的**main函数中的**整体步骤实现**也放在稳定的程序库lib中，然后在应用开发中实现不稳定的步骤

由于lib库中也需要用到app的实现，因此我们可以将两个不稳定的函数**作为lib库的虚函数**，交由**应用程序开发人员继承实现**

这样在main中直接创建一个lib库的多态指针，然后调用lib的**整体实现步骤框架函数**就可以

```c++
// 程序库开发人员
#include <iostream>
using namespace std;

class Library{
public:
    void step1(){
        cout << "Library::step1()" << endl;
    }
    void step3(){
        cout << "Library::step3()" << endl;
    }
    void step5(){
        cout << "Library::step5()" << endl;
    }
    void run(){
        step1();
        if(step2()){//支持变化 ==> 虚函数的多态调用
            step3();
        }
        for(int i = 0; i < 4; i++){
            step4();//支持变化 ==> 虚函数的多态调用
        }
        step5();
    }
    virtual bool step2() = 0;
    virtual void step4() = 0;
    virtual ~Library(){};
};
```
```c++
// 应用程序开发人员
class Application:public Library
{
public:
    bool step2(){
        cout << "Application::step2()" << endl;
        //...
        return true;
    }
    void step4(){
        cout << "Application::step4()" << endl;
    }
};

int main(){
    Library* plib = new Application();
    plib->run();
    delete plib;
    return 0;
}
```

这种方法属于**晚绑定**的实现方式，是**面向对象开发**的设计思维，也就是**早实现的lib库**通过开发稳定的算法骨架（Run函数），并将一些步骤延迟（延迟也就是虚函数）到**晚实现的应用程序开发人员**去实现

<img src="late_bind.png">

## 二、总结

- 在面向对象的设计中，我们要将**稳定的代码**写成**非虚函数**，将**不稳定**的代码写成**虚函数**，这样可以实现**稳定代码的复用**，**不稳定代码的延迟实现**

- 设计模式的假设是必须有一个稳定点，那么当所有代码都是不稳定的时候，就不适合使用设计模式了

- **设计模式**最大的特点是在**变化和稳定**中间寻找隔离点，将变化的部分通过虚函数隔离出来，使得稳定的部分不受影响

- 虚函数是面向对象里面最核心的晚绑定实现技术