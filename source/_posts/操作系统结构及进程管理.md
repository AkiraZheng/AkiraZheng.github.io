---
title: 操作系统结构及进程管理
date: 2024-04-25 17:14:13
tags:
categories:
- 操作系统
---

# 一、CPU执行过程

## 1.1 CPU基本硬件结构

我们直到，计算机主要是由**CPU、内存、I/O设备**组成的

<img src="Computer_struct.png" width="80%">

而**CPU**是计算机的核心部件，它负责**执行指令、控制操作**等，其执行速度极快，且速度与时钟周期息息相关。CPU的基本硬件结构如下：

- **寄存器**：CPU内部的高速存储器，用于缓存指令、数据等。
    - **通用寄存器**：存放**数据**
    - **程序计数器**：存放下一条指令的**地址**
    - **指令寄存器**：存放当前**指令**
- **逻辑单元ALU**：负责**执行算术运算、逻辑运算、数据传输、条件分支等**
- **控制单元**：负责**控制指令的执行**
    - 负责按照地址从内存中**取出指令**
    - 负责**跳转**操作

<img src="CPU_Struct.png" >

## 1.2 CPU寻址与位宽的关系

### 1.2.1 位宽

**位宽**是指CPU**一个时间周期**能处理的**数据位数**，例如**32位**或**64位**，位宽越大，CPU处理数据的能力越强，但同时也会增加成本。

### 1.2.2 寻址

**寻址**是指CPU访问内存的方式，是由**地址总线**决定的，因此**寻址**能力与**位宽**是无关的，因为位宽管的是**数据**。

### 1.2.3 位宽与寻址的关系

场景：
- 当CPU需要从**内存**中读取数据到**寄存器** 或者 **写入数据**到物理内存时

流程：
- CPU会先通过**地址总线**指定需要访问的**物理内存地址**
- 在指定的**物理内存地址**通过**数据总线**进行**读取**或**写入**操作

## 1.3 CPU执行指令过程

CPU执行指令的**一个指令周期**过程如下：

- step1：CPU读取**程序计数器**中的**指令地址**（内存地址）
- step2：CPU根据指令地址，交由**控制单元**操作**地址总线**去访问指定内存地址，读取指令
- step3：CPU将读取到的指令存放到**指令寄存器**中
- step4：**程序计数器**完成上述操作后，自增指向下一条指令，其中自增的步长（字节）取决于**CPU位宽**，一般为**32位**或**64位**
- step5：CPU根据**指令寄存器**中的指令，解析指令类型和参数，对于**计算指令**，将参数从**通用寄存器**中取出，交由**逻辑运算单元ALU**执行计算


# 二、用户态与内核态

## 2.1 用户态与内核态

OS中的**内存**根据**权限**划分为两个空间：
- **用户空间（User Space）**：用户程序运行的空间（权限小，执行普通操作）
- **内核空间（Kernel Space）**：操作系统运行的空间（权限大，执行访问磁盘、内存分配、网卡、声卡等敏感操作需要进行安全校验）

一个运行中的**进程/程序**，在执行中有可能处于**用户态**或者**内核态**，因此这里就涉及了两个空间之间的切换：

- **用户态--->内核态**：当用户程序需要进行**外部资源申请**时，需要切换到**内核态**，一般有以下几种情况：
    - **系统调用**：用户程序通过**系统调用**请求操作系统提供服务（**软中断**）
    - **异常**：用户程序执行过程中出现**异常**，如**除零操作**
    - **中断**：外部设备发生**中断**，需要CPU处理

### 2.1.1 系统调用

**1）系统调用的类型**

**系统调用**一般有以下几种：
- **进程控制**：如创建进程(`fork`)、终止进程(`exit`)
- **文件操作**：如打开文件(`open`)、读写文件(`read/write`)、关闭文件(`close`)
- **设备（外设）操作**：如读写设备(`read/write`)
- **通信**：如创建管道(`pipe`)、消息队列(`msgget`)、`mmap`

以**申请内存（malloc）**为例，当`C++`中调用`malloc`函数时，实际上会执行**系统调用**：
- **brk**：对于较小的内存申请，会调用`brk`系统调用
- **mmap**：对于较大的内存申请，会调用`mmap`，`mmap`申请的是**虚拟内存**而不是**物理内存**，当出现**第一次访问**时，会发现该处的**虚拟内存**没有映射到**物理内存**，此时会发生**缺页中断**，操作系统才会将**虚拟内存**映射到**物理内存**中

<img src="user_kernal_state.png" width="80%">

**2）系统调用的过程**

正常情况下，程序是运行在**用户态**内存空间中的

当程序需要执行**系统调用**时，会发现其**权限**不够，此时会产生**中断Trap**（切换到内核态是通过**中断**实现的）

然后CPU跳转到**内核空间**执行**系统调用**

在内核态处理完后，再次产生**中断Trap**，并将**系统调用**的结果返回给**用户空间**

<img src="User_Kernel.png" width="80%">

### 2.1.2 中断

**1）中断的概念**

**中断**是指CPU在执行程序时，由于**外部事件**的发生（通常由IO设备触发），当CPU收到**中断号**时，**CPU暂停当前程序的执行**，转而去执行相应的**中断处理程序**，处理完后再返回原来的程序继续执行。

操作系统会注册**中断号**以及其对应的**中断处理程序**（也就是注册后存在中断向量表中），当中断发生时，CPU会根据**中断号**找到对应的**中断处理程序**，并执行。

其中中断向量表的一个节点如下：

<img src="CruptTable.png" width="50%">

具体执行中断的步骤如下（以键盘按下为例）：

- **硬件**：键盘按下，会通过**中断控制器**发送**中断信号 n**给**CPU**
- **CPU**：收到**中断信号 n**后，会去**中断向量表**中寻找第 n 个**中断描述符**，从中断描述符中找到**中断处理程序的地址**
- **CPU**：通过**压栈操作**保存当前程序的**状态（原来的程序地址、原来的程序堆栈、原来的标志位）**，然后跳转到**中断处理程序**的地址执行
- 中断处理程序执行完后，再通过**出栈操作**恢复原来的程序状态，继续执行原来的程序

**2）操作系统需要中断的原因**

- 针对硬件中断：设想一下，如果没有中断机制，那么CPU在执行程序时，还要不断的去**轮询外设**是否有数据到来，导致CPU的**利用率**非常低。
- 针对软件中断：如果一个应用程序触发了某个操作，需要从**用户态**切换到**内核态**，如果没有**中断机制**，那么CPU会进入**盲等待**状态（等待寄存器空闲）。(**中断机制**可以让CPU在等待时，去执行其他程序)

**3）CPU触发中断的三种方式**

- 通过**中断控制器（外设）**给 CPU 的 `INTR` 引脚发送信号，CPU 从中断控制器的一个端口上读取中断号。
    - 比如按下键盘的一个按键，最终会给到 CPU 一个 0x21 中断号。

- CPU 执行某条指令发现了**异常**，会**自己触发并给自己一个中断号**
    - 比如执行到了无效指令，CPU 会给自己一个 0x06 的中断号。

- 执行 `INT n` 指令，会直接给 CPU 一个中断号 n
    - 比如触发了 Linux 的**系统调用**，实际上就是执行了 INT 0x80 指令，那么 CPU 收到的就是一个 0x80 中断号。

**4）硬件中断和软件中断**

硬件中断和软件中断都属于**硬中断**，只是触发方式不同。

<img src="Currpt.png" width="80%">

**5）硬中断和软中断**

由于中断会打断内核中进程的正常调度运行，所以要求中断服务程序尽可能的短小精悍；但是在实际系统中，当中断到来时，要完成工作往往进行大量的耗时处理。

所以一般 Linux 会把中断分成上下两半部分执行，**上半部分处理最简单的逻辑（硬中断）**，下半部分直接丢给一个**软中断**异步处理。

比如我们进行**网卡**的**数据包**处理时：

- 当网卡收到一个数据包时，将**数据包**放到**内核**的**缓冲区**中，然后会触发一个**硬中断**
- 硬件中断告诉 CPU 有数据包到来并触发一个**软中断**
- **软中断**会在**内核态**异步处理**数据包**的**解析**（如完整性、校验等）

**硬中断**

上述**3）**中提到的三种方式全是**硬中断**（包括中断、异常以及 INT 指令这种软件中断）。整个中断机制是**纯硬件实现的逻辑**，不管触发它的是谁，所以通通叫硬中断。

微观上来说，CPU 在每一个指令周期的最后，都会**留一个 CPU 周期去查看是否有中断**，**硬中断**处理耗时短的操作

**软中断**

**软中断**是处理**硬中断**后，延时处理具体的**耗时**的工作。

**主要区别**

- **硬中断**是由硬件设备直接触发，通常是即时的，需要**快速响应**。
- **软中断**是由**内核代码**触发，可以是**延迟的**，用于处理那些不需要立即响应的任务。

### 2.1.3 异常

**异常**是指程序在执行过程中，由于**程序错误**或**CPU故障**等原因，导致**程序无法继续执行**，**CPU**根据异常类型查找**异常向量表**，找到对应的异常处理程序，进行处理。

## 2.2 用户态与内核态的切换的具体实现

以**Linux系统**系统为例，操作系统会为每个进程分配出**内核空间**和**用户空间**

<img src="memory_type.png" width="30%">

当发生切换时：
- **CPU**会涉及**上下文切换**，将**用户态**原来在**CPU中**的**程序计数器**和**栈指针**等寄存器的值保存到**内核态**的**内核栈**中，以便最后**内核态**执行完逐步出栈后，能够恢复到**用户态**的执行状态

- 保存完后再更新**CPU**的**程序计数器**和**栈指针**等寄存器的值，将其变为**内核态**的值

- 然后才**跳转**到**内核态**执行**系统调用**

- **系统调用**结束后再次进行**上下文切换**，恢复**CPU的寄存器**的值，将其变为**用户态**的值

系统调用过程中，并**不会涉及**到**虚拟内存**等进程用户态的资源，也**不会切换进程**。

系统调用过程通常称为**特权模式切换**，而不是进程上下文切换。

## 2.3 用户态与内核态下的线程问题

实际系统中会存在**用户态线程**和**内核态线程**的问题，关于这部分的**线程**问题将在下面的**进程管理**中详细介绍。

> 参考资料：
> - [Linux下软中断过程（详细）源码总结](https://blog.csdn.net/Luckiers/article/details/123868625 )
> - [系统调用](https://liuyehcf.github.io/2017/08/20/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/)

# 三、进程管理

## 3.1 进程与线程

### 3.1.1 进程与线程的基本区别


- **进程**：**资源分配**的基本单位
- **线程**：**CPU调度**的基本单位

我们执行一个程序时，实际上是**操作系统**为我们创建了一个**进程**，一个进程中可以有多个线程存在

- **操作系统的三大资源**
    - **CPU**
    - **内存**
    - **文件描述符**
- **进程分配的资源**
    - **内存空间**：代码段、数据段、堆、栈等
    - **文件描述符**：打开的文件、网络连接等
    - **CPU时间片**
- **线程分配的资源**
    - **寄存器**：通用寄存器、程序计数器等
    - **栈**：线程独有的栈空间（从进程的**用户态堆**中分配出来的）
    - **CPU时间片**

从最基本的关系来说，**多线程**可以共享其**进程**的**资源（地址空间、文件描述符资源...）**，各个线程之间**独立**地拥有自己的**栈空间**和**寄存器**


**1）线程的优缺点**

- **优点**：开销小、通信方便
    - **创建快**
    - **终止快**
    - **切换快**：同一进程的线程切换不需要切换**资源**，只切换独有的**栈空间**和**寄存器**
    - **通信方便**：同一进程的线程共享**内存空间**，数据传输**不经过内核**
- **缺点**：单个线程出错会导致整个进程崩溃

**2）进程的优缺点**

- **优点**：**稳定性**高
    - **独立性**：进程之间**独立**，一个进程出错不会影响其他进程
    - **资源独立**：进程之间**资源独立**，一个进程的资源不会被其他进程访问
- **缺点**：开销大、通信复杂

### 3.1.2 进程与线程的结构描述

进程和线程的结构称为**进程表**和**线程表**，其中包含了进程和线程的**基本信息**，存储于**内核空间**中。

**1）进程控制块的结构：PCB**

在操作系统中，每个进程具有唯一标识**PCB**（Process Control Block）来描述一个进程的基本信息，进程的PCB是系统感知进程的唯一实体，包括：
- **PID**：进程的唯一标识
- **Name**：进程的名字
- **State**：进程的状态（运行、就绪、阻塞等）
- **Priority**：进程的CPU抢占优先级
- **资源I/O分配**：内存地址、虚拟空间地址、打开和使用的文件描述符等（进程间是通过页表的方式隔离地址空间的）
- **CPU信息**：主要是记录切片中断保存现场的信息，但是其实**PCB**不够大存不下，所以会有**内核栈**来配合存放这些信息
- ......

<img src="PCB.png" width="80%">

**2）线程控制块的结构：TCB**

线程表中存放的信息与进程类似，包括：
- **Thread ID**：线程的唯一标识
- **State**：进程的状态（运行、就绪、阻塞等）
- **Priority**：进程的CPU抢占优先级
- **CPU信息**：程序计数器等寄存器的值

### 3.1.4 进程与线程的状态类型

我们知道，CPU调度采用的是**时间切片**的方式，所以需要有多个状态来描述进程和线程的状态：
- **创建状态**
- **就绪状态**：维护一个**就绪队列**，等待CPU调度
- **运行状态**：该时刻正在占用CPU
- **阻塞状态**：等待某个事件的发生，如I/O磁盘操作读取数据、打印机响应等，避免**占用CPU**
- **挂起状态**：当进程/线程**内存空间**搬至**外存**、`sleep`、**Ctrl+Z主动挂起**时会进入挂起状态
    - **就绪挂起**：内存空间搬至**外存（硬盘）**，但只要重新进入内存就立刻执行
    - **阻塞挂起**：等待某个事件的发生，但只要事件发生就立刻执行w
- **终止状态**：进程或线程执行完毕

各状态之间具有相互转换的关系：

<img src="process_state.png" width="80%">

**1）创建状态**

- 申请**PCB/TCB**，并初始化
- 分配内存资源如**内存空间**，并将**代码段**、**数据段**、**堆**、**栈**等加载到内存中
- 将**PCB/TCB**插入**就绪队列**中

**2）阻塞状态**

当**运行状态**中的进程出现某些系统调用时，如**I/O操作**，会进入**阻塞状态**，等待**事件**的发生

- 找对应的**PCB/TCB**，将其从**就绪队列**中移除
- 经历**运行状态--->保护现场--->阻塞状态**的过程
- 将**PCB/TCB**插入**阻塞队列**中

**3）从阻塞状态唤醒到就绪状态**

当**阻塞状态**的进程等待的**事件**发生后，会进入**就绪状态**（信号触发）

- 查找PCB/TCB，将其从**阻塞队列**中移除
- 将其插入**就绪队列**中等待调度

**4）终止状态**

- 查找PCB
- 从**运行状态**停止，也就是归还CPU
- 子进程变成**孤儿进程**交给**init** **1号**进程接管
- 归还资源给操作系统
- 从**PCB/TCB队列**中移除

### 3.1.4 CPU调度算法

调度关系着CPU的**利用率**和**响应时间**，当进程/线程进入**运行状态**就是占用了CPU，而什么时候占用就与调度算法有很大关系了

**什么时候触发调度？**

总的来说，在上面那张状态图中，跟**运行状态**相关联的**就绪状态**、**阻塞状态**、**终止状态**的出现都会触发调度

- **时间片用完**：出现**就绪态---运行态**的转换
- **发生阻塞**：当出现阻塞事件时，正在运行的进程会进入阻塞状态，此时会触发调度重新选一个进程执行
- **进程终止**

**调度算法**

调度算法是为了**提高CPU的利用率**和**响应时间**，调度算法有**抢占式**和**非抢占式**之分：
- **非抢占式**：进程一旦进入**运行状态**，就一直运行，直到进程**终止**或**阻塞**，才会调度其他进程
- **抢占式**：进程在**运行状态**时，会根据**时间片**或**优先级**等因素，被其他进程抢占，从而调度其他进程（到时就换）

常见的调度算法有：

- **先来先服务（FCFS）**：按照进程到达的先后顺序进行调度
    - 每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。
- **短作业优先（SJF）**：按照进程的**运行时间**进行入队列
    - 每次从就绪队列选择**运行时间最短**的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择**运行时间最短**的进程接着运行。
- **时间片轮转（RR）**：按照**时间片**进行调度
    - 按照公平原则，每个进程都有一个**时间片**，当时间片用完后，会重新进入**就绪队列**，等待下一次调度
- **优先级调度**：按照**优先级**进行调度
    - 每次从就绪队列选择**优先级最高**的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择**优先级最高**的进程接着运行。
- **多级反馈队列调度**：结合**时间片轮转**和**优先级调度**的调度算法
    - 将**就绪队列**分为**多个队列**，每个队列有一个**时间片**，**优先级**逐渐降低，当一个进程**时间片**用完后，会进入**下一个队列**等待调度

## 3.2 上下文切换

当CPU出现**调度**，需要切换到其他进程时，会涉及到**上下文切换**，需要经过**当前进程**的**保存现场**和**下一个进程**的**加载恢复现场**

在切换前程序会先停止运行，然后**触发中断保护现场**，之后操作系统会将**寄存器信息**压栈到**PCB+内核栈**中

现代操作系统都是直接调度**线程**，而不是**进程**，因为**线程**的**切换**比**进程**的**切换**要快
- **线程**的**上下文切换**只需要**切换栈**和**寄存器**即可
- **进程**的**上下文切换**需要**切换页表**、**切换内存空间**等操作

### 3.2.1 触发上下文切换的场景

当出现**CPU当前运行状态的进程/线程需要转换为另一个进程/线程的场景时（也就是发生调度）**，就会触发**上下文切换**，主要有以下几种情况：
- **运行状态<--->就绪状态**
    - **时间片用完，剥夺CPU，通过时间中断实现切换**
- **运行状态<--->挂起状态**
    - **资源不足挂起**
    - **sleep主动挂起**
- **运行状态<--->阻塞状态**
    - **硬件中断**：如**I/O操作**等

### 3.2.2 线程和进程上下文切换比较

要比较两者的上下文切换区别，首先要分别了解**进程**和**线程**的**上下文切换**具体切换了什么内容？


**1）上下文指什么？**

上下文可以分为**用户上下文**、**系统上下文**和**硬件上下文**：
- **用户上下文**：用户态的地址空间（用户空间）、页表等信息
- **系统上下文**：PCB+内核栈等信息
- **硬件上下文**：寄存器、程序计数器等信息

**2）进程、线程、协程上下文切换的内容**

<img src="context_switch.png" width="60%">

### 3.2.3 上下文切换的过程

进程**状态的切换**会触发进程的**上下文切换**，而切换是由**中断驱动实现的**

以进程为例，首先要了解进程的组成，进程的切换中**保护线程**就是围绕进程的组成来进行的：

<img src="process_struct.png" width="80%">

具体过程主要为
- **硬件中断**：CPU收到**中断信号**后，会**暂停当前进程**的执行
- **保存当前进程的上下文**：先将**SP**、**PC**保存至**内核栈**中
- **切换到内核态**：**程序计数器PC**重新指向**内核态**的**中断处理程序**
- **中断处理程序**：执行**中断处理程序**，将通用寄存器保存下来
- **调度新进程**：根据**调度算法**选择新的进程，将其**PCB、内核栈**中的**寄存器**信息恢复到**CPU**中

<img src="process_switch.png" width="80%">

> 参考资料：
> - [用户级thread_内核级thread_内核thread之区别](https://www.bilibili.com/video/BV1PK411w75b/?vd_source=fa61c94b4d0a0af186e3cb794e46eea9)
> - [用户态和内核态：用户态线程和内核态线程有什么区别？](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14%20%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md)
> - [17 进程和线程：进程的开销比线程大在了哪里？](https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/17%20%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%A4%A7%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%9F.md)
> - [5.1 进程、线程基础知识](https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B)

## 3.3 协程

相比于进程和线程**，**协程**是一种**用户态**的**轻量级线程**

**协程 VS 线程**

- **协程**的**切换**是**用户态**的**切换**，由**内核态**调度的（纯软实现），而**线程**需要频繁转换**用户态<--->内核态**，因此**协程**的**切换**速度比**线程**的**切换**速度更快

- 相比于**线程**上下文切换需要**内核态+寄存器**，**协程**的**上下文内容**只有硬件上下文，也就是**寄存器（SP、PC、DX）**的内容

**进程 VS 线程 VS 协程**

|  | 进程 | 线程 | 协程 |
| :---: | :---: | :---: | :---: |
|**切换内容**| 用户态（页表）+内核态+硬件上下文 | 用户态+内核态+硬件上下文 | 硬件上下文 |
|**切换位置**| 内核态 | 内核态 | 用户态 |
|**切换速度**| 低 | 中 | 高 |

**协程的实现**

协程属于**用户态**的**线程**，因此其实现是在用户态的**堆**中malloc出来的**栈空间**，并在**用户态**中进行**切换**，**切换**时只需要**保存寄存器**的信息即可

根据堆中开辟空间的方式，**有栈协程**可以分为**独立栈**和**共享栈**两种：

- **独立栈**：每个协程都有自己的**栈空间**
    - **优点**：**切换**时只需要**切换栈指针**即可，无需再次拷贝，因此比较快
    - **缺点**：独占内存资源，**栈空间**较大时会占用较多内存
- **共享栈**：所有协程共享一个**栈空间**
    - **优点**：节省内存资源
    - **缺点**：**切换**时需要**拷贝栈空间**，因此**切换**速度较慢

在堆区中，协程的空间通过**esp**和**ebp**来控制
- **esp**表示**栈顶**
- **ebp**表示**栈底**

<img src="coroutine.png" width="20%">

## 3.4 进程间通信

进程间通信主要有**管道**、**消息队列**、**共享内存**、**信号量**、**信号**、**套接字**等方式

### 3.4.1 管道Pipe

管道是一种**半双工**的**通信方式**，由**读端**和**写端**组成的**单向**通信方式

我们最常见的Linux中的指令`|`其实就代表了**管道**的使用，如`ps aux | grep mysql`

<img src="pipe.png" width="50%">

**1）存储方式**

- 管道属于**内核里的一块缓冲区**
- 数据无格式
- **读端**读取数据后，**缓冲区**中的数据就会被清空
- 大小有限，**满了**会**阻塞写端**，**空了**会**阻塞读端**

**2）缺点**

通信效率低，不适合**大量数据、频繁通信**的场景

### 3.4.2 消息队列MQ

**1）存储方式**

- **消息队列**是以**消息链表**的形式存储的
- **消息队列**中的**消息**是有**格式**的，可以是**结构体**等
- 有固定大小的存储块

**2）优点**

- 适用于频繁的数据交流

**3）缺点**

- 通信不及时：**消息队列**是**异步**的，**发送**和**接收**消息的时间不一定是同步的
- 存储块有限，不适合**大量数据**的通信
- 存在用户态和内核态的**数据拷贝**开销：**发送**和**接收**消息时，需要**数据拷贝**，效率较低

### 3.4.3 共享内存

**1）存储方式**

通过拿出一块**虚拟内存**，然后**映射**到**物理内存**中，实现**共享内存**的通信

**2）优点**

通过**映射**的方式不需要**数据拷贝**，效率较高

### 3.4.4 信号量

信号量只是一个**计数值**，通常用于进程or线程的**数据同步**、防止多进程竞争共享资源

信号量有两个关键操作（P&V操作）：
- **P操作：请求资源，对应C++的.wait()**
    - 信号量减1
    - `sem<0`：阻塞，表示无资源可用
    - `sem>0`：继续执行
- **V操作：释放资源，对应C++中的.signal()**
    - 信号量加1
    - `sem<=0`：唤醒一个等待的进程

## 3.5 其它进程类型

进程有多种类型，主要有**孤儿进程**、**僵尸进程**、**守护进程**等，通过Linux的`ps`命令可以查看，进程间通过pid号来区分

### 3.5.1 孤儿进程

**孤儿进程**是指**父进程****退出**后，**子进程**还在运行

此时**子进程**的**父进程**会被进程号为1的**init**进程接管，操作系统会定期清理**孤儿进程**

### 3.5.2 僵尸进程

进程**exit()**退出内核后会**释放该进程的所有资源**（打开的文件、占用内存等），但是不会主动**回收**该进程的**PCB**，也就是该**进程号**还一直被占用

**僵尸进程**是指一个**子进程**已经**exit()**，但是**父进程**还没有**回收**它的**PCB**，导致**子进程**的**PCB**一直保存在**内核**中，这种进程就是**僵尸进程**

**僵尸进程**会占用**系统资源（进程号有限）**，因此需要**回收**它，回收有两种方式：

- **父进程主动回收**
    - 子进程退出时发送**SIGCHLD**信号给父进程，父进程通过**wait()**或**waitpid()**回收子进程
- **Kill父进程**
    - 当父进程退出时，子进程会变为**孤儿进程**，被**init**进程接管并定期清理

### 3.5.3 守护进程

**守护进程**是一种在**挂在后台**运行的进程，通常用于**系统服务**的启动和管理

它会定期执行一些**系统任务**，如**日志清理**、**定时任务**等；其父进程是**init**进程，因此不会成为**僵尸进程**，同时操作系统结束它才会结束

## 3.6 多线程同步问题

多线程之间会存在**资源竞争**的问题，因此有**互斥**和**同步**的问题
- **互斥**：某段代码同一时间只能被一个线程访问，其它线程需要阻塞等待进入
- **同步**：多个线程之间的**数据互通**需要协调工作，如**生产者-消费者模型**、**读写锁**等

### 3.6.1 为什么多线程需要同步？

假设有多线程共享的变量`i`，当执行`i=i+1`时，实际上在汇编层面上不是一个原子操作，而是分为**读取**、**计算**、**写入**三个步骤：
- **读取**：内存中`i`的值-->寄存器中
- **计算**：寄存器中的值+1
- **写入**：寄存器中的值-->内存中`i`

因此多线程很有可能在其中某个步骤被**抢占**，导致**数据不一致**的问题

<img src="crrupt.png" width="60%">

在文章[从0开始实现线程池(C++)](https://akirazheng.github.io/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/#/%E4%BA%8C%E3%80%81C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0)中有介绍**互斥锁解决多线程数据共享问题**以及**死锁**问题的代码模拟，这里不再赘述

### 3.6.2 实现同步的方式

实现同步有**加锁**和**不加锁**两种方式：
- **不加锁**：通过原子操作来保证数据的一致性，如**CAS、TAS**等
- **加锁**：通过**互斥锁**、**读写锁**、**条件变量**等方式来保证数据的一致性

也可以将锁分为**乐观锁（通常也是无锁编程）**和**悲观锁**：
- **乐观锁**：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作
    - 重写成本高，不适合冲突频繁场景
- **悲观锁**：认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁
    - 适合冲突频繁场景
    - 锁住等待的成本高

各种锁如下所示：

<img src="lock.png" width="100%">

### 3.6.3 死锁问题

在文章[从0开始实现线程池(C++)](https://akirazheng.github.io/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/#/%E4%BA%8C%E3%80%81C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0)中有介绍**互斥锁解决多线程数据共享问题**以及**死锁**问题的代码模拟，这里不再赘述