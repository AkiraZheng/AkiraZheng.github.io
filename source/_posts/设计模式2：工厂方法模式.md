---
title: 设计模式2：工厂方法模式(C++)
date: 2024-02-02 12:27:14
tags:
categories:
- 设计模式
---

## 前言

> [本文中所有设计模式Github代码](https://github.com/AkiraZheng/designPattern/tree/master/designPattern)
其中本文**工厂方法模式-简单工厂**相关代码在`FactoryMethod_SimpleFactory.h`文件中
本文**工厂方法模式-工厂方法**相关代码在`FactoryMethod.h`文件中

> 工厂方法中，一般一个应用中每一个工厂系列只需要一个ConcreteFactory类的实例，因此设计工厂类时，通常将其设计为单例模式

## 一、简单工厂

### 1. 什么是简单工厂

简单工厂中，设计的核心思想是**将对象的创建和使用分离**，即将对象的创建交给工厂类（非抽象类），而将对象的使用交给客户端。

在**简单工厂**设计中，工厂类采用通常使用**switch-case**语句来根据不同的条件创建不同的对象，这样的设计是**不符合开闭原则**的，因为每次添加新的产品都需要修改工厂类的代码(在switch-case语句中加入新产品的create代码)，代码灵活性很差。

因此需要将简单工厂的设计升级为工厂方法模式，在工厂类中使用纯虚函数方法(createProduct方法)将其设计成抽象类。

> 开闭原则：对扩展开放、对修改关闭；
也就是说，我们可以添加代码，但是添加代码的时候**不能够对现有的代码进行修改**

### 2. 简单工厂的代码
- 代码UML类图
    <img src="SimpleFactory.png" width="90%" heigh="90%">

```c++
/*产品类的设计：抽象基类*/
class Phone{
    // 产品基类
public:
    Phone(string name):_phone_name(name){};
    virtual void show() = 0;
    virtual ~Phone(){}; //基类应该被声明为虚析构函数
protected:
    string _phone_name;
};
class Iphone:public Phone{
    // 产品派生类
public:
    Iphone(string name):Phone(name){};
    void show(){
        cout << "I have a phone named: " << _phone_name << endl;
    }
};
class HuaWei:public Phone{
    // 产品派生类
public:
    HuaWei(string name):Phone(name){};
    void show(){
        cout << "I have a phone named: " << _phone_name << endl;
    }
};
```
```c++
/*工厂类的设计：非抽象类*/
class PhoneFactory{
    // 工厂类
public:
    enum phone_type{
        IPHONE,
        HUAWEI
    };
    Phone* createPhone(int type){
        switch (type)
        {
        case IPHONE:
            return new Iphone("iphone");
        case HUAWEI:
            return new HuaWei("huawei");
        default:
            return nullptr;
        }
    }
};
```
```c++
/*测试函数*/
/*测试函数*/
void testFactory_simpleFactory(){
    PhoneFactory factory;
    Phone* p1 = factory.createPhone(PhoneFactory::IPHONE);
    Phone* p2 = factory.createPhone(PhoneFactory::HUAWEI);
    p1->show();
    p2->show();
}
```

## 二、工厂方法模式

1. 工厂方法相较于简单工厂的改进

    - 简单工厂中，**产品基类**是**抽象**的，而**工厂类**是**非抽象**的，这样的设计是不符合开闭原则的
    - 工厂模式将**工厂基类**也设计成一个**抽象**的，并针对不同的产品类型设计不同的**工厂派生类**，这样在用户使用的时候可以很有目的性地选择对应的工厂派生类进行初始化，而不是简单工厂中的switch-case语句的随机性选择。

2. 工厂方法的缺点

    - 工厂方法模式的缺点是**每增加一个产品，就需要增加一个产品工厂类**，这样会导致工厂类的数量增加，增加了系统的复杂度。
    - 工厂方法中的工厂类**只有一个create方法**，因此当产品不断增加时，需要的工厂派生类也不断增加，这样不利于管理，因此需要将工厂方法模式升级为**抽象工厂模式**。

## 三、工厂方法模式的实现代码（C++）

> tips:使用智能指针需要引入头文件`#include <memory>`，使用普通指针**new**之后记得**delete**

- 代码UML类图
    <img src="FactoryMethod.png" width="90%" heigh="90%">

```c++
/*产品类的设计：抽象基类*/
//1. 产品抽象基类
class Phone{
    // 产品基类
public:
    Phone(string name):_phone_name(name){};
    virtual void show() = 0;
    virtual ~Phone(){}; //基类应该被声明为虚析构函数
protected:
    string _phone_name;
};
//2. 产品派生具体类
class Iphone:public Phone{
    // 产品派生类
public:
    Iphone(string name):Phone(name){};
    void show(){
        cout << "I have a phone named: " << _phone_name << endl;
    }
};
class HuaWei:public Phone{
    // 产品派生类
public:
    HuaWei(string name):Phone(name){};
    void show(){
        cout << "I have a phone named: " << _phone_name << endl;
    }
};
```
- 说明：在工厂抽象类设计时，具体工厂一一对应用于new一个具体产品，当具体工厂类创建时，不同具体产品要求的的参数不同时，可以将参数也设计成一个抽象基类，这样在具体工厂类中可以根据不同的参数创建不同的产品。
```c++
/*工厂类的设计：抽象基类*/
//1. 工厂抽象基类
class PhoneFactory{
    // 工厂类
public:
    virtual Phone* createPhone(string name) = 0;
    virtual ~PhoneFactory(){}; //基类应该被声明为虚析构函数
};
//2. 工厂派生具体类
class IphoneFactory:public PhoneFactory{
    // 工厂派生类
public:
    Phone* createPhone(string name){
        return new Iphone(name);
    }
};
class HuaWeiFactory:public PhoneFactory{
    // 工厂派生类
public:
    Phone* createPhone(string name){
        return new HuaWei(name);
    }
};
```
```c++
/*测试函数*/
void testFactory_factoryMethod(){
    unique_ptr<PhoneFactory> iPhoneFactory(new IphoneFactory());
    unique_ptr<PhoneFactory> huaweiFactory(new HuaWeiFactory());
    unique_ptr<Phone> iphone(iPhoneFactory->createPhone("iphone"));//通过单独的Iphone工厂创建对应产品
    unique_ptr<Phone> huawei(huaweiFactory->createPhone("huawei"));//通过单独的HuaWei工厂创建对应产品
    iphone->show();
    huawei->show();
}
```

## 四、Reference

1. [C++工厂模式（简单工厂、工厂方法、抽象工厂）](https://blog.csdn.net/m0_46308273/article/details/117126962)
2. [工厂方法模式](https://github.com/youngyangyang04/kama-DesignPattern/blob/main/DesignPattern/2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.md)