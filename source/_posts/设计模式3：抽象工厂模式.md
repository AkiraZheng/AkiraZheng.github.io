---
title: 设计模式3：抽象工厂模式(C++)
date: 2024-02-02 19:41:09
tags:
categories:
- 设计模式
---

## 前言

> [本文中所有设计模式Github代码](https://github.com/AkiraZheng/designPattern/tree/master/designPattern)
其中本文**抽象工厂模式**相关代码在`AbstractFactory.h`文件中

## 一、抽象工厂模式

### 1. 什么是抽象工厂模式

抽象工厂模式是指**提供一个创建一系列相关或相互依赖对象的接口**，而无需指定它们具体的类。

抽象工厂模式是工厂方法模式的升级版：工厂方法中，一个工厂只能生产**一种**产品，当需要生产多种相关的产品时，如手机生产厂商**既生产手机又生产手机壳**，这时就需要使用抽象工厂模式，将手机和手机壳的生产分别交给两个工厂，再将工厂细分为具体的产品。

### 2. 抽象工厂模式优缺点
#### 优点
- 抽象工厂模式可以在**不修改**具体工厂类的情况下引入**新的产品**，即**增加新的产品族**，满足开闭原则

- 抽象工厂模式可以保证由**同一个工厂类创建的产品**之间的兼容性

#### 缺点
- 抽象工厂模式的**扩展性**是有限的，**增加新的产品族**时，需要修改抽象工厂类，不符合开闭原则

- 客户(Client)必须知道抽象工厂的所有具体工厂类，才能根据需求创建对应的工厂实例

### 3. 抽象工厂模式设计原理
- 依赖倒置原则：高层模块不应该依赖于底层模块，两者都应该依赖于抽象
    - 这里的高层模块是指客户端，底层模块是指具体产品类，抽象工厂中客户端依赖于抽象工厂类，而不是具体工厂类，因此当工厂类产品系列更换时，只需要更换具体工厂类，客户端不需要修改代码
- 开闭原则：对扩展开放、对修改关闭
    - 当引入新的产品时，只需要增加对应产品的具体工厂类，而不需要修改抽象工厂类
- 接口隔离原则：使用多个专门的接口，而不使用单一的总接口
    - 抽象工厂模式中，每个具体工厂类都有自己的接口，而不是使用单一的总接口

### 4. 简单工厂、工厂方法、抽象工厂的区别
- 简单工厂模式：一个工厂方法创建所有具体产品

- 工厂方法模式：一个工厂方法创建一个具体产品

- 抽象工厂模式：一个工厂方法可以创建一类具体产品

## 二、抽象工厂模式的实现代码（C++）
- 代码UML类图

<img src="AbstractFactory.png" width="100%" heigh="100%">

```c++
/*手机产品类的设计*/
class Phone{
    // 产品基类
public:
    Phone(string name):_phone_name(name){};
    virtual void show() = 0;
    virtual ~Phone(){}; //基类应该被声明为虚析构函数
protected:
    string _phone_name;
};
class Phone_Iphone:public Phone{
    // 产品派生类
public:
    Phone_Iphone(string name):Phone(name){};
    void show(){
        cout << "手机工厂生产具体产品: " << _phone_name << endl;
    }
};
class Phone_Huawei:public Phone{
    // 产品派生类
public:
    Phone_Huawei(string name):Phone(name){};
    void show(){
        cout << "手机工厂生产具体产品: " << _phone_name << endl;
    }
};

/*手机壳产品类的设计*/
class PhoneShell{
    // 产品基类
public:
    PhoneShell(){};
    virtual void display() = 0;
    virtual ~PhoneShell(){}; //基类应该被声明为虚析构函数
};
class PhoneShell_Iphone:public PhoneShell{
    // 产品派生类
public:
    PhoneShell_Iphone(){};
    void display(){
        cout << "手机壳工厂生产具体产品: Iphone壳" << endl;
    }
};
class PhoneShell_Huawei:public PhoneShell{
    // 产品派生类
public: 
    PhoneShell_Huawei(){};
    void display(){
        cout << "手机壳工厂生产具体产品: Huawei壳" << endl;
    }
};
```
```c++
/*工厂类的设计*/
class AbstractFactory{
    // 抽象工厂类
public:
    virtual Phone* createPhone() = 0;
    virtual PhoneShell* createPhoneShell() = 0;
    virtual ~AbstractFactory(){}; //基类应该被声明为虚析构函数
};
class PhoneFactory_Iphone:public AbstractFactory{
    // 具体苹果工厂类
public: 
    Phone* createPhone(){
        return new Phone_Iphone("Iphone");
    }
    PhoneShell* createPhoneShell(){
        return new PhoneShell_Iphone();
    }
};
class PhoneFactory_Huawei:public AbstractFactory{
    // 具体华为工厂类
public:
    Phone* createPhone(){
        return new Phone_Huawei("Huawei");
    }
    PhoneShell* createPhoneShell(){
        return new PhoneShell_Huawei();
    }
};
```
```c++
/*测试函数*/
void testAbstractFactory(){
    unique_ptr<AbstractFactory> iphoneFactory(new PhoneFactory_Iphone());
    unique_ptr<AbstractFactory> huaweiFactory(new PhoneFactory_Huawei());
    unique_ptr<Phone> iphone(iphoneFactory->createPhone());//通过单独的Iphone工厂创建手机产品
    unique_ptr<PhoneShell> iphoneShell(iphoneFactory->createPhoneShell());//通过单独的Iphone工厂创建手机壳产品
    unique_ptr<Phone> huawei(huaweiFactory->createPhone());//通过单独的HuaWei工厂创建手机产品
    unique_ptr<PhoneShell> huaweiShell(huaweiFactory->createPhoneShell());//通过单独的HuaWei工厂创建手机壳产品
    iphone->show();
    iphoneShell->display();
    huawei->show();
    huaweiShell->display();
}
```
## 三、Reference

1. [C++工厂模式（简单工厂、工厂方法、抽象工厂）](https://blog.csdn.net/m0_46308273/article/details/117126962)