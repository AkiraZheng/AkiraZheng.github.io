---
title: 文件描述符
date: 2024-05-18 21:08:33
tags:
categories:
- 操作系统
---

# 一、内核缓冲区Page Cache

进程在调用write函数写入文件描述符时，其实不是直接写入文件，而是
- 先**中段**到内核空间
- 然后再由内核空间写入**内核缓冲区Page Cache**(因为内核缓冲区相较于磁盘I/O速度更快)
- 最后内核会在适当的时机**将内核缓冲区的内容写入磁盘**

通过这种机制，可以**减少操作磁盘I/O的次数**，提高磁盘I/O效率（当然也可以通过`mmap`函数将文件映射到内存中，这样就可以直接操作内存，内存中的操作既快速，又不用经过内核态<-->用户态的切换，更加高效）

如果想立即将内核缓冲区的内容写入磁盘，可以调用`fsync`函数（调用`fflush`函数也会将缓冲区的内容强制写入磁盘，而不等待缓冲区满再刷新）

# 二、零拷贝技术：mmap

磁盘相对于计算机中的CPU、内存来说，属于慢速设备，因此针对磁盘的优化，有我们上述讲到的**通过内核态中的缓冲区Page Cache减少I/O访问次数**，还有通过**零拷贝技术**来减少数据在内核态和用户态之间的拷贝次数

如果通过中断的方式，当我们发生系统调用`read`时，内核会将**磁盘中的数据拷贝到内核缓冲区(第一次拷贝)**，然后再将**内核缓冲区的数据拷贝到用户缓冲区**，这样就发生了两次拷贝

<img src="two_copy.png" width="80%">

也就是说在大量数据拷贝过程都需要**CPU**参与搬运，这样会浪费CPU资源，降低效率

因此进一步可以通过**DMA直接内存访问技术**进行优化：
- 在不占用CPU资源的情况下(此时CPU可以执行其它任务)，将数据从磁盘拷贝到内核缓冲区

- 当DMA读取了足够多的数据，再通知**CPU**将数据从内核缓冲区拷贝到用户缓冲区，这样就只发生了一次拷贝

<img src="one_copy.png" width="80%">

即使采用**DMA**技术，还是需要通过**CPU**进行一次拷贝，具体通过`read`和`write`的流程如下所示(**各发生2次用户态<-->内核态的上下文切换**，一次切换需要耗时几十纳秒到几微秒；以及**各发生一次DMA拷贝+一次CPU拷贝**)：

'''shell
read(file, buffer, size)
write(socketfd, buffer, size)
'''

<img src="read_write.png" width="80%">

而实际上，多次拷贝是没必要的，我们可以通过`mmap`函数将文件映射到内存中，使`read`和`write`直接操作**共享的内核缓冲区**，这样就可以**减少一次拷贝，但也不是完全的零拷贝**，具体流程如下：

'''shell
buf = mmap(file, size)
write(socketfd, buf, size)
'''

<img src="mmap.png" width="80%">

真正的零拷贝是Linux上提供的`sendfile`函数，它可以直接将文件描述符之间的数据拷贝，而**不需要经过用户态，完全存在内核态中，只经过2次拷贝**，具体流程如下：

'''shell
sendfile(out_fd, in_fd, offset, size)
'''

<img src="sendfile.png" width="80%">

> 参考：[什么是零拷贝？](https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-dma-%E6%8A%80%E6%9C%AF)

# 三、I/O多路复用技术

## 3.1 Linux中的五中I/O模型

- **阻塞I/O**：调用`socket.read()`或`socket.write()`时，如果没有数据可读或写，会一直阻塞等待，直到有数据可读或写
  - 适合计算密集型，因为计算密集型消耗的是CPU资源
- **非阻塞I/O**：不断轮训查看数据是否准备好，所以非阻塞I/O也不会交出CPU
  - 适合传视频，一直占用CPU减少线程切换的成本
- **I/O复用**：通过`select`、`poll`、`epoll`等函数，可以同时监听多个文件描述符，当其中任何一个文件描述符就绪时，就可以进行读写操作（监听的文件描述符本身也是阻塞的）
- **信号驱动I/O**：通过信号来通知应用程序I/O已经完成
- **异步I/O**：通过`aio_read`、`aio_write`等函数，可以在I/O操作完成后通知应用程序（应用程序发起I/O后可以直接进行其它操作，不用等待I/O完成）

在文章[WebServer学习3：socket编程与epoll实现I/O复用](https://akirazheng.github.io/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/#/%E4%BA%8C%E3%80%81I-O%E5%A4%8D%E7%94%A8)中已经有详细介绍，这里不再赘述

# 四、事件驱动模型

在文章[WebServer学习4：并发事件驱动模式Reactor和Proactor](https://akirazheng.github.io/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/)中已经有详细介绍，这里不再赘述