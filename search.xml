<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Asyncflow项目1：环境部署</title>
    <url>/2024/06/14/Asyncflow%E9%A1%B9%E7%9B%AE1%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="错误密码，请重试" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a1cab0e727ac860f6843ab2d20c9eaa9f54ee1d83534323be4140c06e7533f4e">e67aaf3b219a461d5f53a135dd966c7e1d838eaa3a61bc019116235e7e147a204975e05e2504a8d96fb25f9057aca4fa8b658124d3c7cb246833241bbc7c951e21f0c90e5081e6c05c3488ac773da3313ba9e9b7eeab8cd4d911492d9739e4ebc45abece53ad1a20e46608f55483d7765bd3217363fbf3d2e1bdd3432b32df0b76458b4d2ee923d73959e0a8d3fe5cc06796e020fb4abe347240fe26c181cb1e02b58ef659eede01c7776bfca03c8444891e2b47048a9bff09a9c02730be797924b90e807e89a7dfa7931e98742c174c9d3a424fa8d817d4915fe106a7b1bd78dbf7cd03601c831332458e79decda75df2b4ca47095663d3b180c86fea25d2090c1a76568e7e6cae169546b20d0576c60bd8eadf81d9b6cbc59c3ee50c39faf775bf9737a1746957fda60f4dba65057f27d43e7eef1152f2f65d668c24b2c40bc90aa6f58b43021e2a69d422ef1c3b93c6d19e81c5dd69598b625867832e435a58fa6b07c5cd565117a9ff173afee32b0b4f9119e28a55d7306fd192e59a5feb071d62d2c13ef32e2117d5123f49efeffb57507a4aadb3d96e82f7c54e92047f817c3afb570d469bf55742f6e26cb51a9d6db6e9c3d1ed921d71c5fd34a2911fb41240308ffd5ebfae12c0e7b12d7ee57f6a0ff5cd98d4fe587213748a27323765a9a70f6af50794262efb30900310c2d97918b3a4ad829fc07a7163e1d8e029b3cbe6400fff4f9157df877be0fe7708ab0e6d440bf9b5e80a52c4d562a73c96025c589fa59e9906b5d5607a545937b3cfea6c038ef0002d423001414d702cea2542845d3ce085179430f2b173950855602059544d8aa63352f816420a3c98a70b15a584cbd4349ea7a93a92a2996a72f1b047d4dce8ac3b302092e57b2bd12da5ab8ba0158abd1e2c1380d3b7da5d50bf0ce44d759c0d752f655991873ae2334041f0e20ea00e2100cc786a4dae83fd51dfa3745c8435457598b8a1cdca67d3fd8ae85cfe0f5e7c9b8ebdc4005c4861f18f28180e225d1f886afad7629ee45876bf2687dde4b85d0e8b4f2e7154aa648c4f16bddcd3dea55508e0ef857d974d5a15740f4a238f76791ea46463cc564674032dd74fdcc53feb1ebebf0ff1455a9fc2b522f826cf6bb1e7e8e0dfda6e36740d76a6a292688ae17ba2e7f64e3a07f27cc6edb9a62b0b1aa2998431e4ed6d3bde0f65ef9efdc3931db3c429d520bd1936af784df49ec388de8a58ec4248d3d2283f54362a70fb4cff7d4308d410c95d7cf78a7fa3342c7f05cda7f2fcc4e31e7204d191495f32e35145b076d3d602fbad559cf91294505fc0a5e825347f30a5b78858b56681b1f66b4b4fe188fcc7aa3f3b44150e2783efe45ec53ba1766e12a4be11f0061ce6edc3942e1af89aab9e79a69b88857e42e285c98cb4ec6c3508a418dc04bb5328962b618844e1835c2687071cad722a0172488339cb2a48d6b432fc416b92ba9d9bae5968a0c36c4b620959cf76edffcdb09ab9b7460550f16753c7381585047bbae120c41300a345ff93fd5e7223de0368c01b365bd224da0f8741df76c6a71b968aa89f235f2f78f1c4627e7e4661938459f6d313005bc9665da6b92c6da4ad952eb3d80a7caf20ed78dd350ca57a35948e07034b8b9e7e4aa9c3c870e942e283502b89b91bf67090f81afba6301ea8367b4f151c644e7e2dc66aa893d361db0b00764ba3cb8143a9acea067ead3faa1d96626648c34b536d5b390a0e6b82f88f9e3cd1c5dfb1f1b800ca662a0e22f6c7f7235838861a33fa7bb655331a1cba17c84726c947d4c728f684f9297855d91a135b7ec97244f2c41113ee9f41bb851775e823a26378288c94ebd3c20afb44ba064fe528297d090a6f9625f4db9e500695489947102b9419d8df5d0b5a6e236851fa925ad63b2c4bc7881cbd28b26128cd58e12a4e931316123c2d0e4cdd828c4645da1ba07605042bef8e548fe5cc8509d0bf391ce6aa96e9cca6f1a657be722cb6e8d49672558e9d576c7c08b63e67a47a08676d6694c02be548b9acf8b57eafd3a9cc6da5a579f4d00e1acd027209b7f44eb4700ea74dce69018cca687b32496106486af51b644b9f5ea35738e074c2fde50ac015026b11939200f73367a15959d18fbc0434c19139e2f51711e7cc65f6a76ec89674dc3e641104d05a6131cef42792b4556412eb789795b1739f5bb996489f03def1c5898b18708dbff328f87b61fabc19068f5ee22dc4e78bbb5673125f92773e18d1933082a1a46c45edaded86c23e468b2830e1f0203fb3b029138f5256f1d57ae86122a97992bfe654dfb05223971af756ad68767621378865821565878bd051b9b4a78e590273233378f8666c99743db8b574b14be89c9935bdb2d4e6c7a43309fcd6ab8f9b0fa2996683b514490a7daa091d3a8d4ba9e49176f4c6366de9f6834b51726c6cd9b1a32da0b4786f14122b22285f5ac526061bfe08f6954af02a8c0423dfda86ca4025a8aa4ff4fca012f03d433e444039340b9d66b32a2b8db8e6029c63139f4176d7045a9d72e09116680bb0185938ce45ee7c55c46698a9a02764b3be509b2532e5c4f2d03280f5b019388e562cb62ee843ebb7f6598763149ddbe5b2bf4d99dec1801608875219e8918c12d4c27b6f835666eec69af3b357914c6b610373aab2271a4e75e0fbaee6a8119c130a03eaa4a2734021149311ced2d761d6dca74fbac8eeaae5cfacf02c40af2904ec66e042bcd3e927a6dc77ccffe4e665866b5ce48d238d5b5fc43de96ffd244053f32894a85a8677fe491bee2df583321aa6cfc4482410c120951e942bc4ea75e6ebab5d9d9628e5ac18e480677218a08263c60c9a64f3559ebd2e6ec818a9d93e4db3912f4816547a7b5a9b97a22e3c9424ecbdb7bcea0fb74ff3c3a572d4bd93940efb8d9294b80c3fa8e9ab27b49630410124b7d2c799b164016104375e134363b084e93c49645977cab2442a0895774ead00e436b01322639b98547a6a3c88510992f5da48db9b03ef2906e2c06da542bf0f4352f177ac869b631bd0f8ada16f52c4d3cfc855f2adf60f861e92a78678f2aab38e3fb0fe1a46116ebd8865667e1a943e9a643ea91632701c0d45640688450277d7b3c0c8604da5769a801e7632c0c97ab727d7cd8f4f1bd55218c39381de8dec0cafb4498c8a363ed559f18714453d12a2c2417f0770b3ba4603cffe65405c8e3572f7d042fd6cbd173676a29b4c75d7a59e798c17c6de9bd33dacef37538bbb5d85be8dd9a96b712458a4f73a1f5b18fa58958c10ad33853e93b3bf3b363ad6639c60e03b4167c27b0a917faf8a6f25c5390e2239e7034363aeec4f7d614e578d5716ca00b33afa7bd508e0aec2b88f604f1e62209725ae4816f22c78e6324f5b70e8a0c0eaa12b5146ca12e1550e18b2b09e572bb19bb9e616635c29f0c3de5899ae9edaf144b5f108d5d7ee5e1a6b1ca03b301824a6566e5732e5303a2f8dbb28390afad672c790897140d299779c2cdd015c5936b0fa3b246fc65f44a2258c3cc309352ed481b0d1e8c60f8ecdf67b71dde88724d92bc681e4bc563af4df4e850ea614d13a8a800879254a60cb4dae6cc48ab9dbdfb0601ad875d6a1be64c79fc44fb771dfa962ffc81e18ad96bdf5de2a732eaa127aaebd8ab768feed2f27f7cdcb17b9e1b350c692c4546eb7b2cb489493d2cafd54c9402be2610d5e7518fb8ad04e5753a8062f61d1f58b7a6c2eb37e6bf969332b0efd9323942e7e989cdc74d7db6331c062cadf465a38ff07ce51239c2ad0a7d7e48b6bfaf3f93802ab3ffb1fb4cbadacb8d3161653f50d94b2377ad9216d220ceb003fc7a003634410f7015b276f18d95663ccfc02ed8796a64007bf7268052d64fcd469f408474d14ad11d6e3eea22362eae07e22360e33c9a86b7f1ae60ab51e0538a8847376b69a3094c0843da20f766b379dcfed074c246b0518362c8384f0dd4abf086f946a5e58dc4f4c04f7c6fd155cc9dc88a70a3b11df9aadc40088b933b22f5c78b463112b21f2f4cb65d389183873e695707b7f1b14a56afd23cc4bfa69d164b20d5ccbc573c6bd54088b1231031c1e74891bc5929818ec7f72e1e57d1b87c49ece1d3b0af2c9fa4a07e459b98b2a2234bfbd723c763885cd9a40eff36ecd8694a5739c13fc7b500ee138ead2571a9986dc5ffd2fdcd67c554f552c113167367e004b59dad81ed1b0f6e31060826165c462cbae9bcf8b4328083fdffa4fd8d2deabc0545464031b82ccec4efde86dfe675ec2fed0ac24bcd6bb3108f67e4f7bd8c769fe048e6ea5d058b8a566f42911738dab9a887cdf4cf322c52706023c840deab48dc5ffd157a47186329e9b0e12ed7626790360471c51d431afb0a4762d7a4a1da66f430946e29af238b7f573746e0a449364736a81bb9e875ffa1ed07be0db69c50303bad93744f696d3c6d9e851b1a711d4b35088171dbd4c77e604478cb7454d01aa8043b72dda587b9aa7c7a0b9e7ed278476e785a29c6931d27538c35fa21feb3cea62a74b64ef09fbd2539c52a15463c11dc82837724078ca072c99734097b73376a6ebc897e492a31f61c1bf66cb4b0c28af9e435973c16fe59347af1ec2811c33f89513d884dafb6d10fb6cb4be77a85a1724b38f01b810aac826f26bcc4f62cc4233dd471e084d8ae579eda8f8f02186297cb02fe01308493eed49d6ad7e8c81d723f0efad57ab0af03ed874292ff7d7da521537aa3dc9e03041ad52ebf0383cf6dfaf8710660ad95caf735acc0a563657a21e1f868e4d54de00131618a9b57b092de6c2e4d83f78a9b6c919eaab447b95d4f8996f89fccae2117cbca7b110bdc338ef5b01a042a202135601790283f286d702d9673ef60467d93e8b521aa936f3de2e8ad284eba4fe05b9d7cef03955adf730bc1b9271c03fb2a69e49a2d581b57e605be44ed6be360a086e08150e434e93401e77f78e7f5dd2a374585e06c6b5356b01900a39c034e20dfacd99efda2099a9232fa227cd37920d575e83f00f33854956562127095b7bcf00c085e6528877a9749d340cf9d883d5e0864f4cbda968ee69bd11139d5d632e1e43dc056463197c3dd4300c15db70ce6493914c18135897a409ba08bd0e7113d1aa93fd2e2ba8385ef3a395b25fd3655c6354d21026ffe926abf23983f8ac696c98fec11b694d2f7ed171683e8a53babdf9e93a07b0245ddb9f03cc3c6bfd7607f0e67a778d6d4da43f8d45aa5886c13ffa7e89e91cf4a356584636dcb790e9d8bdaa65d24fd201fb667f8c64d898d254eceade760e0f941b71d108e529a5ff69509ff1e4695fc294ccf9353b8028c1e9d4c0eec7244480eafc8c37dd66c58e038be73ad9aab74c46c3b2181e5fc03e563a889016b1d4dafdb6d77e9aa58a7db541d8cdf73a8a3223c75f59becb31b3ffc9eb93210fd56a48c4307d7c971998d3587fdb0bcde4464b6bffb810545d9a1c68865df6c4d0689fa923aaf519b57f8566e540afc29deaa5b4a0613dbd77b8c03d283f13fd8e77c8f942f19f63f758a36796c9ece923e7b9a86834c609f782e90a3743d034d2b78652225eb181bf616030b16698e36855e38f4226c9f26e6a8d0322945cf6d45e6890562aed36d1bc48a5786004b0dc39875ec3f1746536afce462f4f60e68c2bfbbec5df0297673b81bcc25f52b13f9bebf409834dedd0db202d71286e7b68bb903df0ff9db45af880355ab8de8b834a14cdedaf8c497e1bec4587575c91de7918eb8721c7e7c262b4656470580bab9cb2b53182c6e1d3c50c9b1e16db3e74f5cdde215ce1ddc861779bd618cd7657ffaeceae5c9a4ee06892d49d54a713a2b89db6116f3beabb1137ecbc9b5c044c3cd8485e21329ea88b6f315b92a896819a4a4fd0d4c5a86a0a71ed93260f168ec12e061a55b88b6c384f900a834b65d1bb0dd2600f3162e0fb4241303009c157a53a097fcc4ddb53409401413458d2fad39aca335c9e3b3e16812f638496db3ebb922e675fc8f4f2202229d8cc9b29730ffcf775c00d5329a274c2ea2990af8cd791c0c776a441e80606ebc1b62361ec9e87111521537cdb80c138669c4c38a2ca0ea9df6a7d96e768c59737690654daf055ccde393df23d9e291d6c555403465fb4923745a1f03aa202ccf2a2ca4addb555c31df3baeb3b30bfc7dd9dccf780ab99d2299845df24e3ee02bbd7123c4f49db71396cc6ddaa410f81868b0159a34ad2c3f79c2316bdf7349a716e3ff4f2824cc049507b36232fdb9977ba28abbe9bfe527ee563f79a12a14e8f8310f766437fb3d7d6a1dc2d967b05e8011b81b80f9e1acaf58850972943fefe9d2f0a92631b2c08082e9499503372677580e5669917be26b51517e3f1e20ba27fd1e9df37ebd38de8a72127c594a0b363b619ebad67b4a759f8295d90fef5e5253ca37f437f95e110a1d6429a84e9af704ab5830a13175dc1008a20dad0db4990229baa3cd98277a8b24d043ac056e7f6280229d2ebf26bf3a5bdf11863d480ff2bcfe6aaf5a7c84f483aaa05e18cb7a10ca92320aad90888c09ba92a67147b0961769ee45dce4a4b0b5bba6311b563c83d3c405aae5826c28b43a95924498749cde7590c44ce46d49ff28683e552f27b2aa29d4d97c8991abc7533af1f21bab144bea21c09fc961a8704b8ae6e316b89d24b706d5f8778af71647bacfefa2275038108ac8f219f2ccc294d7ad4fbbae14a10e0566d76bdff12c064c8c2a2f0a95fc8ca2016abe0189ac32092d5d42a9159dc43a30427c2fcccef6dca282af5c5f971868a2a41b734b9d9bc75e6ea2647916073d343cefaefebb6651ae8e9e0413848d05a47e1d1924bcf47602739b2c1d473a884b8545ffc77d767c01bee2bc2dfc9816ff4fe925b1b7621c325dbcb52911101233f136a6750b46831e709147a334be0ccaf84accfbbcab627fc0dd210766bc7090b13d69ba2c46472e3cabe9700cd5af9b2a90f97245e3e2f609d8f584df52a06e2c83a0bd84682806036d2b826b1507929b6b5909922fa4621f64cfe67708a0c0c44a8b773ec54259f760e1f374458cd7812a3c9d16b379ba99d93ed7851b8012305694f76d096934bfd1184a5847299f7aa928feb76ec22cd4a8a26521c7547a302b76f0a07a58a7d3cf7fbf0991ea3e57fcac6fdba95f6aaf5197f7ef9864a837e2544a500278b35c46e80d027d9690877154276a0baf4a977195edef8615dc6c6713db0276e07e72355ccccdc1f91280c3f577c24bd57dd7b0cb698c34f865f8dbddfbf25cf3c6283fed849aa67677bb8eebe3b75fca99ed09f454b13664e1b5c4268ceb64f16a689f50766994cf1eb823b336eb977541f207006abe0eb3d3d819c30752278d64a9f601639568b26d3c40ce619bd15bedcd65f968091d5b65d277ac1ebcb4984e2f194e03744334c4a1cc403144464febca83ab379550c40bb34b8844e867fdabda15cfeb6ea4a4968d3a76b4d707a7d7a662cda18daef8da0b34afc51a2f039bef30f2e568e3297aa1a97051adad7db659725b593716078b54297ab9762d3eb9b86a71f8eea6441b98b3c28c3a9cf597b0cd6ef315893bcd4b86b1facc77732298a9f2230e262eb179e30cdddb70393ef15f00e6ea2ee0d29f46bfb2f7b4bca868e1739d288773043afb19590c88258c761784f8aeaea34e725c8427af99cf27d142aed52afb8773424210aa6ec3fc42e031bd5f7c673ba704a465f38f49e498d1891b2589af910c96a02aeae43dfa7f4beaa17211e27f108308e68f0d71c2d00801e2026cc2e6ad48a8cbe0408f39c9356dc2f34250587bdfe457cc71ee9546a597e8d164efd2fa160c6e8444db921b66f317a034c6838bc48d11568d18285badd67c755bb00997b0f935dbae2aac49220306fcaa7872527aab2b416a1f5b9f6f3401963644371df83648aeb64a02a0e64732cb4a2a4cb0ac172278a6adc39a802745d0cd474b7d530a63ddf53d51cf9be20a599fa198d03b745f318356d0843d229859ccdee53b7ae39d6e18b5816f74e9b368a89d453d3189ea4abda911dca22731e6faccc194fbfba393d05e62798b0503d830c9dc4afdda237d15da873d97924ac5cdf23ab9d4ffb0d113ab39da78e95b51b78e77bcf15b1ccfbb60b50a8c71fa70d0de55faa433b3ea2f3b5386d08c1e4acd9f03b7b46a0d1997f065e2c8fddf835214a0cb11e24b4b89dc9715016d50d2deb32692a2d7dd899cded471ec1608dc2e506e92a416086e22955419fcb06bb46c92668a5d8764595ae01dd77908815ac383ead375a0b3e4a52e66f75efa2f4d6ac0396489ce5fb1205b1663bdfede4f6a7c8645f0c45a24ef62fdc6ca3acf38ba51417bb83f03a9656677d3fdb8a4b2d6a18e59187bbcda30330bae518826a5bb5994bc712d11dfabdebd4e75561ab79ef42d9a73cabf54f6e71b835d85fe3226ba9ebb2b1f7fded53395d5d56f4efcf8f8b16baf534e36bef31207d1e7745efec7395010b6ee8457c44586b7b33cf40c55e0de16a9886c809db9d781f0a550389d4b29af68f610f070906a9e8c0f6f2513da90cf63529ef5693f17fe475424e8ec2d059f7eae7e3bbffc8ce2ca091677865374f87826151c45b85f8be887b9d6f232d5ecb1b0893ce188f3a64ef0c433a305234104065a0fbdeda1649f9c66f986f3d84772a67e70d96320d156916aece99e9a68ee5fa1efdbc2ec1a71eea440131c04ac89458991a6c67b6c5df143364110a3fb8423b3ee487f11392719e0aa5f0a810309131e740c13deddf28b01ea386a984c41c288e0c5c85ddfb642bc40ed8bd2c73b83324e19abd418ebbdf19f79db9526661a1e12c349d94388be019ba1d78836664d7a0e7b22a2debc162f7030cdd9b68aec24e8aaab9cf1da123fd31a9c9acfac1b6d68ed36fce186a116d0138b6723f3888972ad011585210728bd5914e0b9dd612c061d7e7320721b3889f0f086bef65a457209e2ad032b99a380fa739877d25bfa1f4d3bd6f3c25fe2b258f0a2b20f6443c5c91c7a961cfb3912fa1cab8f97bfb5c381c08e94be5619a53685bb646c0c110bffa6bc371cc2026e5788892a266b11b61ebefc90cf11087d22b2597afc06f2c888fdc69c99192cfb92633e65149c3cc1fdfa790981cecf3dc63884b7ebe72bed5221450d5257d36f69f307ede255758797f71af288c13e8bcd4cb07824f3d08876fe22479968ded9c32a22cf784af8ffd0f31ebb7e5ca741b93b59ae133397e186e5ce9ba033a0dfd2dd7255b168078a2246e89352cd069ec862e30f0e99a65342dd3f1ec9ac938c02e985617bede2eeda596331d983b843f659bc3aa6d30088789194dc019de50012808c061cde84816ec1e5a73e9105b45d23526ce5f36e3d2d811caebdd23f63568be683830b85077dd12eb4f4379b538e65abfbf1c8076e2b67833c5ebd43ea82b5d108ccc73bfba202f999f194a81cd0559586d29aa0c922556e64e3bd5ab5d704c65a3edbbbd5a320f077fad6861caaa1c039c2cb8ab356e1aabbd3b738ec1ba3c7074f5ad1c5b8b0ae2bf5b59ca8a92f4102b9256059fce818a8f8af56cf4055c38596bcec619f36de0707bbe57b8ee1ee1a175c4b69b8803cb6bd9cbfc68088da205fc91138c4a24434dcccaee3921259e327f39fbcd0c670d4ffc411d6c1c96edfdd44bb931284b49157a131850b2976d84ccd28213754b69f18617b8223ec635b1e291d25f7279153d8758ebe3449051d5011cc428067234761e0d04461132e1f66e7646a063ae306e7101a2b644af02ada7d33aef61c013c6debb4aeb825fcad840b6e491b7e82fef094d843d3fa511da0d9f0140215331d3c1f4561787812e57721000cbc058fab9e2c06bf52089956bd0064276bf5afe6e5bd1a1dc985b3efe71b4b9d347145d88e97ae9832fe3d1609f95fd6918f47b090ce882f61c342d9fe4ce57a49c54ca39bc6a1638a56dfc1037a629682a761cac211db2e99abf44340663a63b57bd5616da1a9c5dd18fd05175f8bc695cabdadba3d5457df642f308fc55ca7f6c05b99aea89af675d713ca4ec2c62451c7af8ef216ad52a9ea48431ce16992047141f00977d89fd81aae5d504577a55cdee58388a1999d6776de889fe2a23491e352ff174609b9d2ee8b4358b3ba51a1aad10b5e312b942f733c9fcc361fb58be0d8e5f7f4784de3544dc8fc53efe23cf461058683817f987efecf11f8cfa1539180768f64e3a33b6faedab51ad476b3502290a2e322c5ae634adb8f469125d174e4eb94b0e9b3e020b359271c171fc049904fc918c9c271241d430a2cee00ba190409000ccc477535ec181f04936d2c75f564d50d96b6b45a378c0280685644c6687dcd52d00c3301b2de046f5daad44b194b65b2668c2cb0bf439b500e2c2f120e2a3629ea23c1d0ba6a1e6be377b80160ea3a2d0eeb5cc25c233243eccddfc3b12f590b58e60c2b671c79a37a83950ae7832bd7f9faf62ee5a7bcabe345ba6e0587d10501bdca1ec24c849d681b43a18305ae93970f0134a0199e25183002e1632bc63ced05c75f27f59ba5a00485fca9726bdfe58bec23422faa81ee96948e0ca858f4c1d7bb7c8d0a4cb57a57b85327c929f3ebd0e8c7f3ad431a0b534c510a6ba3a306d3c1134d2a1c08124906fc803ba9592c0c8774bedf6c8526030a1242180a4a3c679cc882648aeb4f8cc6d81e3b4839ceddec6baa57bee4f08154e1b29beadb12bc5adcb007a967243aa35ad30ce52e3f43954c9b7d2c377f6a82b9f08e51c1cc47568b074f8411f554333a3052e76be09615f4c593470c57401b0ed8adff54e1959cf4a5e504c645793ea03de08062bae4d6999b0491a693e5d89baa907445d2ec3a43b055dcbf274fbfa64244fdd9ca4eaa84cf8c8484146df6c43ad460f01c13f3f026ec21aa6a364e12854b8d9ca6915320454744d4de3b0def3f2d67adcc9fd887890feb32a4a7fdeabd3fbb1f12ba8358ab76c1c49185daed1aa64a89d60e4b0fcc1a62faee177f0e97ad7b6d167210a63c34d81ab4e08b000f900ff693da743ed2274f63b0a6725fb21c7b2d3fc845ea56b37d66f854c5d27f702b43bcfebbedc4ca96eb5365d3cb220fbf9182b2afd1faf14ab2dc49be3c0d4e3ad61d0b8195d3ac531ddf8bf274d11747d90f69427dd1267e8be0ec8398e64394ec62df9555f49a5121dabbcb2fa0ad23d603512cb0bcf95970f24d1a1addb6007e4ce55055419625b3bc0a1c72d980803910961fb9aabe9ee698e4a0bff1514a9b7d3d0f3fc4384199b69385b9fd779e0de05ae3059818da44a0c4b91cbe84350a29fd5e2d5a21349858cecf259830e1bf609346579000e050e39608af640c8bb8192ba1275a78ff4c5c83136f0b185407ba6516287ac4b165b193a009d9da14aabb09e881585c19bf8f13bd4cca9149be21344a7bddae7958f3d7ea68402651d95e244b8dff8f011e13b47f8520c3492dc0195ff16e87cfdd2df8155cf89ea4ed71a669c398033716697f9e6416154efb458b9bfc0cdbe8558049bd3fcc7ee0c2580494dc4acad36c1896e586611c0700da88e0452cc64855c7cd4b4d508f709672edd7fb8198c988a6b7d5c20c586f7548c03cd1b805f1242e2b95ff7e4b3b57159e2386bb08d15063c64e73ade3fa3122f68dfeb8ed1a94d938c9e2054355a7ed0388f2592e8d6e9315aad9e9fa87bd50567dd2032990d7a6012c7391d0ec6d86e30e8300b16a7d03b674a69af08690b704a662dee79a6971ee53eac620d51d6e42ffeaf8bacdea5b193771388e0a32147acfd877119eee8e907c7e4a8921906f1a58864802b768de23df563da7903650dcd72eaf7542a6c4c01e4ad44ae0809e9b98e954b550b708433dfd609361422187d420ab1840dd218f94437a504696275625d058cea49e3693ed2d10d290fa3042ed55084a89929242f2bcc06ad91ea22d569243ca19984d36d7f10a84dfb03064d9637771f100715c25fde42ae81ebd438c6f967e4fc8ce38c58991a6e5106ff350ebb9b04b286f496ee1a70b6cf3b5d8b2be1873b1db5fe033ada59e83fcac29ba6e15989bc051ce7646d3af20dab28619c45e1503337f7a14f30a5cc1e6f910942c55d400652d7c07e5345e6d01f1609fdb38c18bb8d53da31ecc1a32b03b28833302615a1a78f82f9413133fb6468415ca9840c091094c9ff6f3c4eb1c941e4d1786c5488c74a5b6568ecbb79c2ffe7bf19eeceab146bcdd548d45791d40ed1564fdfb47e2a678ee6a273e5961078fd67d4c446fc1fefbadf9c0743248631ad8bd88e959330f373f66a8084a3a250183f3660be8f44fd6dffcb324b3b4bf70cd2a4c2de530f88b9c90bf087f81d7a00b5a364b7f0ef277e6172e3959f0258d813dff37a90e98a57943ab56844d55dca88eb550aa185ef8848b4d005e95b74eed4a76cf96cc58f47c21d28ed152c33bd123e6df8a8cfa78b1d23055b137e4ffa720fefc21511e6104f3a536c53e91e6fad65ede1e78f413f844e2274cdde3e0292f3d983e20be77470ac2f819c3be9fad4aab732aee3bfb941cbaa90d1ac6fadb14ef84be19ea5836504acabcce95aa5031b8146edc5e4d86583a534aee971a3a12819f05cc886752401a834205188884c2efa32fa53f10b4f46326b56bd59438b77488188caf9dde3f6a4247723a7296b9a54e6e00cbdaca3af28ab05a1f375b08242da5395852416840daf73ebae0fc3d7f460d0f6b92690844aa75030984a47cb90b0402f5cc53a1c65c289cf54cb6a0c00c6094bb0be187bdac10815d26a6d140839572970c5af4b87df3ef7ffdac6eeaeab8fe1544e66c568738fd46a97f2dfe0ba54537569e9b2f4c2e710d0fdd355553268da0a3a60eb8fe4a9f6089e3bb99047e6f90b690ef02d769263c42da36f048ca13d63378283218c5186e0a6b698b49faf1b11d1a9bd0e1a7084ec60e26bf37637627604be9160d0bf805c51b8ac1203756c277c26f2b2c22675694a209976bfcac1bfe9631ca664146185859e82c3e0385ffab393de4c6af006b32ffe47526c566afbaaf933016df24d91e08df2165852791258be568ec4e551c6e7ce246258b098ab549ef3644c8cd07ceb246209a385621b65f9a27b7b90ab96b08543ba8ecf331c072e7868cf227b45ef4e95ef02e221c7cfa93eb78e65bc0905de1a84058854160d4c9a90bc2a6c238140cc15333eb66254d2af93bdc9c368282d8dd4bb04c8f40f506999dbbefb538c51af7b766e6c00c0d59d4dea589d076e507be43ebaaeb591da2d75ca30b070c8c2cdd32b74ce522404182d727efb516455b357a39ac9ad0f30efe2f3f7e3c5494e375c7dccf87d97d695b4f3a2f2991f8c14379465bd6f67f398e102bce08a5a47b85146f769dac93f3d079172edf5ddc3dd3d6474773e0b8c114183f6f204514727ea76b3df393c37cc2a87c89be7445469b7dabb7f61c9c5661c7bb0862e84c2949050cea711c59b279bdf6dce805609302666e8c22e222515350d80d20879a3ecb04b6e9a403ea9ff2ea2ea2324ca5bf9ac99491fc0412dd05040aad2a3ee28f9248aafbd66d6e24a65b91876dbced91119a672f1cb6cf91d83f7b5d5b5f682218bf78b838264293bba13bdc55d3e43e889d59bd8f4b9fd89a39af1bc7cdc4aeba47683a79055bee6e671fa13838c99f3aaf1924dd32bf16103178acee829917cd536ddaf8ca53787e1f2d903c22b89aab52f646fd0080c4bfb01e1531e5b41703ada7a9ec4f74abc803bf568394ff39d729b3d440bd3887e4a36a4b1ac877c3ea28251b460b6f3c3a79203d976bf9dcec91eb5dcb38492087190e800715eea77daabf8c1fa1881bb5176c9f199e9cf7e9bb589eb58f2fa28ed7e9821b313c84bba7e5da8f1cbe1f778c4ae162ba80123a322668455bc52056e016b9156de041ec4ecce18ba6783ac71ba1ac6f320ffdc08aa1bce9b571e6f022d06bfa3c4db845829d516f88e5afde24e90d2674b0bb2f7e28cb532bbe19e63ebec54c0d1e3beee0edd83435fac3335088a55d8ce2d872efe99939b053b36b960c63625bca909678661f414cbdd6857cf72a73b09612c417a4b00382ca43877daf4d10af92c640f09a29e9614ad3c18848526841d2b45a6b4dfc6d29cbfd8a3268eed9dca44d5ae26d913673d8ae263003fc3b0b90f9ecdb880df5861c2bf21bd356498c22a16b469115452290f3a800b5a39a8166e8c24d46467d72579173352d3b041af503cc0d5f19e22d158c23e165180b2a3e93a437be1c7526a3260788503420647d77345fbb1dc7b858aeb0b6dbdbcd89885978cee478951f8edb2d81db04e51ffdb1c55e62b74780bb3cedfc804c7b5d8c50097d6b317eea72bb411aeab34b255b5ba43ba91561d24ff6cafa5fd7269afa9b16716f39626aedf14ca905eb637abd015885f5187de108fffc1838fa5ba16556223cd528c93473243920f4abd543a588a4c8efd849b19f382998806882f875c87d3347e358e8053d8da4f70c18e72556f839f76704d6592b3013d473baf6a03e1cfdee76e4593ac4f0040859b4dd04b9ca66cde942efc86918bff37cc528bf0185a5d329050da654dcc5fc44a526dcc60fb795b615426468b76f4db7a63c02b75ea5a77bf19d139f49216b02b9c58c4ee7a41673417e05f091e38ef16d2cabc48d885e32bc9dcbf87dd81de3492d7d03340107decd272197ccc65e3307a8c229173d2aeba57eb56f3cbdff5e31d2e820e835e7e2ff774dd87ef14fc00b999ffe8fc8b6da8bdea2ac9e404befebf2507b346843c91556be450a607413995369c9d70d0f0974bb569fc8bde718e5525fe9883e2d5b111b8e69ba65244daf509713f6294770382045f478a04ad32a533f43a350bc126562fbc536bd6aa2018efec974b6ac24c8f4151efae80f9e4e45b28d73b25afd8c63df0717ce51735484a8e02aa5566b701e0a2e84af671675ba95efa5fcd5825bec8b7963d93494966956918072884236ad4de559aa3405ab05a00c0aea1ea476d854e86e43115459fe4771e83a1500c0cc8071112dcb3b37a5a520896ededb1d8e410517d0c6508e1d1dbda6733bbda0ac973a5c312ee157bd7a89f75d3cf52caa5794067ec7f4a271be9d1747ba73c11fafc9828bbe7471f179e4c2e9ffd93db6d8443dd1783b6abf5d47590cef60f811873acf41305cbc321ada5dcb90adae19b6e535397fa1c4e68d71cfdc3078156d8677058d1d5ca08743e31dec51976defee15247c9a9bbde405c2d776f6644dd918a29b7848bc52c32c71c174a375cac84fa8dabb3aedd286830dee565b5b080558b79923fab30ceccd9769718346aab08604bd815cf2b20c42853e52881075f09c5f4a3e2e2a300e6f24ae42d286a60be58b5f8c607e1efc2c7ed1e986f373db125e6a95310c562b5855fc9c45f7eda821b0296baa4a2c43d6a5492f9ca546ba06679f0e5952e85953a05162761c6b91df93df614052402e2162457c31e62bb7a89ea19a34bfd07fc33f07c4c0fbf8ab01b7a6ce0cd1fc9a5c22dfb074f7d69e15044ce852b6002a261f8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要填入密码才可访问阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Asyncflow</category>
      </categories>
  </entry>
  <entry>
    <title>Asyncflow项目2：整体设计思路</title>
    <url>/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="一整体框架异步任务框架">一、整体框架（异步任务框架）</h1>
<h2 id="整体框架">1. 整体框架</h2>
<p>在Asyncflow项目中，主要包括以下部分的设计：</p>
<ul>
<li>任务调度器Worker
<ul>
<li>异步执行实际的任务</li>
<li>执行完毕后将<strong>任务status、stage</strong>更新提交到flowSvr</li>
</ul></li>
<li>代理FlowSvr
<ul>
<li>接收任务请求</li>
<li>将任务请求转发给Worker</li>
<li>获取数据库中的任务</li>
<li>任务治理（定时执行<strong>任务位置表更新</strong>、定时轮询<strong>是否达到分表阈值500w（更新任务位置表）</strong>、间隔查看和处理<strong>卡死任务</strong>等）</li>
</ul></li>
<li>DB数据库设计
<ul>
<li>数据库表、字段、索引、优先级设计
<ul>
<li>上下文设计：<strong>content</strong>字段，框架worker和flower<strong>不需要理解上下文</strong>，<strong>只需要存储和传递</strong>，所以可以实现对各种类型任务的快速注册（新增任务类型typeX）</li>
</ul></li>
<li>分表设计</li>
</ul></li>
<li>Cache缓存设计
<ul>
<li>分布式锁设计</li>
</ul></li>
</ul>
<p>在主要实现流程中，代理做为worker、用户、数据库之间的桥梁，负责接收、分发任务以及管理任务状态转移。</p>
<p>由于worker是异步执行的，因此对于多个woker获取同一类型任务时，需要在worker与flowSvr之间加一层分布式锁，只有获得锁的worker才能向flowSvr请求任务。</p>
<p>具体流程如下：</p>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/Asyncflow_structure.png"></p>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/work_structure.png"></p>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/flow_structure.png" width="50%"></p>
<h2 id="中间件">2. 中间件</h2>
<p>在整体框架中，主要用到的中间件为<strong>MySQL</strong>和<strong>Redis</strong>，根据需求可以引入<strong>消息队列</strong></p>
<ul>
<li><strong>MySQL</strong>作为<strong>持久化存储</strong>，用于存储任务的<strong>状态</strong>、<strong>优先级</strong>、<strong>任务类型</strong>等信息</li>
<li><strong>Redis</strong>作为<strong>信息缓存</strong>加速查询，以及实现<strong>分布式锁</strong>解决冲突问题
<ul>
<li>一类任务的多个worker需要一把分布式锁</li>
<li>而不同任务之间会打到不同flowsvr上，操作不同的表格，所以不同任务之间不需要加锁</li>
</ul></li>
</ul>
<h2 id="框架部署方式">3. 框架部署方式</h2>
<p>当前部署方式为：</p>
<ul>
<li><strong>多flowSvr单MySQL单Redis</strong>：
<ul>
<li>多个flowSvr部署在单机上，共用一个MySQL数据库，通过<strong>分布式锁</strong>解决并发问题</li>
<li>路由通过<strong>Nginx</strong>实现<strong>负载均衡</strong></li>
<li>部署在阿里云服务器上</li>
</ul></li>
<li><strong>多Worker</strong>
<ul>
<li>worker处理任务的接口逻辑需要用户自己实现</li>
<li>worker用于占据并执行任务、更新任务状态（任务提交）</li>
</ul></li>
</ul>
<p>当前阶段单机（1个server）中部署了<strong>3个flowSvr
pod</strong>和<strong>3个worker</strong>，通过<strong>Nginx</strong>实现<strong>负载均衡</strong>，<strong>MySQL</strong>和<strong>Redis</strong>也是单机部署</p>
<h2 id="表结构设计">4. 表结构设计</h2>
<p><strong>1）任务信息表t_video_task_1</strong></p>
<p>以其中一种任务类型<code>video</code>为例，其表名为<code>t_video_task_1</code>，表结构如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>bigint</td>
<td>自增ID，主键</td>
</tr>
<tr>
<td>user_id</td>
<td>varchar</td>
<td>用户ID</td>
</tr>
<tr>
<td>task_id</td>
<td>varchar</td>
<td>任务ID，唯一约束</td>
</tr>
<tr>
<td>task_type</td>
<td>varchar</td>
<td>任务类型</td>
</tr>
<tr>
<td>task_stage</td>
<td>varchar</td>
<td>任务阶段</td>
</tr>
<tr>
<td>task_status</td>
<td>varchar</td>
<td>任务状态：待执行1、执行中2、成功3、失败4</td>
</tr>
<tr>
<td>crt_retry_num</td>
<td>int</td>
<td>当前已经重试次数</td>
</tr>
<tr>
<td>max_retry_num</td>
<td>int</td>
<td>最大重试次数</td>
</tr>
<tr>
<td>max_retry_interval</td>
<td>int</td>
<td>最大重试时间间隔：渐进式重试</td>
</tr>
<tr>
<td>schedule_log</td>
<td>varchar(4096)</td>
<td>任务调度日志：json格式</td>
</tr>
<tr>
<td>priority</td>
<td>int</td>
<td>任务优先级：默认为0</td>
</tr>
<tr>
<td>task_content</td>
<td>varchar(4096)</td>
<td>任务内容：json格式</td>
</tr>
<tr>
<td>order_time</td>
<td>int</td>
<td>任务调度时间：与优先级、当前失败后重试间隔有关</td>
</tr>
<tr>
<td>create_time</td>
<td>datetime</td>
<td>创建时间</td>
</tr>
<tr>
<td>modify_time</td>
<td>datetime</td>
<td>修改时间</td>
</tr>
</tbody>
</table>
<ul>
<li><code>id</code>和<code>task_id</code>的区别
<ul>
<li><code>id</code>是表内自增不对外暴露的</li>
<li><code>task_id</code>可以是uuid，<strong>提供用户进行轮询查询任务状态</strong>以及做为唯一标识<strong>保证接口幂等</strong>的</li>
</ul></li>
<li><code>task_type</code>
<ul>
<li>这里是用于识别<strong>不同类任</strong>务的，比如音视频和北斗解算就是不同类型任务有不同type</li>
<li>而对于<strong>同一个任务</strong>的<strong>多阶段</strong>是用<code>task_stage</code>去区分的，<strong>不同类型任务不会出现在一张表格中的</strong></li>
</ul></li>
<li><code>task_stage</code>：如一个任务有三个阶段，则有task_1、task_2、task_3
<ul>
<li>举例：北斗解算可以划分为<strong>采集数据过滤预处理</strong>、<strong>数据解算</strong>两个阶段</li>
</ul></li>
<li><code>status</code>
<ul>
<li>指的是worker对当前任务的执行状态，有<strong>4种</strong>
<ul>
<li><strong>过程态会在不同任务阶段动态变化</strong>：1（等待worker调度）、2（正在被worker调度）</li>
<li><strong>任务终态不会变化</strong>：3（任务失败）、4（任务成功）</li>
</ul></li>
</ul></li>
<li><code>max_retry_interval</code>：比如设置为10，重试时会从1开始，翻倍递增，直到10后一直不变，直到达到最大重试次数
<ul>
<li>公式：<code>max_retry_interval = min(1&lt;&lt;crt_retry_num, max_retry_interval)</code></li>
<li>举例：[1, 2, 4, 8, 10, 10, 10, 10, 10, 10]</li>
</ul></li>
<li><code>schedule_log</code>：json格式，包含本次<strong>任务追踪id、耗时、失败原因</strong>等信息</li>
<li><code>task_content</code>
<ul>
<li>一般是存json，所以flowsvr对语义是无感知的，worker方与用户需要统一里面的语义进行业务操作</li>
<li>只能存储4096字节，如果业务复杂的话应该<strong>开辟单独的表专门存储上下文，然后在task_content中值存一个类似content_id的标识用于查询对应的结果</strong></li>
</ul></li>
<li><code>order_time</code>：用于排序设置优先级的，与优先级、当前失败后重试间隔有关（实现重试的关键）</li>
</ul>
<p><strong>2）任务配置表t_schedule_cfg</strong></p>
<p>属于配置表，用于存储各类任务的<strong>系统配置信息</strong>，包括<strong>单次拉取数</strong>、<strong>重试配置</strong>，表结构如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>task_type</td>
<td>varchar</td>
<td>任务类型</td>
</tr>
<tr>
<td>schedule_limit</td>
<td>int</td>
<td>单次拉取任务数</td>
</tr>
<tr>
<td>schedule_interval</td>
<td>int</td>
<td>每次拉取任务间隔</td>
</tr>
<tr>
<td>max_retry_num</td>
<td>int</td>
<td>最大重试次数</td>
</tr>
<tr>
<td>max_retry_interval</td>
<td>int</td>
<td>最大重试时间间隔</td>
</tr>
<tr>
<td>create_time</td>
<td>datetime</td>
<td>创建时间</td>
</tr>
<tr>
<td>modify_time</td>
<td>datetime</td>
<td>修改时间</td>
</tr>
</tbody>
</table>
<p><strong>3）任务位置表t_schedule_pos</strong></p>
<p>也属于一种配置信息，属于动态变化的配置，用于实现<strong>分表</strong>，分表有助于实现<strong>负载均衡</strong></p>
<p>最主要的字段是<strong>schedule_begin_pos</strong>和<strong>schedule_end_pos</strong>，分别用于标记<strong>worker下次调度在哪个表拉取任务</strong>和<strong>user下次在哪个表插入任务</strong>，两个值一般跨度最大只有两个表，表结构如下：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>task_type</td>
<td>varchar</td>
<td>任务类型</td>
</tr>
<tr>
<td>schedule_begin_pos</td>
<td>int</td>
<td>下次调度在哪个表拉取任务</td>
</tr>
<tr>
<td>schedule_end_pos</td>
<td>int</td>
<td>下次调度在哪个表插入任务</td>
</tr>
<tr>
<td>create_time</td>
<td>datetime</td>
<td>创建时间</td>
</tr>
<tr>
<td>modify_time</td>
<td>datetime</td>
<td>修改时间</td>
</tr>
</tbody>
</table>
<ul>
<li><code>schedule_begin_pos</code>和<code>schedule_end_pos</code>的更新
<ul>
<li>在flowSvr的<strong>任务治理模块</strong>中，会定时更新这两个信息</li>
<li><code>schedule_begin_pos</code>更新：定时<strong>全表扫描</strong>，当前表<code>status</code>都为终态<code>3执行成功</code>或<code>4执行失败</code>时，更新pos++</li>
<li><code>schedule_end_pos</code>更新：当前表count&gt;500w时，更新pos++</li>
</ul></li>
<li><code>schedule_begin_pos</code>和<code>schedule_end_pos</code>的作用
<ul>
<li><code>schedule_begin_pos</code>：
<ul>
<li>拉取任务会根据<code>begin_pos</code>找到那张表</li>
<li>然后用sql语句按顺序过滤筛选一批未执行完所有阶段且处于待执行的任务</li>
<li>根据<code>order_time</code>选出top limit条任务</li>
<li>更新或查询任务时不需要获取任务位置表，因为<strong>task_id会自带这个任务的位置信息</strong></li>
</ul></li>
<li><code>schedule_end_pos</code>：user下次在哪个表插入任务</li>
</ul></li>
</ul>
<h2 id="状态流转">5. 状态流转</h2>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE2%EF%BC%9A%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/status_flow.png"></p>
<h2 id="选用的网络通信协议">6. 选用的网络通信协议</h2>
<p>走<strong>HTTP</strong>实现通信</p>
<h2 id="webserver依赖框架">7. webserver依赖框架</h2>
<ol type="1">
<li>tinyWebServer</li>
<li><a href="https://github.com/drogonframework/drogon/wiki/Home.zh-CN">Drogon框架</a>（有完整的路由配置）</li>
</ol>
<h1 id="二使用场景">二、使用场景</h1>
<p>Asyncflow项目主要用于解决异步任务调度问题，因此适用于需要<strong>多阶段任务</strong>、<strong>阶段间相互依赖</strong>且<strong>耗时</strong>的异步执行的场景，例如：</p>
<ul>
<li>音视频</li>
<li>图片处理</li>
<li>数据处理...</li>
</ul>
<h1 id="三同步和异步的区别">三、同步和异步的区别</h1>
<p><strong>1）同步与异步的区别</strong></p>
<p>同步任务是指任务执行完毕后，才会继续执行下一个任务。而异步任务是指任务执行过程中，可以继续执行下一个任务，只需要<strong>轮询处理结果</strong>即可，因此异步很适合在<strong>耗时的操作</strong>中使用。</p>
<p>相当于在同步任务中，user发起任务请求后会阻塞干等；而在异步任务中，user发起任务请求后会收到一个<strong>任务ID</strong>，然后可以继续做其他事情，等到任务执行完毕后再获取结果（通常是通过<strong>回调函数or轮询结果</strong>）。</p>
<p>本项目中同一个任务的多个阶段是同步执行的，需要按顺序，而不同任务之间是异步执行的，可以并行执行。</p>
<p><strong>2）异步时对外提供的接口</strong></p>
<p>异步需要暴露给生产者（用户）的接口通常有两个：</p>
<ul>
<li><strong>发起任务</strong>接口：用于生产者提交发起任务，返回任务ID</li>
<li><strong>查询任务</strong>接口：用于查询任务状态，返回任务结果</li>
</ul>
<p><strong>3）为什么异步结果查询普遍用的是轮询而不是服务器主动通知？</strong></p>
<p>因为轮询对于客户端来说更加灵活，可以根据自己的需求来决定轮询的频率，而服务器主动通知则<strong>需要客户端保持长连接</strong>（得使用WebSocket、HTTP2等支持主动push的协议，而轮询的话大多数协议都支持），增加了服务器的压力。</p>
<p><strong>4）框架中体现异步的两个主要的点</strong></p>
<ul>
<li>对于<strong>用户</strong>而言的异步
<ul>
<li>提交任务后，直接交给Async执行，用户不需要等待任务执行完毕，轮询即可</li>
</ul></li>
<li>对于<strong>Async框架</strong>而言的异步
<ul>
<li>对于Async框架来说，将任务分解后，worker拉取某个阶段的<strong>任务交由下游接口执行</strong>，此时的<strong>worker</strong>相对于下游接口也是用户，<strong>只需要异步等待下游接口返回结果就行</strong>（多阶段异步），此时框架就可以去做别的任务调度了</li>
<li>举例：比如下游业务是向腾讯云发出任务请求，那么其实worker主要要完成的就是向腾讯云调接口而不是Asyncflow实际执行业务逻辑，消费者worker的工作是实现调度，去查结果</li>
</ul></li>
</ul>
<h1 id="四asycnflow与消息队列的区别">四、Asycnflow与消息队列的区别</h1>
<h2 id="asycnflow的特点">1. Asycnflow的特点</h2>
<p>Asycnflow最主要的亮点是：<strong>异步</strong>、<strong>多阶段任务</strong>、<strong>任务调度框架化</strong>、<strong>轻量级</strong></p>
<ul>
<li>天生为<strong>异步</strong>任务设计（适合多阶段、耗时任务）</li>
<li>任务<strong>状态转移</strong>明确（任务状态：未开始、进行中、已完成）</li>
<li>任务<strong>优先级</strong>明确（任务优先级：高、中、低）</li>
<li>提供通用框架，<strong>注册</strong>各种任务类型，实现任务逻辑即可
<ul>
<li>非框架下，总是做重复代码，于是先做调研做一个框架节省代码开发时间，只需要做业务逻辑就行</li>
</ul></li>
<li>核心是<strong>任务调度器</strong>，负责任务的调度和执行，因此相比消息队列（只是消息传递的组件），Asyncflow具备<strong>简化任务管理-调度</strong>的优势</li>
</ul>
<p>功能设计上有以下特点：</p>
<ul>
<li>两种重试机制：<strong>均匀重试</strong>和<strong>渐进式重试</strong></li>
<li>滚表的分表方式</li>
<li>解耦多个排序因素：抽象<code>order_time</code>字段作为排序依据</li>
<li>接入GORM接入GORM库简化数据库操作，实现数据库连接池优化性能</li>
</ul>
<h2 id="为什么用asyncflow而不用消息队列呢">2.
为什么用Asyncflow而不用消息队列呢？</h2>
<p><strong>1）消息队列和Asyncflow的区别与联系</strong></p>
<p>消息队列与Asyncflow之间是纯队列和调度框架的区别，实际上Asyncflow也可以引入消息队列作为中间件提高性能：</p>
<ul>
<li>在flowSvr中，由于拉取跟执行任务是耦合的，所以导致多个worker拉取任务时需要排队</li>
<li>如果引入消息队列，可以提前拉取多批任务放入消息队列中，worker从消息队列中拉取任务，这样可以<strong>提高并发度</strong>，<strong>减少worker之间的竞争</strong>、<strong>加快分布式锁的释放</strong></li>
<li>缺点：引入中间件会加入<strong>维护成本</strong>和额外组件的<strong>开发学习成本</strong>，同时增加框架的复杂性，可能有<strong>过度设计</strong>的问题，所以要根据实际情况决定是否引入</li>
</ul>
<p><strong>2）消息队列和Asyncflow的区别</strong></p>
<ul>
<li><strong>消息队列</strong>只是一个组件，需要<strong>单独维护和设计调度</strong>，且不是天生具备<strong>任务管理-任务状态查询</strong>的，需要单独开发和维护，其本质是进行<strong>消息传</strong>递，主要用于<strong>解耦（任务本身不依赖）</strong>，<strong>异步（处理耗时任务）</strong>处理，<strong>削峰（抗住瞬间流量）</strong>填谷等场景；而<strong>Async</strong>的框架就是开发了<strong>完整的调度和任务状态更新管理功能</strong>，用户只需要<strong>注册任务、将任务传入</strong>即可，更倾向是一个<strong>任务调度器</strong>且强调多阶段的依赖性，主要用于任务的调度和执行</li>
<li>使用<strong>消息队列</strong>需要对各个事件驱动的任务阶段加入消息队列，不便于顺序执行流程，且中间<strong>服务挂了会导致丢失</strong>；而<strong>Async</strong>通过<strong>MySQL持久化存储</strong>，稳定性更好</li>
</ul>
<p>因此，使用Async异步框架可以<strong>简化开发流程和维护成本</strong>，天生提供<strong>任务管理调度能力</strong>，且同样具备水平扩展的能力</p>
<p><strong>3）为什么用消息队列而不用Asyncflow呢？</strong></p>
<p>因为消息队列只是消息传递的组件，而Asyncflow是一个任务调度框架，提供了任务的<strong>管理、调度、状态更新</strong>等功能，更适合于任务的调度和执行。</p>
<p>虽然用Kafka也可以实现，但是也是要重新实现<strong>MySQL的接入和一些worker调度逻辑</strong>的实现</p>
<p>调研了一下，C++实现这种框架的其实是很少的，Go中有一个<strong>Machine</strong>框架，但是该框架的功能过与齐全，对于本项目来说属于过度设计，所以觉得仿照其他语言的框架实现一个<strong>轻量级Asyncflow</strong>，实现单任务多阶段串联</p>
<h1 id="五c语言异步框架比较">五、C++语言异步框架比较</h1>
<p>C++语言的异步框架有很多，比如<strong>libuv</strong>、<strong>boost.asio</strong>等，这些框架都是<strong>事件驱动</strong>的，可以实现<strong>异步IO</strong>，<strong>多线程</strong>等功能。</p>
<p><strong>1）libuv</strong></p>
<p>libuv是一个<strong>跨平台</strong>的异步IO库，主要用于<strong>事件驱动</strong>的编程，它提供了<strong>事件循环</strong>、<strong>异步IO</strong>、<strong>定时器</strong>、<strong>线程池</strong>等功能，可以用于开发高性能的网络应用</p>
<p>它更适合于<strong>网络编程</strong>，<strong>异步IO</strong>等场景，适用于编写高性能的网络服务器和客户端，如WebSocket服务器、HTTP服务器等</p>
<p><strong>2）boost.asio</strong></p>
<p>boost.asio是一个<strong>C++标准库</strong>，提供了<strong>异步IO</strong>、<strong>网络编程</strong>、<strong>多线程</strong>等功能，可以用于开发高性能的网络应用，其适用性类似于libuv，但是更加<strong>底层</strong>，需要自己实现更多的功能</p>
<p><strong>3）Asyncflow</strong></p>
<p>本项目相较于libuv和boost.asio，提高<strong>更高级别的抽象层</strong>，是用户友好型，提供了<strong>任务调度</strong>、<strong>任务状态管理</strong>等功能，适用于<strong>多阶段任务</strong>、<strong>任务依赖</strong>等场景，更加适合于<strong>任务调度</strong>和<strong>执行</strong>，而不是仅仅网络编程</p>
<p>同时框架具有<strong>轻量级</strong>、<strong>依赖少易维护</strong>等优点</p>
]]></content>
      <categories>
        <category>Asyncflow</category>
      </categories>
  </entry>
  <entry>
    <title>Asyncflow项目4：Worker的设计</title>
    <url>/2024/08/18/Asyncflow%E9%A1%B9%E7%9B%AE4%EF%BC%9AWorker%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一worker调度任务设计">一、Worker调度任务设计</h1>
<p>worker最主要的任务就是进行任务的调度，获取到任务后，通过<code>stage</code>字段来判断任务的执行阶段，并通过<code>task_content</code>字段来获取上下文信息并执行任务。</p>
<p>worker其实只有三个主要任务：</p>
<ol type="1">
<li><p><strong>任务治理</strong>定时去拉取任务（拉取任务时多个worker需要抢锁）</p>
<p>worker开启一个单独线程，timer定时去拉取任务</p></li>
<li><p>webserver服务实现并发处理任务</p>
<p>worker任务由线程池处理，线程池容量为2000（根据任务最大堆积量1000来设置的）</p></li>
<li><p><strong>框架使用者需要自定义编写worker的业务处理逻辑部分的代码</strong></p></li>
</ol>
<ul>
<li>根据<code>schedule_interval</code>字段，定时拉取任务
<ul>
<li>当worker中任务队列积压到一定阈值定时到了也不拉取任务</li>
</ul></li>
<li>调用post的<code>/hold_task</code>接口，请求占据拉取一批任务</li>
<li>执行任务
<ul>
<li>根据<code>stage</code>字段，判断任务的执行阶段
<ul>
<li>worker每次只执行一个阶段后就扔回给flowSvr</li>
<li>原因：是为了保证<strong>不被一个任务占据太久时间</strong>，实现异步调度</li>
</ul></li>
<li>载入<code>task_content</code>字段，获取上下文信息</li>
<li>线程池并发执行任务</li>
<li>更新任务执行信息</li>
<li>调用post的<code>/set_task</code>接口提交任务执行状态</li>
</ul></li>
</ul>
<p>这是对于单worker的情况，抽离出了worker的调度流程，实际上部署的时候是多worker的，会存在竞争问题</p>
<p>所以在发送请求后，在flowSvr端需要加锁解决竞争问题</p>
<h1 id="二分布式下的worker流程">二、分布式下的worker流程</h1>
<ul>
<li>根据<code>schedule_interval</code>字段，定时拉取任务
<ul>
<li>当worker中任务队列积压到一定阈值定时到了也不拉取任务</li>
</ul></li>
<li>调用post的<code>/hold_task</code>接口，请求占据拉取一批任务</li>
<li>获取分布式锁</li>
<li><strong>占据任务</strong>
<ul>
<li><strong>flowSvr更新一批任务状态</strong></li>
<li><strong>flowSvr返回一批任务列表</strong></li>
</ul></li>
<li><strong>释放锁</strong></li>
<li>执行任务
<ul>
<li>根据<code>stage</code>字段，判断任务的执行阶段
<ul>
<li>worker每次只执行一个阶段后就扔回给flowSvr</li>
<li>原因：是为了保证<strong>不被一个任务占据太久时间</strong>，实现异步调度</li>
</ul></li>
<li>载入<code>task_content</code>字段，获取上下文信息</li>
<li>线程池并发执行任务</li>
<li>更新任务执行信息</li>
<li>调用post的<code>/set_task</code>接口提交任务执行状态</li>
</ul></li>
</ul>
<p><img src="/2024/08/18/Asyncflow%E9%A1%B9%E7%9B%AE4%EF%BC%9AWorker%E7%9A%84%E8%AE%BE%E8%AE%A1/worker_flow.png" width="50%"></p>
<h1 id="三具体设计细节">三、具体设计细节</h1>
<h2 id="多worker的竞争问题">1. 多worker的竞争问题</h2>
<p><img src="/2024/08/18/Asyncflow%E9%A1%B9%E7%9B%AE4%EF%BC%9AWorker%E7%9A%84%E8%AE%BE%E8%AE%A1/worker_competition.png" width="50%"></p>
<h3 id="解决竞争的方案类型">1.1 解决竞争的方案类型</h3>
<p>解决竞争的方法主要有三种：</p>
<h4 id="mysql悲观锁">1.1.1 MySQL悲观锁</h4>
<p>通过<code>select ... for update</code>语句，产生<strong>间隙锁</strong></p>
<ul>
<li>优点：<strong>简单</strong>，<strong>易于理解</strong></li>
<li>缺点：<strong>性能差</strong>，当并发量大时，容易造成<strong>死锁</strong></li>
</ul>
<p>悲观锁阻塞说明：</p>
<p><img src="/2024/08/18/Asyncflow%E9%A1%B9%E7%9B%AE4%EF%BC%9AWorker%E7%9A%84%E8%AE%BE%E8%AE%A1/for_update_lock.png" width="50%"></p>
<ul>
<li>当第一个sql执行时，会对<code>status=1</code>的所有记录加锁（status是索引）</li>
<li>当第二个sql执行时，属于任务更新，会将该条<code>status=2</code>记录的索引先删掉，在新增<code>status=1</code>的记录
<ul>
<li>索引的B+树叶子节点是有序的</li>
<li>但是由于第一个sql的锁还没有释放，所以第二个sql在新增<code>status=1</code>的记录时，会插入sql1的间隙中，所以会阻塞等待sql1的锁释放再执行</li>
</ul></li>
</ul>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;mid=2247524580&amp;idx=1&amp;sn=8032d1de9a45304f91dbb2e6f5a12e0e&amp;chksm=f98d244ecefaad58a21f730cd9f0646b41e20cd16d20e76c97b6de3b081d3554637366746fd3&amp;token=1905900309&amp;lang=zh_CN#rd">我打赌！这个
SQL 题，大部分人答不出来</a></p>
</blockquote>
<h4 id="mysql乐观锁">1.1.2 MySQL乐观锁</h4>
<p>通过<code>owner</code>字段，实现<strong>CAS</strong>操作，即<strong>比较并交换</strong></p>
<ul>
<li>缺点：增加多余的sql操作数、worker多的话冲突更多（CPU负担）</li>
</ul>
<p>乐观锁拉取任务举例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_video_task_1 <span class="keyword">where</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> order_time limit <span class="number">10</span>;</span><br><span class="line">update t_video_task_1 <span class="keyword">set</span> owner<span class="operator">=</span>a <span class="keyword">and</span> status<span class="operator">=</span><span class="number">2</span> <span class="keyword">where</span> task_id <span class="keyword">in</span> (第一条<span class="keyword">sql</span>的task_id);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_video_task_1 <span class="keyword">where</span> owner<span class="operator">=</span>a;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/08/18/Asyncflow%E9%A1%B9%E7%9B%AE4%EF%BC%9AWorker%E7%9A%84%E8%AE%BE%E8%AE%A1/optimistic_lock.png" width="50%"></p>
<h4 id="redis分布式锁">1.1.3 Redis分布式锁</h4>
<p>分布式锁设计：</p>
<ul>
<li>用redis去实现分布式锁（redis的setnx）</li>
<li>只有worker拿到锁后才能去调用MySQL</li>
<li>worker挂了：如果竞争到锁的worker挂了会<strong>有过期时间自动释放锁</strong>的</li>
<li>worker没挂-任务没执行完但锁到期：用<strong>看门狗自动续期</strong></li>
</ul>
<p>存在问题：锁释放不及时，其他worker就闲置了</p>
<p>原因：拉取同步数据任务时需要排队等待拉取完一批任务（<strong>拉取和执行耦合了</strong>）</p>
<p>解决方案：<strong>队列化</strong>，加入消息队列Kafka中间件，将拉取和执行解耦，缩短锁的时间</p>
<ul>
<li>提前同步一批任务放在消息队列中，worker拉取的时候就可以直接拿到一批数据，不需要再等待同步操作的执行，缩短了释放锁的时间</li>
<li>缺点：增加了维护成本</li>
</ul>
<p><strong>最终选型：redis分布式锁（非队列化）。</strong>因为虽然拉取任务需要排队，但是项目中最耗时的在拉到任务后执行任务，所以拉取任务时短时间的排队是允许的，因此不考虑过度设计加入Kafka增加维护成本</p>
<p>前瞻设计-无任务时减少flowSvr空转查询数据库：</p>
<ul>
<li>way1：<strong>redis setnx</strong>
<ul>
<li>当没任务的时候setnx，有worker进来时，都通过setnx失败来拒绝worker进入</li>
<li>有任务的时候再把键删除掉，以此来允许用户进去flowSvr拉取任务</li>
</ul></li>
<li>way2：加入一个<strong>消息订阅发布</strong>机制，有/无消息时通知worker</li>
</ul>
<h4 id="分情况选择加锁方案">1.2 分情况选择加锁方案</h4>
<p><strong>1）单flowSvr多worker的情况</strong></p>
<p>用flowSvr内部<strong>本地锁</strong>控制一段时间只有一个线程操作MySQL</p>
<p><strong>2）多flowSvr多worker的情况</strong></p>
<p>多机下共享MySQL，所以肯定要加<strong>redis分布式锁</strong></p>
<h2 id="任务推拉模式选择">2. 任务推拉模式选择</h2>
<ul>
<li><strong>推模式</strong>：worker主动拉取任务
<ul>
<li>缺点：会造成竞争</li>
</ul></li>
<li><strong>拉模式</strong>：flowSvr推送任务，无竞争
<ul>
<li>缺点：推的方式缺乏个性化，对所有节点都要发送相同信息，所以<strong>需要保持长连接</strong>，且<strong>频繁的实时推送会造成订阅者worker的负担</strong></li>
</ul></li>
</ul>
<p>最终选型：<strong>推模式</strong>，因为worker拉取任务时短时间的排队是允许的，而且拉取任务时的竞争问题可以通过加锁解决</p>
<h2 id="多阶段任务设计">3. 多阶段任务设计</h2>
<h3 id="多阶段任务调度流程">3.1 多阶段任务调度流程</h3>
<p>调度框架中的多阶段是在<strong>stage</strong>字段中体现的，<strong>stage</strong>字段的改变也是在<strong>worker</strong>中实现的，<strong>flowSvr</strong>对任务阶段是无感的</p>
<p>其中多阶段的调度流程如下图所示：</p>
<p><img src="/2024/08/18/Asyncflow%E9%A1%B9%E7%9B%AE4%EF%BC%9AWorker%E7%9A%84%E8%AE%BE%E8%AE%A1/multi_stage.png" width="40%"></p>
<h3 id="多阶段中的上下文">3.2 多阶段中的上下文</h3>
<p>多阶段中需要存储上一阶段的<strong>上下文信息</strong>，以便下一阶段的任务能够继续上一阶段的任务</p>
<p>这里由<strong>task_content</strong>字段来存储上下文信息，<strong>task_content</strong>字段的设计是为了<strong>worker执行任务</strong>，所以<strong>flower不需要理解上下文，只需要存储和传递</strong>，所以可以实现对各种类型任务的快速注册（只需要插入一条新配置）</p>
<p><strong>上下文类型</strong>：</p>
<ul>
<li><strong>json</strong>、url、文本...</li>
</ul>
<p><strong>task_content</strong>字段大小限制：</p>
<ul>
<li><strong>4096字节</strong>的限制</li>
</ul>
<p>前瞻设计-当超过这个限制时：</p>
<ul>
<li>way1：需要开辟额外的空间用于存储上下文，而<strong>task_content</strong>字段只存储上下文的<strong>索引</strong>
<ul>
<li>如：将mp3、mp4等存在云盘中，只存储云盘的地址</li>
</ul></li>
<li>way2：使用文档型数据库如<strong>MongoDB</strong>来替换MySQL</li>
</ul>
<h3 id="上下文举例">3.2 上下文举例</h3>
<p>数据量较少的上下文，最常用的是<strong>json格式</strong>的上下文，通过<strong>存储时的序列化</strong>和<strong>读取时的反序列化成数据结构</strong></p>
<p>如一类上下文由<strong>SourceUrl</strong>、<strong>CheckTaskID</strong>、<strong>SourceId</strong>组成：</p>
<p>序列化：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;SourceUrl&quot;</span>: <span class="string">&quot;http://www.video1.com&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;CheckTaskID&quot;</span>: <span class="number">1234</span>,</span><br><span class="line">    <span class="attr">&quot;SourceId&quot;</span>: <span class="number">22</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反序列化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">    std::string SourceUrl;</span><br><span class="line">    <span class="keyword">int</span> CheckTaskID;</span><br><span class="line">    <span class="keyword">int</span> SourceId;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Asyncflow</category>
      </categories>
  </entry>
  <entry>
    <title>Asyncflow项目3：FlowSvr的设计</title>
    <url>/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE3%EF%BC%9AFlowSvr%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一flowsvr对外接口设计">一、flowSvr对外接口设计</h1>
<p>flowSvr对外接口主要有对<strong>user</strong>的暴露接口和对<strong>worker</strong>暴露的接口，<code>content-type</code>均为<code>application/json</code>（通过序列化反序列化解析），有GET和POST两种请求方式：</p>
<ul>
<li><strong>GET</strong>请求：<strong>只能通过url传递参数</strong>，参数在url中可见，不安全，常用于<strong>向服务器请求数据（适合数据过滤检索的场景）</strong></li>
<li><strong>POST</strong>请求：<strong>参数在请求体content中</strong>，不会在url中显示，安全，常用于<strong>向服务器提交数据（表单提交、创建任务）</strong></li>
</ul>
<h2 id="种post接口说明3user2worker">1.
5种POST接口说明（3user，2worker）</h2>
<h3 id="user创建任务接口">1.1 user创建任务接口</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/create_task</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/create_task</code></li>
<li>说明：user向flowSvr提交任务，flowSvr将任务存入数据库，返回任务id</li>
</ul>
<p><strong>2）请求体中json字段说明</strong></p>
<ul>
<li>JSON请求字段为<code>task_data</code>，结构体中包含以下多个字段：
<ul>
<li><code>task_id</code>：创建时不填，可用于接口幂等保证</li>
<li><code>task_type</code>：任务类型</li>
<li><code>task_content</code>：任务内容</li>
<li><code>task_priority</code>：任务优先级，默认为<code>0</code></li>
<li><code>user_id</code>：用户id</li>
</ul></li>
</ul>
<p><strong>3）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息
<ul>
<li>成功：<code>SUCCESS</code></li>
<li>失败情况说明：<code>FAIL_REASON::ERROR_MSG</code></li>
</ul></li>
<li><code>task_id</code>：任务id（成功时返回，用于后续查询任务状态）</li>
</ul>
<h3 id="user创建任务接口-1">1.2 user创建任务接口</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/register_task</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/register_task</code></li>
<li>说明：user向flowSvr注册任务类型，flowSvr将<strong>任务配置信息</strong>插入<strong>任务配置表</strong>，并插入<strong>任务位置表</strong></li>
</ul>
<p><strong>2）请求体中json字段说明</strong></p>
<ul>
<li>JSON请求字段为<code>task_config_data</code>，结构体中包含以下多个字段：
<ul>
<li><code>task_type</code>：任务类型</li>
<li><code>schedule_limit</code>：单次调度拉取数</li>
</ul></li>
</ul>
<p><strong>3）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
</ul>
<h3 id="user创建新任务类型接口">1.3 user创建新任务类型接口</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/register_task_type</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/register_task_type</code></li>
<li>说明：user向flowSvr注册新的任务类型，flowSvr将<strong>任务配置信息</strong>插入<strong>任务配置表</strong>，并插入<strong>任务位置表</strong>，新建<strong>任务信息表1</strong></li>
</ul>
<p><strong>2）请求体中json字段说明</strong></p>
<ul>
<li>JSON请求字段为<code>task_type_data</code>，结构体中包含以下多个字段：
<ul>
<li><code>task_type</code>：任务类型</li>
<li><code>schedule_limit</code>：单次调度拉取数（可选）</li>
<li><code>schedule_interval</code>：每次拉取任务间隔（可选）</li>
<li><code>max_retry_num</code>：最大重试次数（可选）</li>
<li><code>max_retry_interval</code>：最大重试时间间隔（可选）</li>
</ul></li>
</ul>
<p><strong>3）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
</ul>
<h3 id="worker拉取占据一批任务的接口">1.4
worker拉取占据一批任务的接口</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/hold_tasks</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/hold_tasks</code></li>
<li>说明：worker向flowSvr拉取一批任务，flowSvr将<strong>这批任务的status</strong>置为<strong>2执行中</strong>，并<strong>返回任务列表给worker</strong></li>
</ul>
<p><strong>2）请求体中json字段说明</strong></p>
<ul>
<li><code>task_type</code>：任务类型</li>
</ul>
<p><strong>3）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
<li><code>task_list</code>：任务列表（成功时返回）
<ul>
<li><code>user_id</code>：用户id</li>
<li><code>task_id</code>：任务id</li>
<li><code>task_type</code>：任务类型</li>
<li>......（任务信息表其它所有字段）</li>
</ul></li>
</ul>
<h3 id="worker提交任务执行结果更新任务">1.5
worker提交任务执行结果（更新任务）</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/set_task</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/set_task</code></li>
<li>说明：worker向flowSvr提交任务执行结果，主要为<strong>更新status、schedule_log、crt_retry_num、stage、task_content</strong>字段</li>
</ul>
<p><strong>2）请求体中json字段说明</strong></p>
<ul>
<li>JSON请求字段为<code>task_data</code>，结构体中包含以下多个字段：
<ul>
<li><code>task_id</code>：任务id</li>
<li><code>task_type</code>：任务类型</li>
<li><code>status</code>：任务状态</li>
<li><code>schedule_log</code>：任务调度日志</li>
<li><code>crt_retry_num</code>：当前已经重试次数</li>
<li><code>task_stage</code>：任务阶段</li>
<li><code>task_content</code>：任务内容</li>
</ul></li>
</ul>
<p><strong>3）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
</ul>
<h2 id="种get接口说明">2. 5种GET接口说明</h2>
<h3 id="ping接口">2.1 PING接口</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/ping</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/ping</code></li>
<li>说明：用于测试flowSvr是否正常</li>
<li>无请求参数</li>
</ul>
<h3 id="user通过task_id查询任务状态">2.2
user通过task_id查询任务状态</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/get_task</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/get_task?task_id=xxx</code></li>
<li>说明：user通过task_id查询任务状态</li>
</ul>
<p><strong>2）请求参数</strong></p>
<ul>
<li><code>task_id</code>：生成<strong>task_id</strong>的时候会<strong>自带任务对应的表pos（如<code>...9ea_video_1</code>）</strong>，所以只需要传task_id即可</li>
</ul>
<p><strong>3）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
<li><code>task_data</code>：任务信息（成功时返回）
<ul>
<li><code>user_id</code>：用户id</li>
<li><code>task_id</code>：任务id</li>
<li><code>status</code>：任务状态</li>
<li><code>stage</code>：任务阶段</li>
<li><code>schedule_log</code>：任务调度日志</li>
<li><code>task_content</code>：任务内容</li>
</ul></li>
</ul>
<h3 id="管理查询所有任务配置信息">2.3 管理：查询所有任务配置信息</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/get_task_schedule_cfg_list</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/get_task_schedule_cfg_list</code></li>
<li>说明：查询所有任务配置信息</li>
</ul>
<p><strong>2）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
<li><code>task_schedule_cfg_list</code>：结构体，含任务配置信息列表所有字段</li>
</ul>
<h3 id="后台管理过滤筛选某个条件下n条任务信息">2.4
后台管理：过滤筛选某个条件下n条任务信息</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/get_task_list</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/get_task_list?task_type=xxx&amp;status=xxx&amp;limit=xxx</code></li>
<li>说明：过滤筛选某个条件下n条任务信息</li>
</ul>
<p><strong>2）请求参数</strong></p>
<p>以下可选的筛选条件：</p>
<ul>
<li><code>task_type</code>：任务类型</li>
<li><code>status</code>：任务状态</li>
<li><code>limit</code>：限制返回的任务数</li>
<li><code>stage</code>：任务阶段</li>
</ul>
<p><strong>3）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
<li><code>task_list</code>：符合条件的任务信息表所有字段</li>
</ul>
<h3 id="后台管理获取某个任务count数">2.5
后台管理：获取某个任务count数</h3>
<p><strong>1）接口说明</strong></p>
<ul>
<li>接口：<code>/get_task_counts_by_type</code></li>
<li>请求地址：<code>http://&lt;flowSvr_ip&gt;:&lt;port&gt;/v1/get_task_counts_by_type?task_type=xxx</code></li>
<li>说明：获取某个任务有多少条任务</li>
</ul>
<p><strong>2）响应体字段</strong></p>
<ul>
<li><code>code</code>：返回码，<strong>0表示成功</strong>，非0表示失败</li>
<li><code>msg</code>：返回信息，成功或失败的提示信息</li>
<li><code>task_count</code>：任务数</li>
</ul>
<h1 id="二flowsvr任务流程设计">二、flowSvr任务流程设计</h1>
<h2 id="创建任务流程">1. 创建任务流程</h2>
<ul>
<li>step1：user发起请求</li>
<li>step2：nginx负载均衡到flowSvr</li>
<li>step3：flowSvr接收请求，路由到<code>创建任务函数</code>
<ul>
<li>3.1：<code>HandlerIput</code>检查入参是否合法及完整，不合法则返回错误</li>
<li>3.2：<code>HandleProcess</code>处理插入任务逻辑
<ul>
<li><strong>任务位置表</strong>找到插入的表号</li>
<li><strong>任务配置表</strong>获取该任务的一些<strong>默认配置信息</strong></li>
<li>根据<strong>入参和配置信息</strong>插入任务表</li>
</ul></li>
<li>3.3：<code>HandlerOutput</code>回包</li>
</ul></li>
</ul>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE3%EF%BC%9AFlowSvr%E7%9A%84%E8%AE%BE%E8%AE%A1/create_task.png" width="50%"></p>
<h2 id="worker拉取占据任务流程">2. worker拉取占据任务流程</h2>
<ul>
<li>step1：worker发起请求</li>
<li>step2：nginx负载均衡到flowSvr</li>
<li>step3：flowSvr接收请求，路由到<code>占据任务函数</code>
<ul>
<li>3.1：<code>HandlerIput</code>检查入参是否合法及完整，不合法则返回错误</li>
<li>3.2：<code>HandleProcess</code>处理拉取任务逻辑
<ul>
<li><strong>任务位置表</strong>拿到当下要调度的表号</li>
<li><strong>任务配置表</strong>拿到该任务的<strong>单次拉取数</strong></li>
<li>在调度的表中根据<code>order_time</code>排序拉取一批任务</li>
<li>将这批任务的<strong>status</strong>置为<strong>2执行中</strong></li>
</ul></li>
<li>3.3：<code>HandlerOutput</code>回包</li>
</ul></li>
</ul>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE3%EF%BC%9AFlowSvr%E7%9A%84%E8%AE%BE%E8%AE%A1/hold_tasks.png" width="50%"></p>
<h1 id="三具体设计细节">三、具体设计细节</h1>
<h2 id="最大重试时间设计">1. 最大重试时间设计</h2>
<p>框架允许选用两种重试策略：<strong>均匀重试</strong>和<strong>渐进重试</strong>，由<strong>任务配置表</strong>中的<code>max_retry_interval</code>字段控制</p>
<ul>
<li>当<code>max_retry_interval</code>为<strong>负数</strong>时，表示采用<strong>均匀重试</strong>策略</li>
<li>当<code>max_retry_interval</code>为<strong>正数</strong>时，表示采用<strong>渐进重试</strong>策略</li>
</ul>
<p>重试次数策略</p>
<ul>
<li><code>max_retry_num</code>：最大重试次数</li>
<li><code>crt_retry_num</code>：当前已经重试次数</li>
<li><code>max_retry_interval</code>：最大重试时间间隔</li>
</ul>
<p>渐进重试公式：<code>order_time += min(1&lt;&lt;crt_retry_num, max_retry_interval)</code></p>
<p>举例：<code>max_retry_interval=10</code>，重试时会从1开始，翻倍递增，直到10后一直不变，直到达到最大重试次数。[1,
2, 4, 8, 10, 10, 10, 10, 10, 10]</p>
<h2 id="拉取任务的优先级">2. 拉取任务的优先级</h2>
<p>排序的目的：用于<strong>拉取任务时优先选择拉取哪些任务</strong></p>
<p>拉取任务的先后排序跟以下三个因素相关：</p>
<ul>
<li><strong>任务创建时间modify_time</strong></li>
<li><strong>任务优先级priority</strong></li>
<li><strong>任务重试时间retry_interval</strong></li>
</ul>
<h3 id="任务创建时间">2.1 任务创建时间</h3>
<p>任务创建时间是任务的<strong>基础排序</strong>，即<strong>先创建的任务先执行</strong>，但是由于该调度算法存在多阶段任务，所以如果按照<strong>创建时间</strong>排序，会导致某些后来的处于低阶段的任务被饿死</p>
<p>解决：摈弃<strong>创建时间</strong>，改成用<strong>修改时间modify_time</strong>做为排序的依据</p>
<h3 id="任务优先级">2.2 任务优先级</h3>
<p>任务优先级是任务的<strong>第二排序</strong>，即<strong>优先级高的任务先执行</strong>，优先级高的任务会被提前调度</p>
<p>一般的任务，都是采用<strong>绝对优先级</strong>，但是在该调度框架中要考虑<strong>重试</strong>的情况，所以不能单一考虑<strong>绝对优先级</strong></p>
<p>因此框架中将<strong>优先级</strong>抽象成<strong>提前priority时间</strong></p>
<h3 id="任务重试时间">2.3 任务重试时间</h3>
<p>任务重试阶段要保证任务在<strong>重试时间间隔retry_interval内</strong>不会被调度</p>
<h3 id="order_time排序">2.4 order_time排序</h3>
<p><strong>1）order_time的设计原理</strong></p>
<p>在上述三种影响因素下，如果我们拉取任务时需要同时将<strong>priority</strong>和<strong>modify_time</strong>都加上联合索引，且大多数时候priority是一样的，增加一个索引很浪费资源，而且priority作为最高优先级其实不合理，比如一个高优先级任务失败后又马上被选中执行了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_lark_task_1 <span class="keyword">WHERE</span> (status <span class="operator">=</span> <span class="number">1</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> priority <span class="keyword">desc</span>, modify_time LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<ul>
<li>抽象出一个中间字段<code>order_time</code>耦合上面的三个排序相关字段</li>
</ul>
<p>排序原理：</p>
<ul>
<li>order_time的相对时间戳越小，越早被拉取</li>
</ul>
<p>优点：</p>
<ul>
<li><strong>解耦</strong>，只需要给<code>order_time</code>与<code>status</code>加上<strong>联合索引</strong>，不用给几个相关字段都加入联合索引</li>
<li>让低优先级任务也有可能有更早被调用的可能</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_lark_task_1 <span class="keyword">WHERE</span> (status <span class="operator">=</span> <span class="number">1</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> order_time LIMIT <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p><strong>2）order_time的更新</strong></p>
<p>在设计更新规则时需要同时考虑三个因素的规则：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>更新规则约束</th>
</tr>
</thead>
<tbody>
<tr>
<td>modify_time</td>
<td>先进先出</td>
<td>保证多阶段下，新阶段扔回去时排到队尾</td>
</tr>
<tr>
<td>priority</td>
<td>考虑任务优先级</td>
<td>解耦，将priority由级别抽象成优先priority秒，级别更高的提前的秒数更多</td>
</tr>
<tr>
<td>retry_interval</td>
<td>防止被异常任务阻塞住</td>
<td>添加重试时间，异常失败的任务需要的重试时间肯定长，也就是排得后面点</td>
</tr>
</tbody>
</table>
<p>根据以上约束，<code>order_time</code>在三个阶段需要更新：</p>
<ul>
<li><strong>任务创建</strong>：<code>order_time = create_time - priority</code>
<ul>
<li>说明：根据优先级<strong>提前任务调度时间</strong></li>
</ul></li>
<li><strong>任务执行成功</strong>：<code>order_time = modify_time - priority</code>
<ul>
<li>说明：根据优先级<strong>提前任务调度时间</strong></li>
</ul></li>
<li><strong>任务执行失败&amp;&amp;治理模块发现超时任务</strong>：<code>order_time = modify_time + retry_interval</code>
<ul>
<li>说明：根据<strong>重试时间</strong>延迟任务被调度时间</li>
<li>这里不能加上priority，否则无法保证<strong>重试时间间隔retry_interval内</strong>不会被调度</li>
</ul></li>
</ul>
<h2 id="分表设计">3. 分表设计</h2>
<h3 id="分表策略">3.1 分表策略</h3>
<p>这里对多种分表策略进行对比：</p>
<ul>
<li><strong>不分表</strong>：不分表<strong>全表扫描性能会很差</strong>，同时<strong>影响查询和任务拉取接口</strong>的效率</li>
<li><strong>hash切分user_id</strong>：如果按user分表是更<strong>有利于数据过滤查询</strong>这种<strong>后台管理业务</strong>的实现，比如购物车心愿单添加这种场景</li>
<li><strong>按大小阈值滚表</strong>：通常调度框架的目的是做任务调度，按照user的话表内会存在很多冷数据，影响拉取任务时的检索速度</li>
<li><strong>分库+分表</strong>：只有分表的话会存在<strong>任务提交单超过MySQL处理能力时的性能瓶颈问题</strong>，单MySQL实例库的话无法进行水平扩展（由于受单MySQL库的性能瓶颈影响，水平扩展多个flowSvr或worker后也难以提升性能）</li>
</ul>
<p>策略选择：</p>
<ul>
<li><strong>hash还是滚表</strong>：如mycat等中间件实现分表的策略一般是<strong>hash切分user_id</strong>，而在该调度框架中，由于任务是不断推进的，冷表属于过去式，对任务拉取性能会有影响，我们更关注的是热表数据，因此在次特点上采用<strong>range</strong>按大小阈值滚表策略保证<strong>pos区间外的冷数据在拉取任务时不会加入检索中</strong>（pos区间内的冷数据还是无法避免，但已经一定程度上提高性能了）</li>
<li><strong>分表还是分库+分表</strong>：本项目场景下，<strong>异步执行任务最大的瓶颈</strong>出现在<strong>worker执行的具体耗时任务</strong>上，也就是worker调用的下游接口的性能，所以就算flowSvr性能提升允许接收更多任务，下游接口也处理不了（如北斗解算场景），同时引入分库会增加开发及维护成本，所以本项目采用<strong>分表</strong>策略</li>
</ul>
<p>前瞻设计-<strong>分库+分表</strong>：</p>
<p>如果实在是要<strong>提高flowsvr的接收能力</strong>的话，也是可以通过引入中间件通过hash切片将用户分到不同数据库实例中隔离开来执行（tdsql天然支持切片，或者使用中间件mycat）</p>
<ul>
<li>分库依据：根据user_id字段进行将数据分布到不同的数据库中</li>
<li>主从同步：配置 MySQL
的主从复制功能，使得主库（写）的数据变化可以实时同步到从库（读、负载均衡）。采用异步复制或半同步复制的方式，确保数据一致性和读写分离。</li>
<li>配置文件
<ul>
<li><strong>mycat</strong>中间件中配置<strong>读写分离配置</strong></li>
<li>结合<strong>数据库本身</strong>的<strong>主从复制</strong>功能能实现主从数据库</li>
</ul></li>
</ul>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE3%EF%BC%9AFlowSvr%E7%9A%84%E8%AE%BE%E8%AE%A1/mycat_master_slave.png" width="50%"></p>
<blockquote>
<p>参考： <a href="https://www.cnblogs.com/joylee/p/7513038.html">学会使用Mycat实现分库分表</a>
<a href="https://juejin.cn/post/7082719286518612005">MySQL主从复制</a>
<a href="https://www.jianshu.com/p/05df9ed24c97">Redis主从复制</a></p>
</blockquote>
<h3 id="分表设计-1">3.2 分表设计</h3>
<p>由于是范围滚表，所以在<strong>任务位置表</strong>中需要有<strong>开始位置begin_pos</strong>和<strong>结束位置end_pos</strong>两个字段，用于标记<strong>worker下次调度在哪个表拉取任务</strong>和<strong>user下次在哪个表插入任务</strong></p>
<p><strong>1）位置更新</strong></p>
<p>对<code>end_pos</code>的更新途径：</p>
<ul>
<li><strong>任务治理模块</strong>：定时全表扫描，当前表<code>status</code>都为终态<code>3执行成功</code>或<code>4执行失败</code>时，更新<strong>end_pos++</strong></li>
</ul>
<p><code>begin_pos</code>的更新也意味着将进行分表，对<code>begin_pos</code>的更新途径：</p>
<ul>
<li><strong>任务治理模块</strong>：count&gt;500w时，更新<strong>begin_pos++</strong>，分表中对阈值的判断是&gt;=500w，允许<strong>分表的延时</strong>（也就是有可能是大于500w再分表的）</li>
</ul>
<p>分表模块划分：</p>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE3%EF%BC%9AFlowSvr%E7%9A%84%E8%AE%BE%E8%AE%A1/table_pos.png" width="50%"></p>
<p>分表流程：</p>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE3%EF%BC%9AFlowSvr%E7%9A%84%E8%AE%BE%E8%AE%A1/table_pos_flow.png" width="40%"></p>
<h3 id="分表参数">3.3 分表参数</h3>
<ul>
<li><strong>滚表阈值</strong>选择：<strong>500w</strong>，属于经验值&amp;&amp;阿里巴巴推荐值</li>
</ul>
<h2 id="数据库设计">4. 数据库设计</h2>
<h3 id="数据库选择">4.1 数据库选择</h3>
<p><strong>1）持久化数据库选择</strong></p>
<p>这里考虑选择<strong>MongoDB</strong>或<strong>MySQL</strong>两种数据库，MongoDB也是比较接近关系型数据库的非关系数据库了，刚开始是考虑<strong>MongoDB不支持事务也不支持join联表查询</strong>，其次是之前我一直接触的是MySQL，所以也存在一定的学习成本，最终选择了<strong>MySQL</strong></p>
<p>当然也会想到Redis的处理能力更强，也具备持久能力，但是Redis基于内存，成本高且存储能力有限，也有一定概率会丢失数据，因此不考虑用Redis</p>
<ul>
<li>redis用RDB持久化：快照有延迟，只适合做备份，宕机容易导致数据丢失</li>
<li>redis用AOF持久化：<strong>每次写操作都会记录日志</strong>，性能较差，且数据量大时会导致磁盘IO压力过大，主从同步也可能导致数据丢失</li>
</ul>
<p>前瞻设计-<strong>MongoDB</strong>：</p>
<ul>
<li>当然其实还有考虑一种场景就是<strong>上下文存的是大数据</strong>，也就是文件类型的话，后续可能就会引入MongoDB，但是目前还不需要</li>
</ul>
<p><strong>2）缓存数据库选择</strong></p>
<h3 id="数据库连接池设计">4.2 数据库连接池设计</h3>
<h4 id="连接池的作用">4.2.1 连接池的作用</h4>
<p>设计数据库连接池的作用：</p>
<ul>
<li>维护池中的长连接，<strong>减少</strong>接收请求时的频繁连接造成的<strong>创建成本</strong></li>
<li>避免高峰期大量连接进来导致的地址不够分配的问题，实现<strong>资源复用</strong></li>
</ul>
<h4 id="连接池参数">4.2.2 连接池参数</h4>
<p>GO语言开发下，选用<strong>GORM库</strong>实现数据库连接池，简化 Go
应用与数据库的交互</p>
<p><strong>GORM库</strong>连接池的特点：除了最大池内连接数（长连接）限制外，还做了<strong>最大连接数（长连接+短连接）兜底</strong>，也就是允许峰值时期的短连接，</p>
<p><strong>GORM库</strong>的连接池参数主要有以下几个：</p>
<table>
<colgroup>
<col style="width: 33%">
<col style="width: 33%">
<col style="width: 33%">
</colgroup>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>maxIdleConn</td>
<td>连接池中最大长连接个数，是影响连接池性能的最关键因素，<strong>调优空间大</strong></td>
<td>10</td>
</tr>
<tr>
<td>maxLifetime</td>
<td>最大空闲时间，在空闲连接检查中，<strong>超过该值的连接空闲会被释放连接资源</strong></td>
<td>0</td>
</tr>
<tr>
<td>maxOpenConn</td>
<td>连接池最大连接数，<strong>兜底用的</strong>，由<strong>长连接</strong>maxIdleConn和<strong>短连接</strong>决定</td>
<td>0</td>
</tr>
<tr>
<td>timeBetweenEvictionRunsMillis</td>
<td>配置一定时间<strong>检查要关闭的空闲连接</strong></td>
<td>0</td>
</tr>
</tbody>
</table>
<h2 id="任务治理模块">5. 任务治理模块</h2>
<p>在分表场景下，刚开始使用每次创建任务时都会<strong>全表扫描</strong>，但是随着任务量的增加，全表扫描的性能会越来越差，导致<strong>create_task</strong>接口的性能下降，因此引入<strong>任务治理模块</strong>，定时执行一些任务，在分表时也允许<strong>分表的延时</strong>，所以问题不大</p>
<p>任务治理模块主要执行以下两个任务：</p>
<p><img src="/2024/07/15/Asyncflow%E9%A1%B9%E7%9B%AE3%EF%BC%9AFlowSvr%E7%9A%84%E8%AE%BE%E8%AE%A1/task_governance.png" width="50%"></p>
<p>分表的sql逻辑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> t_lark_task_1;</span><br></pre></td></tr></table></figure>
<p>超时任务判断逻辑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> status<span class="operator">=</span><span class="number">2</span> <span class="keyword">and</span> now()<span class="operator">&gt;</span>modify_time<span class="operator">+</span>max_processing_time;</span><br></pre></td></tr></table></figure>
<h1 id="四flowsvr性能">四、flowSvr性能</h1>
<p>异步调度框架中最大的性能瓶颈是worker<strong>耗时任务</strong>，而flowSvr的瓶颈一般都是在<strong>数据库读写</strong>上，也就是MySQL</p>
<h2 id="数据库性能优化两个关键点">4.1 数据库性能优化两个关键点</h2>
<ul>
<li><strong>sql语句优化</strong>
<ul>
<li><strong>添加task_id索引</strong>和<strong>status-order_time联合索引</strong>，提高任务查询和拉取效率</li>
<li><strong>分表</strong>通过任务治理模块定时处理，减少全表扫描</li>
<li>在处理竞争时放弃<code>for update</code>的方式，转成使用分布式锁</li>
</ul></li>
<li><strong>数据库连接池优化</strong>
<ul>
<li>主要是对<strong>GORM库</strong>的连接池参数<code>maxIdleConn</code>和<code>maxOpenConn</code>进行调优，提高连接池性能</li>
</ul></li>
</ul>
<h2 id="数据库连接池调优">4.2 数据库连接池调优</h2>
<p>调优原因：一开始压测时查看<strong>netstat发现出现了很多TIME_WAIT</strong>，应该是端口被耗尽了，根据常识定位到消耗端口最大的可能性就是连接池的问题，因此将连接池的参数调大</p>
<p>测试工具：wrk这个轻量级工具进行压测，只需要进行一些配置就行</p>
<p>几个接口在2核4g下调优结果</p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr>
<th>接口</th>
<th>maxIdleConn初始值：QPS</th>
<th>maxIdleConn调优值：QPS</th>
<th>分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>create_task</td>
<td>10：350</td>
<td>1000：3000</td>
<td>正常</td>
</tr>
<tr>
<td>get_task</td>
<td>10：400</td>
<td>1000：3300</td>
<td>查询有redis缓存，QPS会高点也正常</td>
</tr>
<tr>
<td>hold_tasks</td>
<td>10：180</td>
<td>1000：2000</td>
<td>由于拉取任务既有业务逻辑又有数据库读写操作，较为复杂，QPS低点但是也有提升</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Asyncflow</category>
      </categories>
  </entry>
  <entry>
    <title>Asyncflow项目5：flowsvr开发</title>
    <url>/2024/09/14/Asyncflow%E9%A1%B9%E7%9B%AE5%EF%BC%9Aflowsvr%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="配置文件">1. 配置文件</h1>
<p>使用<code>TOML</code>作为配置管理</p>
<hr>
<p>导入配置文件</p>
<p>通过<code>DecodeFile</code>读取某路径下的配置文件并解析到结构体实例<code>Conf</code>中</p>
<hr>
<p>定义结构体解析配置文件</p>
<p>对于</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> commonConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    Port    <span class="keyword">int</span>  <span class="string">`toml:&quot;port&quot;`</span></span><br><span class="line">    OpenTLS <span class="keyword">bool</span> <span class="string">`toml:&quot;open_tls&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>toml:"port"：是结构体字段的标签（tag），它告诉 Go
中的TOML库应该将文件中的 <code>port</code> 字段映射到该结构体中的
<code>Port</code>变量中。</li>
</ul>
<hr>
<p>将<code>TOML</code>库添加到<code>go.mod</code>文件中</p>
<ul>
<li><p>使用<code>go mod init</code>初始化生成go.mod 文件</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set GO111MODULE=on</span><br><span class="line">export GOPROXY=https://goproxy.cn</span><br><span class="line">go mod init [name]//在项目目录下执行，其中name为项目文件夹名</span><br><span class="line">eg: go mod init Asyncflow-dev-raw</span><br></pre></td></tr></table></figure></p></li>
<li><p>使用<code>go get</code>下载<code>TOML</code>库</p>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">go get github.com/BurntSushi/toml</span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>参考</p>
<ol type="1">
<li><p><a href="https://blog.csdn.net/Gusand/article/details/106094535">Golang
toml完全解析示例</a></p></li>
<li><p><a href="https://github.com/BurntSushi/toml">toml-go客户端</a></p></li>
<li><p><a href="https://b23.tv/CqBtVlV">3分钟教你go语言如何使用go
module下载指定版本的golang库依赖管理</a></p></li>
</ol>
</blockquote>
<h1 id="项目资源">2. 项目资源</h1>
<h2 id="mysql数据库资源框架gorm">2.1. mysql数据库资源框架：gorm</h2>
<ul>
<li>数据库连接池：选择gorm库</li>
</ul>
<h3 id="gorm框架的字段映射">2.1.1.gorm框架的字段映射</h3>
<p><code>gorm</code>中映射字段有<strong>显式映射</strong>和<strong>隐式映射</strong>两种，<strong>隐式映射</strong>是通过字段名和类型自动映射，<strong>显式映射</strong>是通过<code>tag</code>标签映射，如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskPos <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id               <span class="keyword">uint64</span> <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">    TaskType         <span class="keyword">string</span> <span class="string">`gorm:&quot;column:task_type&quot;`</span></span><br><span class="line">    ScheduleBeginPos <span class="keyword">int</span>    <span class="string">`gorm:&quot;column:schedule_begin_pos&quot;`</span></span><br><span class="line">    ScheduleEndPos   <span class="keyword">int</span>    <span class="string">`gorm:&quot;column:schedule_end_pos&quot;`</span></span><br><span class="line">    CreateTime       *time.Time</span><br><span class="line">    ModifyTime       *time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高性能web框架gin">2.3 高性能Web框架：gin</h2>
<h3 id="gin框架的初始化">2.3.1. gin框架的初始化</h3>
<ul>
<li><p>创建Web服务</p></li>
<li><p>路由：定义路由组<code>/v1</code></p></li>
<li><p>路由中的<code>POST</code>请求：</p>
<ul>
<li>注册任务<code>/register_task</code></li>
<li>创建任务<code>/create_task</code></li>
<li>占据任务<code>/hold_task</code></li>
<li>执行完更新任务<code>/set_task</code></li>
</ul></li>
<li><p>路由中的<code>GET</code>请求：</p>
<ul>
<li>查询任务<code>/get_task</code></li>
<li>过滤获取一批任务<code>/get_task_list</code></li>
<li>获取任务配置表<code>/get_task_schedule_cfg_list</code></li>
<li>获取某个type任务的数量<code>/get_task_counts_by_type</code></li>
<li>Ping测试<code>/ping</code> <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RegisterRouter 注册路由</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterRouter</span><span class="params">(router *gin.Engine)</span></span> &#123;</span><br><span class="line">    v1 := router.Group(<span class="string">&quot;/v1&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册任务</span></span><br><span class="line">        v1.POST(<span class="string">&quot;/register_task&quot;</span>, task.RegisterTask)</span><br><span class="line">        <span class="comment">// 创建任务接口，前面是路径，后面是执行的函数，跳进去</span></span><br><span class="line">        v1.POST(<span class="string">&quot;/create_task&quot;</span>, task.CreateTask)</span><br><span class="line">        <span class="comment">// 占据任务</span></span><br><span class="line">        v1.POST(<span class="string">&quot;/hold_tasks&quot;</span>, task.HoldTasks)</span><br><span class="line">        <span class="comment">// 更新任务</span></span><br><span class="line">        v1.POST(<span class="string">&quot;/set_task&quot;</span>, task.SetTask)</span><br><span class="line">        <span class="comment">// 查询任务（请求参数是 TaskId）</span></span><br><span class="line">        v1.GET(<span class="string">&quot;/get_task&quot;</span>, task.GetTask)</span><br><span class="line">        <span class="comment">// 获取任务列表（请求参数是 taskType Limit Status）</span></span><br><span class="line">        v1.GET(<span class="string">&quot;/get_task_list&quot;</span>, task.GetTaskList)</span><br><span class="line">        <span class="comment">// 获取任务配置信息列表</span></span><br><span class="line">        v1.GET(<span class="string">&quot;/get_task_schedule_cfg_list&quot;</span>, task.GetTaskScheduleCfgList)</span><br><span class="line">        <span class="comment">// 通过taskType获取任务所有记录数量</span></span><br><span class="line">        v1.GET(<span class="string">&quot;/get_task_counts_by_type&quot;</span>, task.GetTaskCountsByType)</span><br><span class="line">        v1.GET(<span class="string">&quot;ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">            c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">                <span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>启动web server：<code>router.Run(Port)</code></p>
<ul>
<li>启动后主协程会阻塞在这里，等待接收请求</li>
</ul></li>
</ul>
<h3 id="gin框架的请求接收">2.3.2. gin框架的请求接收</h3>
<ul>
<li><p><code>c *gin.Context</code>：请求上下文</p></li>
<li><p><code>c.ShouldBind(&amp;task)</code>：将请求的json数据自动绑定到结构体<code>task</code>中</p>
<ul>
<li>其中结构体<code>task</code>需要定义<code>json</code>标签，如：
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TaskData 任务调度数据</span></span><br><span class="line"><span class="keyword">type</span> TaskData <span class="keyword">struct</span> &#123;</span><br><span class="line">  UserId           <span class="keyword">string</span>    <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">  TaskId           <span class="keyword">string</span>    <span class="string">`json:&quot;task_id&quot;`</span></span><br><span class="line">  TaskType         <span class="keyword">string</span>    <span class="string">`json:&quot;task_type&quot;`</span></span><br><span class="line">  TaskStage        <span class="keyword">string</span>    <span class="string">`json:&quot;task_stage&quot;`</span></span><br><span class="line">  Status           <span class="keyword">int</span>       <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">  Priority         *<span class="keyword">int</span>      <span class="string">`json:&quot;priority&quot;`</span></span><br><span class="line">  CrtRetryNum      <span class="keyword">int</span>       <span class="string">`json:&quot;crt_retry_num&quot;`</span></span><br><span class="line">  MaxRetryNum      <span class="keyword">int</span>       <span class="string">`json:&quot;max_retry_num&quot;`</span></span><br><span class="line">  MaxRetryInterval <span class="keyword">int</span>       <span class="string">`json:&quot;max_retry_interval&quot;`</span></span><br><span class="line">  ScheduleLog      <span class="keyword">string</span>    <span class="string">`json:&quot;schedule_log&quot;`</span></span><br><span class="line">  TaskContext      <span class="keyword">string</span>    <span class="string">`json:&quot;context&quot;`</span></span><br><span class="line">  OrderTime        <span class="keyword">int64</span>     <span class="string">`json:&quot;order_time&quot;`</span></span><br><span class="line">  CreateTime       time.Time <span class="string">`json:&quot;create_time&quot;`</span></span><br><span class="line">  ModifyTime       time.Time <span class="string">`json:&quot;modify_time&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="redis缓存资源goredis">2.3 redis缓存资源：goredis</h2>
<p>使用<code>goredis</code>库中的<strong>redis连接池</strong>，用在<strong>创建任务时</strong>增加缓存任务信息、以及使用<code>redission</code>库实现<strong>分布式锁</strong></p>
<h3 id="redis缓存">2.3.1. redis缓存</h3>
<p>redis缓存设置的过期时间以天为单位，在config.toml中设置具体的过期天数</p>
<p>redis缓存主要用于客户端轮询查询<strong>任务信息表</strong>中某个<code>TaskId</code>对应的任务信息，以及<strong>任务配置表</strong>中的任务配置信息</p>
<h3 id="分布式锁">2.3.2. 分布式锁</h3>
<p>使用<code>setnx</code>还是<code>redission</code>库实现分布式锁？</p>
<p>如果使用<code>setnx</code>，当锁过期无法续期，这样可能导致锁被释放，但是任务还没有执行完，从而导致任务重复执行</p>
<p>因此使用<code>redission</code>库实现分布式锁，通过<strong>看门狗机制</strong>实现锁的自动续期</p>
<h2 id="性能分析pprof">2.4 性能分析：pprof</h2>
<p>项目中使用<code>pprof</code>进行性能分析，可以通过<code>localhost:26688/debug/pprof/</code>查看性能分析结果</p>
<p><img src="/2024/09/14/Asyncflow%E9%A1%B9%E7%9B%AE5%EF%BC%9Aflowsvr%E5%BC%80%E5%8F%91/pprof_analyse.png" width="60%"></p>
<ul>
<li>在<code>main</code>函数中添加<code>pprof</code>的启动代码
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;0.0.0.0:26688&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li>
<li><code>net/http/pprof</code>包中提供了<code>pprof</code>的几种路由
<ul>
<li><code>goroutine</code>：查看当前程序中的goroutine数</li>
<li><code>heap</code>：查看堆内存的分配情况</li>
<li><code>threadcreate</code>：查看线程的创建情况</li>
<li><code>block</code>：查看阻塞事件的记录</li>
<li><code>cmdline</code>：查看当前程序的命令行参数</li>
<li><code>profile</code>：查看CPU的profile信息</li>
<li><code>trace</code>：查看当前程序的trace信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ppfof包中提供了几种路由</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    prefix := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> godebug.New(<span class="string">&quot;httpmuxgo121&quot;</span>).Value() != <span class="string">&quot;1&quot;</span> &#123;</span><br><span class="line">        prefix = <span class="string">&quot;GET &quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    http.HandleFunc(prefix+<span class="string">&quot;/debug/pprof/&quot;</span>, Index)</span><br><span class="line">    http.HandleFunc(prefix+<span class="string">&quot;/debug/pprof/cmdline&quot;</span>, Cmdline)</span><br><span class="line">    http.HandleFunc(prefix+<span class="string">&quot;/debug/pprof/profile&quot;</span>, Profile)</span><br><span class="line">    http.HandleFunc(prefix+<span class="string">&quot;/debug/pprof/symbol&quot;</span>, Symbol)</span><br><span class="line">    http.HandleFunc(prefix+<span class="string">&quot;/debug/pprof/trace&quot;</span>, Trace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="日志框架seelog">2.5. 日志框架：seelog</h2>
<p>用XML格式统一化日志输出的格式，方便后续日志的查看和分析，存储路径为<code>"../log/web.log"</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">seelog</span> <span class="attr">minlevel</span>=<span class="string">&quot;trace&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">outputs</span> <span class="attr">formatid</span>=<span class="string">&quot;fmt_info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">levels</span>=<span class="string">&quot;trace,debug,info,warn,error,critical&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingfile</span> <span class="attr">formatid</span>=<span class="string">&quot;fmt_info&quot;</span> <span class="attr">type</span>=<span class="string">&quot;size&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;../log/web.log&quot;</span>  <span class="attr">maxsize</span>=<span class="string">&quot;104857600&quot;</span> <span class="attr">maxrolls</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">levels</span>=<span class="string">&quot;error,critical&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">rollingfile</span> <span class="attr">formatid</span>=<span class="string">&quot;fmt_err&quot;</span> <span class="attr">type</span>=<span class="string">&quot;size&quot;</span> <span class="attr">filename</span>=<span class="string">&quot;../log/error/web_error.log&quot;</span>  ` +</span></span><br><span class="line"><span class="tag">      `<span class="attr">maxsize</span>=<span class="string">&quot;10485760&quot;</span> <span class="attr">maxrolls</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">outputs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">format</span> <span class="attr">id</span>=<span class="string">&quot;fmt_info&quot;</span> <span class="attr">format</span>=<span class="string">&quot;%Date(2006-01-02 15:04:05.999):::%Msg%n&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">format</span> <span class="attr">id</span>=<span class="string">&quot;fmt_err&quot;</span> <span class="attr">format</span>=<span class="string">&quot;%Date(2006-01-02 15:04:05.999):::%Msg%n&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">seelog</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考</p>
<ol type="1">
<li><p><a href="https://gorm.io/zh_CN/docs/index.html">GORM
指南:中文官方文档-数据库操</a></p></li>
<li><p><a href="https://gin-gonic.com/zh-cn/docs/">gin框架</a></p></li>
<li><p><a href="https://juejin.cn/post/6844903938093744142">golang框架-web框架之gin</a></p></li>
<li><p><a href="https://juejin.cn/post/7121614553649004575">一文搞懂gin框架httprouter路由实现原理</a></p></li>
<li><p><a href="https://colobu.com/2016/03/23/Go-HTTP-request-router-and-web-framework-benchmark/">超全的Go
Http路由框架性能比较</a></p></li>
<li><p><a href="https://github.com/redis/go-redis">Github
go-redis</a></p></li>
<li><p><a href="https://redis.uptrace.dev/zh/guide/go-redis.html">Go
Redis 快速入门</a></p></li>
<li><p><a href="https://github.com/cihub/seelog">Go 日志框架：seelog
github</a></p></li>
<li><p><a href="https://blog.csdn.net/qq_36051316/article/details/118696592">seelog使用</a></p></li>
</ol>
</blockquote>
<h1 id="路由对应的任务调度方法task">3. 路由对应的任务调度方法：task</h1>
<p>接入<code>Handler</code>库，定义所有接口均需处理的两个接口方法：</p>
<ul>
<li><code>HandleInput</code>：检查输入参数是否合法</li>
<li><code>HandleProcess</code>：参数合法后，HandleProcess处理业务逻辑</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HandlerIntf handler接口</span></span><br><span class="line"><span class="keyword">type</span> HandlerIntf <span class="keyword">interface</span> &#123;</span><br><span class="line">	HandleInput() error</span><br><span class="line">	HandleProcess() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建任务create_task">3.1. 创建任务<code>create_task</code></h2>
<p><code>CreateTaskHandler</code>实现<code>HandlerIntf</code>的两个接口，并作为<code>Run</code>方法的参数传入，其中<code>Run</code>方法统一执行自定义的<code>HandleInput</code>和<code>HandleProcess</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Package handler 用于接口逻辑处理</span></span><br><span class="line"><span class="keyword">package</span> handler</span><br><span class="line"></span><br><span class="line"><span class="comment">//Run 执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(handler HandlerIntf)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := handler.HandleInput()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	err = handler.HandleProcess()</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerIntf handler接口</span></span><br><span class="line"><span class="keyword">type</span> HandlerIntf <span class="keyword">interface</span> &#123;</span><br><span class="line">	HandleInput() error</span><br><span class="line">	HandleProcess() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="handleinput">1）HandleInput</h3>
<p><code>c.ShouldBind(&amp;hd.Req)</code>：将请求的json数据自动绑定到结构体<code>task</code>中，然后检查请求参数是否合法</p>
<ul>
<li>检查<code>hd.Req</code>中的<code>TaskType</code>是否为空</li>
<li>检查<code>hd.Req</code>中的<code>Priority</code>是否为空</li>
<li>检查<code>hd.Req</code>中的<code>Priority</code>值在<code>[0, db.MAX_PRIORIT]</code>之间</li>
</ul>
<h3 id="handleprocess">2）HandleProcess</h3>
<p>其中数据库操作使用<code>gorm</code>库，<code>db.Create</code>方法创建新纪录、<code>db.Save</code>方法更新某一条记录（其中根据表的主键更新）</p>
<p><code>gorm</code>库的数据库操作方法通过<code>struct</code>中的各个字段<strong>隐式映射</strong>按顺序对应数据库表中的字段，实现了自动映射，如位置配置表的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskPos <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id               <span class="keyword">uint64</span></span><br><span class="line">	TaskType         <span class="keyword">string</span></span><br><span class="line">	ScheduleBeginPos <span class="keyword">int</span></span><br><span class="line">	ScheduleEndPos   <span class="keyword">int</span></span><br><span class="line">	CreateTime       *time.Time</span><br><span class="line">	ModifyTime       *time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取分表中<strong>位置信息表的信息</strong>：找到插入的位置<code>endPos</code></li>
<li>获取<strong>任务配置表</strong>中的该任务的配置信息：用于填充插入的一条新任务的<strong>基础配置信息</strong></li>
<li>创建<strong>任务信息表</strong>：插入一条新任务的信息</li>
<li>填充<code>p.Resp</code>的回包信息（含唯一的<code>TaskId</code>）</li>
<li>增加该条任务完整信息的<strong>redis缓存</strong>：string类型，设置过期时间24小时</li>
</ul>
<p>其中<code>createTask</code>需要通过<code>uuid</code>生成唯一索引<code>TaskId</code>，并拼接上<strong>表名</strong>方便滚表方式下随时查询</p>
<p><code>uuid</code>使用<code>"github.com/google/uuid"</code>库，通过<code>uuid.New()</code>生成唯一索引</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GenTaskId 生成对应taskId</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Task)</span> <span class="title">GenTaskId</span><span class="params">(taskType, pos <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">taskType = strings.Replace(taskType, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%+v_%s_%s&quot;</span>, uuid.New(), taskType, pos)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注册任务register_task">3.2.
注册任务<code>register_task</code></h2>
<h3 id="handleinput-1">1）HandleInput</h3>
<ul>
<li>检查<code>hd.Req</code>中的<code>TaskType</code>是否为空</li>
</ul>
<h3 id="handleprocess-1">2）HandleProcess</h3>
<ul>
<li>创建对应的<strong>任务信息表</strong>：<code>t_taskType_1</code></li>
<li>在<strong>位置信息表</strong>插入一条(beginPos, endPos)为(1,
1)的记录</li>
<li>在<strong>任务配置表</strong>插入一条任务配置信息</li>
</ul>
<h2 id="占据任务hold_task">3.3. 占据任务<code>hold_task</code></h2>
<h3 id="handleinput-2">1）HandleInput</h3>
<ul>
<li>检查<code>hd.Req</code>中的<code>TaskType</code>是否为空：根据任务类型拉取一批任务</li>
</ul>
<h3 id="handleprocess-2">2）HandleProcess</h3>
<ul>
<li>修正batch的limit值</li>
<li>从<strong>位置信息表</strong>中获取当前任务类型的<code>beginPos</code></li>
<li>获取一批<strong>任务类型为待执行</strong>的任务
<ul>
<li>任务拉取约束为：<code>order_time &lt; NOW</code>和<code>status</code>，并按照<code>order_time</code>升序排列</li>
</ul></li>
<li>将拉取到的一批任务的<code>status</code>更新为<code>TASK_STATUS_PROCESSING</code>并逐个装进<code>hd.Resp</code>中</li>
<li>更新数据库
<ul>
<li>更新当前一批任务的<code>status</code>为<code>TASK_STATUS_PROCESSING</code></li>
<li>并更新<code>modify_time</code></li>
</ul></li>
</ul>
<h2 id="执行完更新任务set_task">3.4.
执行完更新任务<code>set_task</code></h2>
<h3 id="handleinput-3">1）HandleInput</h3>
<ul>
<li>检查<code>hd.Req</code>中的<code>TaskId</code>是否为空：更新一条<code>TaskId</code>对应的任务</li>
<li>检查<code>hd.Req</code>中的<code>Priority</code>的数值</li>
</ul>
<h3 id="handleprocess-3">2）HandleProcess</h3>
<ul>
<li>更新<strong>任务信息表</strong>中的<code>TaskId</code>对应的任务的<code>status</code>为<code>TASK_STATUS_FINISHED</code>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只对id为p.TaskId 且 该任务状态不为成功和失败的任务进行更新，更新内容为p中的内容</span></span><br><span class="line">err := db.Table(tableName).Where(<span class="string">&quot;task_id = ?&quot;</span>, p.TaskId).</span><br><span class="line">Where(<span class="string">&quot;status &lt;&gt; ? and status &lt;&gt; ?&quot;</span>, TASK_STATUS_SUCCESS, TASK_STATUS_FAILED).Updates(p).Error</span><br></pre></td></tr></table></figure></li>
<li>清除<strong>redis缓存</strong>中的该条任务信息</li>
</ul>
<h2 id="查询任务get_task">3.5. 查询任务<code>get_task</code></h2>
<p><code>GET</code>方法需要从<code>Request</code>中获取请求参数，这里同样通过<code>c.ShouldBind(&amp;hd.Req)</code>将请求的json数据自动绑定到结构体<code>task</code>中</p>
<h3 id="handleinput-4">1）HandleInput</h3>
<ul>
<li>检查<code>hd.Req</code>中的<code>TaskId</code>是否为空：查询一条<code>TaskId</code>对应的任务</li>
</ul>
<h3 id="handleprocess-4">2）HandleProcess</h3>
<ul>
<li>从<strong>redis缓存</strong>中查询是否含该<code>TaskId</code>的任务信息</li>
<li>若有则直接返回，否则从<strong>任务信息表</strong>查找<strong>数据库</strong></li>
<li>若数据库中有该任务信息，则将该任务信息重新写入<strong>redis缓存</strong>中，方便下一次查询</li>
<li>装包：将查询到的任务信息装进<code>hd.Resp</code>的响应信息中</li>
</ul>
<h1 id="任务治理模块设计">4. 任务治理模块设计</h1>
<p>任务治理模块主要进行<strong>分表处理</strong>和<strong>卡死任务处理</strong>两个功能</p>
<p>任务管理通过<code>go routine</code>开启三个<strong>协程</strong>，协程在<code>for</code>死循环中不断执行，每个协程维护一个<strong>定时器</strong>定时处理一项特定任务：</p>
<h2 id="卡死任务处理">4.1. 卡死任务处理</h2>
<p>开启定时器：定为10s检查一次，当任务过期时，相当于用掉一次<strong>超时重试</strong>机会，所以重置任务状态时还需要更新<strong>超时重试次数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(time.Duration(config.Conf.Task.LongProcessInterval) * time.Second)</span><br><span class="line">        <span class="comment">// &lt;-t.C：阻塞等待定时器到期</span></span><br><span class="line">		&lt;-t.C</span><br></pre></td></tr></table></figure>
<h2 id="分表处理新增表end_pos">4.2. 分表处理：新增表end_pos</h2>
<p>开启定时器：定为30s检查一次是否需要分表，每次统计<strong>任务位置表</strong>中<code>endPos</code>表的记录数，若超过<strong>分表阈值</strong>，则进行分表操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(time.Duration(config.Conf.Task.SplitInterval) * time.Second)</span><br><span class="line">		&lt;-t.C</span><br></pre></td></tr></table></figure>
<h2 id="分表处理更新拉取任务的表begin_pos">4.3.
分表处理：更新拉取任务的表begin_pos</h2>
<p>开启定时器：定为10s检查一次表任务是否已经全部执行完（通过比较<code>begin_pos</code>表中所有状态为<code>成功</code>和<code>失败</code>的任务数和<code>end_pos</code>表中的总任务数，如果相等则滚表到下一张表）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">t := time.NewTimer(time.Duration(config.Conf.Task.MoveInterval) * time.Second)</span><br><span class="line">		&lt;-t.C</span><br></pre></td></tr></table></figure>
<h1 id="go学习笔记">GO学习笔记</h1>
<h2 id="goland全局搜索">1. Goland全局搜索</h2>
<ul>
<li>按两次<code>Shift</code>：全局搜索</li>
<li><code>Ctrl+Shift+F</code>：全局搜索</li>
</ul>
<h2 id="依赖包含关系">2. 依赖包含关系</h2>
<ul>
<li>在调用其他包的方法时，要保证该方法是公开的，即<strong>首字母大写</strong></li>
<li>go的<code>init</code>函数是在包被导入时自动执行的函数，可以用来初始化包</li>
</ul>
]]></content>
      <categories>
        <category>Asyncflow</category>
      </categories>
  </entry>
  <entry>
    <title>Asyncflow项目6：worker开发</title>
    <url>/2024/09/16/Asyncflow%E9%A1%B9%E7%9B%AE6%EF%BC%9Aworker%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="配置文件">1. 配置文件</h1>
<p>使用<code>TOML</code>作为配置管理</p>
<hr>
<p>导入配置文件</p>
<p>通过<code>DecodeFile</code>读取某路径下的配置文件并解析到结构体实例<code>Conf</code>中</p>
<hr>
<p>定义结构体解析配置文件</p>
<p>对于</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TomlConfig 配置</span></span><br><span class="line"><span class="keyword">type</span> TomlConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">FlowsvrAddr       <span class="keyword">string</span> <span class="string">`toml:&quot;flowsvr_addr&quot;`</span>        <span class="comment">// flowsvr的地址</span></span><br><span class="line">RedisLockAddr     <span class="keyword">string</span> <span class="string">`toml:&quot;redis_lock_addr&quot;`</span>     <span class="comment">// redis分布式锁的地址</span></span><br><span class="line">RedisLockPassword <span class="keyword">string</span> <span class="string">`toml:&quot;redis_lock_password&quot;`</span> <span class="comment">// redis分布式锁的密码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分布式锁go-redis框架">2. 分布式锁：go-redis框架</h1>
<p>本项目中使用<code>go-redis</code>库来实现分布式锁，通过<code>SetNX</code>命令结合<strong>看门狗机制</strong>手动实现一个<strong>分布式锁</strong>的，<code>SetNX</code>命令是一个原子性的操作，只有在key不存在时才会设置key的值。</p>
<p>其中使用的key为<code>taskType</code>，value为用uuid生成的<code>token</code>，过期时间为<code>expireTimeSecond</code>。</p>
<blockquote>
<p>参考</p>
<ol type="1">
<li><p><a href="https://github.com/redis/go-redis">Github
go-redis</a></p></li>
<li><p><a href="https://redis.uptrace.dev/zh/guide/go-redis.html">Go
Redis 快速入门</a></p></li>
</ol>
</blockquote>
<h1 id="task处理">3. Task处理</h1>
<p>Task处理完的返包用的是<code>http.Client</code>，通过<code>http.NewRequest</code>实现对服务端接口的调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">req, err := http.NewRequest(method, reqUrl, reader)</span><br></pre></td></tr></table></figure>
<h2 id="注册task">3.1 注册Task</h2>
<p>将Task注册到worker的<code>map</code>数据结构中，以<code>taskType</code>为键，<code>task</code>为值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TaskHandler <span class="keyword">struct</span> &#123;</span><br><span class="line">    TaskType <span class="keyword">string</span></span><br><span class="line">    NewProc  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">TaskIntf</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterHandler func RegisterHandler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterHandler</span><span class="params">(handler *TaskHandler)</span></span> &#123;</span><br><span class="line">	taskHandlerMap[handler.TaskType] = handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="task任务需要实现的公用接口">3.2 Task任务需要实现的公用接口</h2>
<p>task需要实现几个公用接口，封装在上述<code>TaskHandler</code>结构体中。主要实现：</p>
<ul>
<li><code>ContextLoad</code>：加载上下文</li>
<li><code>HandleProcess</code>：处理、执行任务</li>
<li><code>SetTask</code>：当前阶段任务完成，调用flowSvr接口更新当前任务状态</li>
<li><code>HandleFinish</code>：当前阶段任务完成执行的操作（更新任务状态）</li>
<li><code>HandleFinishError</code>：任务失败后执行后续的任务失败处理操作</li>
<li><code>Base</code>：反序列化任务信息到<code>TaskBase</code>结构体</li>
<li><code>CreateTask</code>：创建任务（创建</li>
<li><code>HandleFailedMust</code>：处理失败的任务，<strong>任务状态重置为失败</strong>，结束任务</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TaskIntf Task interface</span></span><br><span class="line"><span class="keyword">type</span> TaskIntf <span class="keyword">interface</span> &#123;</span><br><span class="line">	ContextLoad() error</span><br><span class="line">	HandleProcess() error</span><br><span class="line">	SetTask() error</span><br><span class="line">	HandleFinish()</span><br><span class="line">	HandleFinishError() error</span><br><span class="line">	Base() *TaskBase</span><br><span class="line">	CreateTask() (<span class="keyword">string</span>, error)</span><br><span class="line">	HandleFailedMust() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="task序列化反序列化处理json">3.3
Task序列化反序列化处理：json</h2>
<p>使用go中自带的<code>"encoding/json"</code>库来实现Task的序列化和反序列化。</p>
<h3 id="task序列化">3.3.1 Task序列化</h3>
<p>序列化是将结构体转换为json字符串的过程，使用<code>json.Marshal</code>函数实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b, err := json.Marshal(body)</span><br></pre></td></tr></table></figure>
<h3 id="task反序列化">3.3.2 Task反序列化</h3>
<p>反序列化是将json字符串转换为结构体的过程，使用<code>json.Unmarshal</code>函数实现。当向接口发送请求获得<code>response</code>后，需要将<code>response</code>的<code>body</code>部分反序列化为结构体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">err = json.Unmarshal(respStr, respData)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考</p>
<ol type="1">
<li><p><a href="https://zhuanlan.zhihu.com/p/115066986">golang解析json数据（Encoding/Json）</a></p></li>
<li><p><a href="https://www.cnblogs.com/niuben/p/15666154.html">golang
json解析</a></p></li>
</ol>
</blockquote>
<h1 id="任务调度">4. 任务调度</h1>
<h2 id="任务调度load任务配置">4.1 任务调度：load任务配置</h2>
<p>在worker启动时，先通过<code>get_task_schedule_cfg_list</code>接口获取任务调度配置，然后根据配置的调度时间，定时执行任务。</p>
<p>开启一个goroutine，每隔<code>20s</code>请求更新一次任务调度配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始化加载任务配置信息表</span></span><br><span class="line">	<span class="keyword">if</span> err := LoadCfg(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		msg := <span class="string">&quot;load task cfg schedule err&quot;</span> + err.Error()</span><br><span class="line">		martlog.Errorf(msg)</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">		os.Exit(<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		CycleReloadCfg()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="任务调度定时拉取任务">4.2 任务调度：定时拉取任务</h2>
<p>在worker的主线程中阻塞，执行任务调度。根据任务配置表中的<code>cfg.ScheduleInterval</code>时间开启定时器定时拉取一批任务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cfg, ok := scheduleCfgDic[p.TaskType]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">	martlog.Errorf(<span class="string">&quot;scheduleCfgDic %s, not have taskType %s&quot;</span>, tools.GetFmtStr(scheduleCfgDic), p.TaskType)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">intervalTime := time.Second * time.Duration(cfg.ScheduleInterval)</span><br><span class="line"><span class="keyword">if</span> cfg.ScheduleInterval == <span class="number">0</span> &#123;</span><br><span class="line">	intervalTime = time.Second * DEFAULT_TIME_INTERVAL</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前后波动500ms[0,501)</span></span><br><span class="line">step := RandNum(<span class="number">501</span>)</span><br><span class="line"><span class="comment">// 加上波动的时间</span></span><br><span class="line">intervalTime += time.Duration(step) * time.Millisecond</span><br><span class="line">t := time.NewTimer(intervalTime)</span><br><span class="line">&lt;-t.C</span><br></pre></td></tr></table></figure>
<p>每到定时时间拉取一批任务时开启一个新的goroutine，并在新开启的goroutine中，假设拿到一批数量为<code>n</code>的任务，遍历这<code>n</code>个任务，每个任务开启一个goroutine执行。</p>
<h2 id="任务调度分布式锁">4.3 任务调度：分布式锁</h2>
<p>其中，在每次拉取一批新任务时先通过<strong>阻塞模式redis抢锁</strong>，通过
Redis
的<strong>LUA原子操作</strong>实现跨进程/跨机器的互斥访问。5s内抢不到锁则返回等待下一次拉取任务。持有锁的过期时间为3s。</p>
<p>其中redis的分布式锁连接地址在配置文件中配置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻塞模式，如果没有抢到锁，就会阻塞直到抢锁成功（默认阻塞最长时间为5秒）</span></span><br><span class="line">mutex := redislock.NewRedisLock(p.TaskType, lockClient, redislock.WithBlock(), redislock.WithWatchDogMode(), redislock.WithExpireSeconds(<span class="number">3</span>))</span><br><span class="line"><span class="keyword">if</span> err := mutex.Lock(context.Background()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	martlog.Errorf(<span class="string">&quot;RedisLock lock err %s&quot;</span>, err.Error())</span><br><span class="line">	<span class="keyword">return</span> <span class="comment">// 没有抢到锁，直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>redislock.NewRedisLock</code>处理完创建锁的操作后，会在<code>redislock.Lock</code>中调用<code>redislock.WatchDog</code>函数通过延时函数在抢占到分布式锁后开启<strong>看门狗</strong>机制，启动一个后台
goroutine 来定期续期锁的有效期。</p>
<p>redis加锁是通过<code>SETNX</code>命令结合<strong>看门狗机制</strong>手动实现一个<strong>分布式锁</strong>的，<code>SETNX</code>命令是一个原子性的操作，只有在key不存在时才会设置key的值，如果key已经存在，则不做任何操作。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lock 加锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisLock)</span> <span class="title">Lock</span><span class="params">(ctx context.Context)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 加锁成功的情况下，会启动看门狗</span></span><br><span class="line">		<span class="comment">// 关于该锁本身是不可重入的，所以不会出现同一把锁下看门狗重复启动的情况</span></span><br><span class="line">		r.watchDog(ctx)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不管是不是阻塞模式，都要先获取一次锁</span></span><br><span class="line">	err = r.tryLock(ctx)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 加锁成功</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非阻塞模式加锁失败直接返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !r.isBlock &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断错误是否可以允许重试，不可允许的类型则直接返回错误</span></span><br><span class="line">	<span class="keyword">if</span> !IsRetryableErr(err) &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基于阻塞模式持续轮询取锁</span></span><br><span class="line">	err = r.blockingLock(ctx)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试通过 SETNX 命令获取锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisLock)</span> <span class="title">tryLock</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 首先查询锁是否属于自己</span></span><br><span class="line">	result, err := r.client.pool.SetNX(ctx, r.key, r.token, time.Duration(r.expireTimeSecond)*time.Second).Result()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 加锁失败，已经有锁</span></span><br><span class="line">	<span class="keyword">if</span> !result &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrLockAcquiredByOthers</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动看门狗</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisLock)</span> <span class="title">watchDog</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1. 非看门狗模式，不处理</span></span><br><span class="line">	<span class="keyword">if</span> !r.watchDogMode &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 确保之前启动的看门狗已经正常回收</span></span><br><span class="line">	<span class="keyword">for</span> !atomic.CompareAndSwapInt32(&amp;r.runningDog, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 启动看门狗</span></span><br><span class="line">	ctx, r.stopDog = context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			atomic.StoreInt32(&amp;r.runningDog, <span class="number">0</span>)</span><br><span class="line">		&#125;()</span><br><span class="line">		r.runWatchDog(ctx)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runWatchDog 看门狗运作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisLock)</span> <span class="title">runWatchDog</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(r.watchDogWorkStepTime)</span><br><span class="line">	<span class="keyword">defer</span> ticker.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 看门狗负责在用户未显式解锁时，持续为分布式锁进行续期</span></span><br><span class="line">		<span class="comment">// 通过 lua 脚本，延期之前会确保保证锁仍然属于自己</span></span><br><span class="line">		_ = r.DelayExpire(ctx, r.expireTimeSecond)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新锁的过期时间，基于 lua 脚本实现操作原子性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RedisLock)</span> <span class="title">DelayExpire</span><span class="params">(ctx context.Context, expireSeconds <span class="keyword">int64</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	result, err := r.client.pool.Eval(ctx, LuaCheckAndExpireDistributionLock, []<span class="keyword">string</span>&#123;r.key&#125;, []<span class="keyword">interface</span>&#123;&#125;&#123;r.token, expireSeconds&#125;).Bool()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !result &#123;</span><br><span class="line">		<span class="keyword">return</span> ErrDelayExpire</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务调度任务执行">4.3 任务调度：任务执行</h2>
<p>在每个任务的goroutine中，执行任务的过程中，需要<strong>先加载上下文<code>ContextLoad</code>，然后执行任务<code>HandleProcess</code>，任务执行完后，根据任务执行结果调用<code>SetTask</code>接口更新任务状态</strong>。</p>
<p>当任务执行完<code>HandleProcess</code>后需要重置<strong>任务阶段和任务状态</strong>，并更新task结构体中的<code>schedule_log</code>(这里包括记录track-uuid时间戳、ErrMsg和cost任务执行时间)</p>
<p>最后再更新当前任务的排序时间<code>order_time</code>:</p>
<ul>
<li><strong>任务执行成功</strong>：<code>order_time = modify_time - priority</code>
<ul>
<li>说明：根据优先级<strong>提前任务调度时间</strong></li>
</ul></li>
<li><strong>任务执行失败</strong>：<code>order_time = modify_time + retry_interval</code>
<ul>
<li>说明：根据<strong>重试时间</strong>延迟任务被调度时间</li>
<li>这里不能加上priority，否则无法保证<strong>重试时间间隔retry_interval内</strong>不会被调度</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Asyncflow</category>
      </categories>
  </entry>
  <entry>
    <title>C++基础知识学习</title>
    <url>/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一指针">一、指针</h2>
<h3 id="c的双指针">1.1 C++的双指针</h3>
<p>C++的双指针是指一个指针<strong>指向另一个指针的指针</strong>，如<code>int **p</code>，其指向的是一个指针的地址，也就是说，<code>p=某个指针的地址</code>，<code>*p=这个指针指向的地址</code>，而<code>p</code>本身也是一个int类型的数据</p>
<p>简单的例子如下：</p>
<p><code>int a = 10;</code></p>
<p><code>int *p = &amp;a;</code>
//<code>p</code>指向a的地址<code>&amp;a</code>,
<code>*p</code>指向<code>a的值</code>，这是一级指针，它的值是内存中存放变量a的地址</p>
<p><code>int **pp = &amp;p;</code>
//<code>pp</code>指向<code>p</code>的地址<code>&amp;p</code>，<code>*pp</code>指向<code>p</code>的值，即<code>&amp;a</code>，这是二级指针，它的值是内存中<strong>存放变量p的地址</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> aa = <span class="number">4</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">singlePointer</span><span class="params">(<span class="keyword">int</span> *p1)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----singlePointer-----&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;p1=&quot;</span> &lt;&lt; &amp;p1 &lt;&lt; <span class="string">&quot;  函数中的p是重新创建的指针&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1=&quot;</span> &lt;&lt; p1  &lt;&lt; <span class="string">&quot;     传进来的是原先a的地址&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*p1 = <span class="number">5</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----singlePointer END-----&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doublePointer</span><span class="params">(<span class="keyword">int</span> **p2)</span></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----doublePointer-----&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;p2=&quot;</span> &lt;&lt; &amp;p2 &lt;&lt; <span class="string">&quot;  函数中的p是重新创建的指针&quot;</span>  &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p2=&quot;</span> &lt;&lt; p2 &lt;&lt; <span class="string">&quot;     传进来的是原先p的地址&quot;</span> &lt;&lt; endl;</span><br><span class="line">	*p2 = &amp;aa;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;-----doublePointer-----END&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">   	<span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt;  <span class="string">&quot; | &quot;</span>&lt;&lt; <span class="string">&quot;&amp;p=&quot;</span>&lt;&lt; &amp;p &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt;  <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot; | &quot;</span> &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">singlePointer</span>(p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;&amp;a=&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">doublePointer</span>(&amp;p);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p=&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;*p=&quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果：</li>
</ul>
<p><img src="/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/doublePointer.png" width="60%"></p>
<ul>
<li>原因：
<ul>
<li>p本身也是一个int型变量，只是存的值是地址；对所存地址进行*p解引用就可以实现取值；</li>
<li>单指针函数的话传的是p，所以其实传进去的是a的地址，然后该地址赋值给新的指针p1，所以已经没有原先p指针的信息了，无法实现修改原先p指针的指向对象，只能改变a的值；</li>
<li>双指针传的是&amp;p，也就是p的地址，所以该地址赋值给新的指针p2，可以实现修改原先p的指向对象</li>
</ul></li>
</ul>
<h3 id="指针和引用的区别">1.2 指针和引用的区别</h3>
<ul>
<li><strong>指针</strong>是一个<strong>变量</strong>，它存储的是一个<strong>地址</strong>；而<strong>引用</strong>是一个<strong>别名</strong>，它是一个<strong>常量</strong>，它本质上跟被引用的变量是同一个东西。</li>
<li>指针有多级而引用只有一级；指针可以指向空，而引用不行；通过指针传参时会重新拷贝到另一个指针中，而引用会直接传实参</li>
<li>sizeof时，指针占用的空间是固定的(8bytes)，而引用占用的空间是被引用变量的大小；</li>
</ul>
<p>指针和引用的使用方式不同：</p>
<ul>
<li><strong>指针</strong>：<code>int *p = &amp;a;</code>
<ul>
<li>通过赋值变量<code>a</code>的地址给指针<code>p</code></li>
<li>通过<code>*p</code>来<strong>解引用</strong>访问<code>a</code>的值</li>
<li>非<strong>指针常量</strong>的话，指针变量可以<strong>重新赋值</strong>改变指向的地址，即<code>p = &amp;b;</code></li>
</ul></li>
<li><strong>引用</strong>：<code>int &amp;r = a;</code>
<ul>
<li>通过<code>&amp;</code>符号来<strong>取地址</strong>，然后赋值给引用<code>r</code></li>
<li>直接通过<code>r</code>来访问<code>a</code>的值</li>
<li>引用<strong>不可以重新赋值</strong>，即<code>r = b;</code>是不允许的，所以<strong>引用必须在定义时初始化</strong></li>
</ul></li>
</ul>
<p>什么时候用指针，什么时候用引用？</p>
<ul>
<li>使用引用：当需要减少拷贝时；当传递<strong>类对象</strong>时标准方式是使用引用</li>
<li>使用指针：当传入<strong>基础类型的数组时使用指针</strong>；当需要在函数中改变指向的对象时；当需要返回函数内局部变量的内存地址时</li>
</ul>
<p>代码举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printTest</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;This is : &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Test m_test;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//指针</span></span><br><span class="line">	Test* m_ptr   = &amp;m_test;</span><br><span class="line">	m_ptr-&gt;<span class="built_in">printTest</span>(<span class="string">&quot;指针&quot;</span>);</span><br><span class="line">	<span class="comment">//引用</span></span><br><span class="line">	Test&amp; m_quote = m_test;</span><br><span class="line">	m_quote.<span class="built_in">printTest</span>(<span class="string">&quot;引用&quot;</span>);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;调试用&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="野指针和悬空指针">1.3 野指针和悬空指针</h3>
<p><strong>野指针</strong></p>
<p>指尚未初始化的指针，既不指向合法的内存空间，也没有使用 NULL/nullptr
初始化指针。</p>
<p>出现野指针举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;<span class="comment">//未初始化,野指针</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">NULL</span>;<span class="comment">//初始化为NULL,不是野指针</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="literal">nullptr</span>;<span class="comment">//初始化为nullptr,p不再是不是野指针</span></span><br></pre></td></tr></table></figure>
<p><strong>悬空指针</strong></p>
<p>指向<strong>已经释放</strong>的内存地址的指针（释放前是合法的指针）</p>
<p>出现悬空指针的原因主要有三种：</p>
<ul>
<li>指针释放资源后<strong>没有被重新赋值</strong> OR
指针释放后<strong>没有置为</strong><code>nullptr</code>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="comment">//p没有被重新赋值或者置为nullptr</span></span><br></pre></td></tr></table></figure></li>
<li>超出变量作用域 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    p = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a是局部变量，超出作用域，p成为悬空指针</span></span><br></pre></td></tr></table></figure></li>
<li>指向函数返回的<strong>局部变量的指针</strong>或者<strong>引用</strong>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *p = <span class="built_in">fun</span>();</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> &amp;p = <span class="built_in">fun</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<p>上述提到的<strong>野指针</strong>和<strong>悬空指针</strong>都是<strong>危险</strong>的，因为它们可能会<strong>访问到非法内存</strong>，导致程序崩溃。</p>
<h3 id="智能指针">1.4 智能指针</h3>
<h4 id="内存溢出-out-of-memory">1.4.1 内存溢出 Out of Memory</h4>
<p>内存溢出是指<strong>程序申请的内存超过了系统能提供的内存</strong>，导致<strong>程序崩溃</strong>。</p>
<p>内存溢出的原因主要是因为<strong>申请内存过大</strong>：程序申请的内存超过了系统能提供的内存</p>
<ul>
<li>比如，程序申请了一个很大的数组，但是系统内存不足，导致内存溢出</li>
<li>再比如，申请了一个<code>int</code>变量，但是实际给它赋值了一个很大的数（如long才能存下的数），导致内存溢出</li>
<li><strong>内存泄漏最终会导致内存溢出</strong></li>
</ul>
<h4 id="内存泄漏-memory-leak">1.4.2 内存泄漏 Memory Leak</h4>
<p>内存泄漏是指<strong>程序分配了一块内存空间</strong>，但<strong>由于某种原因</strong>，<strong>程序没有释放</strong>或者<strong>无法释放</strong>这块内存空间，导致<strong>这块内存空间永远无法被使用</strong>，这就是内存泄漏。</p>
<p>内存泄漏的原因主要有两种：</p>
<ul>
<li><strong>堆内存泄漏</strong>：程序在堆上分配了内存，但是<strong>没有释放</strong>，导致内存泄漏。通常是因为<strong>程序员使用<code>new</code>或者<code>malloc</code>分配内存，但是忘记使用<code>delete</code>或者<code>free</code>释放内存</strong>。</li>
<li><strong>资源泄漏</strong>：程序在使用资源时，<strong>没有释放</strong>，导致资源泄漏。比如<strong>打开文件</strong>、<strong>打开数据库连接</strong>等，但是<strong>没有关闭</strong>，久而久之会导致其它程序无法使用它。</li>
</ul>
<p><strong>如何避免内存泄漏</strong>：</p>
<ul>
<li>首先是记得及时释放，一般会在<strong>析构函数</strong>中释放内存类的资源（但是如果类的对象也是用<code>new</code>分配的内存，那么还是要手动释放对象才能调用析构函数）</li>
<li>其次是使用<strong>智能指针</strong>，实现自动管理内存。（智能指针过期后会自动调用析构函数，释放内存）</li>
<li>可以使用<strong>RAII</strong>（资源获取即初始化，智能指针就是采用的RAII实现的资源管理）技术，即在<strong>构造函数</strong>中申请资源，在<strong>析构函数</strong>中释放资源，这样可以保证资源的及时释放。</li>
<li>用工具检查内存泄漏，如<code>BoundsChecker</code>、<code>Valgrind</code>等</li>
<li>调用DEBUG版程序的<code>CRT</code>堆栈提示分析泄漏原因</li>
</ul>
<p>题外话说一下<strong>缓冲区</strong>溢出：缓冲区溢出是指如<code>vector</code>、<code>string</code>等这种带索引的容器，当<strong>索引超出容器的范围</strong>时，会导致<strong>程序崩溃</strong>。</p>
<h4 id="智能指针-1">1.4.3 智能指针</h4>
<p>智能指针是C++11引入的一种<strong>内存管理</strong>方式，它是一个<strong>类模板</strong>，可以自动管理内存，<strong>避免内存泄漏</strong>。智能指针在<code>&lt;memory&gt;</code>头文件中。</p>
<p>智能指针的主要作用是解放程序员，实现<strong>自动释放内存</strong>，当智能指针<strong>超出作用域</strong>时，会自动调用析构函数，释放内存。</p>
<p>常用的智能指针有<code>unique_ptr</code>、<code>shared_ptr</code>和<code>weak_ptr</code>是C++11标准，而<code>auto_ptr</code>是C++98标准，已经被C++17废弃。</p>
<h5 id="unique_ptr">1.4.3.1 unique_ptr</h5>
<p>通常一块内存可以被多个普通指针指向，但是<code>unique_ptr</code>是<strong>独占</strong>的，即<strong>一块内存只能有一个<code>unique_ptr</code>指向它</strong>。</p>
<p>首先来产生用<code>unique_ptr</code>管理普通的指针，实现没有<code>delete</code>也能自动释放普通指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestSmartPtr</span>(string m_name) :<span class="built_in">m_name</span>(m_name) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">TestSmartPtr</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">TestSmartPtr</span>(<span class="keyword">const</span> TestSmartPtr&amp; other):<span class="built_in">m_name</span>(other.m_name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//使用智能指针管理普通指针：实现程序结束自动调用析构函数</span></span><br><span class="line">	TestSmartPtr* p = <span class="keyword">new</span> <span class="built_in">TestSmartPtr</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">	<span class="function">unique_ptr&lt;TestSmartPtr&gt; <span class="title">uni_ptr</span><span class="params">(p)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用了Test的构造函数</span><br><span class="line">调用了Test的析构函数</span><br></pre></td></tr></table></figure>
<p>但实际上，有了智能指针之后，我们很少再使用普通指针了，所以我们一般是直接在构造函数中<code>new</code>一个对象，或者使用<code>make_unique</code>函数来创建对象。因此初始化时主要有三种方法：</p>
<ul>
<li><code>unique_ptr&lt;TestSmartPtr&gt; uni_ptr(new TestSmartPtr("Test"));</code></li>
<li><code>unique_ptr&lt;TestSmartPtr&gt; uni_ptr = make_unique&lt;TestSmartPtr&gt;("Test");</code>
<ul>
<li><code>auto uni_ptr = make_unique&lt;TestSmartPtr&gt;("Test");</code></li>
</ul></li>
<li><code>unique_ptr&lt;TestSmartPtr&gt; uni_ptr(p);</code>不建议使用这种方式，会暴露原始指针</li>
</ul>
<p><strong><code>unique_ptr</code>怎么保证独占？</strong></p>
<p><code>unique_ptr</code>是通过在其模板类的定义中<strong>禁止拷贝构造函数</strong>和<strong>赋值运算符</strong>来保证独占的。</p>
<ul>
<li><p>禁止拷贝构造函数：<code>unique_ptr(const unique_ptr&amp;) = delete;</code></p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;TestSmartPtr&gt; <span class="title">uni_ptr1</span><span class="params">(<span class="keyword">new</span> TestSmartPtr(<span class="string">&quot;Test1&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;TestSmartPtr&gt; uni_ptr2 = uni_ptr1; <span class="comment">//赋值，编译报错</span></span><br><span class="line"><span class="function">unique_ptr&lt;TestSmartPtr&gt; <span class="title">uni_ptr3</span><span class="params">(uni_ptr1)</span></span>; <span class="comment">//拷贝，编译报错</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>禁止赋值运算符：<code>unique_ptr&amp; operator=(const unique_ptr&amp;) = delete;</code></p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;TestSmartPtr&gt; <span class="title">uni_ptr1</span><span class="params">(<span class="keyword">new</span> TestSmartPtr(<span class="string">&quot;Test1&quot;</span>))</span></span>;</span><br><span class="line"><span class="function">unique_ptr&lt;TestSmartPtr&gt; <span class="title">uni_ptr2</span><span class="params">(<span class="keyword">new</span> TestSmartPtr(<span class="string">&quot;Test2&quot;</span>))</span></span>;</span><br><span class="line">uni_ptr2 = uni_ptr1; <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p><strong>为什么需要保证<code>unique_ptr</code>的独占？</strong></p>
<p>如果不独占的话，当我们用多个智能指针指向同一个对象时，当多个智能指针过期时会<strong>调用多次析构函数</strong>，这样除了第一次调用析构函数是正常的，其它的调用都是对<strong>野指针</strong>的操作，会导致程序崩溃。</p>
<h5 id="shared_ptr">1.4.3.2 shared_ptr</h5>
<p><code>shared_ptr</code>是<strong>共享</strong>的智能指针，它可以<strong>多个<code>shared_ptr</code>指向（关联）同一个对象</strong>，在内部采用<strong>引用计数</strong>来实现共享管理：</p>
<ul>
<li>当有一个<code>shared_ptr</code>与对象关联时，引用计数加1（内部的引用计数是线程安全的）</li>
<li>当最后一个<code>shared_ptr</code>超出作用域时，表示没有任何与其关联的对象了，才会调用析构函数（其它情况的超出作用域只会将引用计数值减1）。此时<code>shared_ptr</code>自动变为<code>nullptr</code>，防止出现悬空指针。</li>
</ul>
<p>相比于<code>unique_ptr</code>，<code>shared_ptr</code>的<strong>拷贝构造函数</strong>和<strong>赋值运算符</strong>是<strong>允许</strong>的，同时还多了一个<code>use_count</code>函数，用来获取当前引用计数的值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestSmartPtr</span>(string m_name) :<span class="built_in">m_name</span>(m_name) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">TestSmartPtr</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">TestSmartPtr</span>(<span class="keyword">const</span> TestSmartPtr&amp; other):<span class="built_in">m_name</span>(other.m_name)&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot;的拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> m_name;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	shared_ptr&lt;TestSmartPtr&gt; p0 = make_shared&lt;TestSmartPtr&gt;(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p0初始引用计数值：&quot;</span> &lt;&lt; p0.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//采用拷贝构造函数增加p1对对象的引用</span></span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr&gt; <span class="title">p1</span><span class="params">(p0)</span></span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p0当前的引用计数值：&quot;</span> &lt;&lt; p0.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p0的user_name：&quot;</span> &lt;&lt; p0-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1初始引用计数值：&quot;</span> &lt;&lt; p0.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1的user_name：&quot;</span> &lt;&lt; p1-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用了Test的构造函数</span><br><span class="line">p0初始引用计数值：1</span><br><span class="line">p0当前的引用计数值：2</span><br><span class="line">p0的user_name：Test</span><br><span class="line">p1初始引用计数值：2</span><br><span class="line">p1的user_name：Test</span><br><span class="line">调用了Test的析构函数</span><br></pre></td></tr></table></figure>
<p>在使用左右值引用时，<strong>左值</strong>的引用计数会<strong>减1</strong>，<strong>右值</strong>的引用计数会加1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	shared_ptr&lt;TestSmartPtr&gt; p0 = make_shared&lt;TestSmartPtr&gt;(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">	shared_ptr&lt;TestSmartPtr&gt; p1 = make_shared&lt;TestSmartPtr&gt;(<span class="string">&quot;Test2&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//采用赋值方法</span></span><br><span class="line">	shared_ptr&lt;TestSmartPtr&gt; p2 = p0;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p0当前的引用计数值：&quot;</span> &lt;&lt; p0.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1当前的引用计数值：&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;---修改p3的引用赋值对象---&quot;</span> &lt;&lt; endl;</span><br><span class="line">	p2 = p1;<span class="comment">//左值：原始p2指向的p0计数值减一；右值：当前指向的p1引用计数值加一</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p0当前的引用计数值：&quot;</span> &lt;&lt; p0.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;p1初始引用计数值：&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用了Test的构造函数</span><br><span class="line">调用了Test2的构造函数</span><br><span class="line">p0当前的引用计数值：2</span><br><span class="line">p1当前的引用计数值：1</span><br><span class="line">---修改p3的引用赋值对象---</span><br><span class="line">p0当前的引用计数值：1</span><br><span class="line">p1初始引用计数值：2</span><br><span class="line">调用了Test2的析构函数</span><br><span class="line">调用了Test的析构函数</span><br></pre></td></tr></table></figure>
<p><strong>用unique_ptr好，还是shared_ptr好？</strong></p>
<p>一般情况下，能用<code>unique_ptr</code>就用<code>unique_ptr</code>，因为<code>unique_ptr</code>的<strong>效率更高</strong>，而且<strong>更安全</strong>。</p>
<p>而如果有需要<strong>共享</strong>的情况，那么就用<code>shared_ptr</code>。</p>
<p><strong>给unique_ptr和shared_ptr自定义删除器</strong></p>
<p>三种自定义删除器的方式：普通函数、仿函数、lambda表达式</p>
<ul>
<li><p><strong>普通函数</strong></p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteFunc</span><span class="params">(TestSmartPtr* t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用普通函数方式自定义删除器（全局函数）\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>仿函数</strong></p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deleteClass</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(TestSmartPtr* t)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;使用仿函数的方式自定义删除器\n&quot;</span>;</span><br><span class="line">        <span class="keyword">delete</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>lambda表达式</strong></p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> deleteLamb = [](TestSmartPtr* t) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;使用Lambda表达式的方式自定义删除器\n&quot;</span>;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>给<code>unique_ptr</code>和<code>shared_ptr</code>添加自定义删除器并进行测试：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//给shared_ptr自定义删除器</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;------------给shared_ptr自定义删除器---------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr&gt; <span class="title">p0</span><span class="params">(<span class="keyword">new</span> TestSmartPtr(<span class="string">&quot;Test&quot;</span>), deleteFunc)</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> TestSmartPtr(<span class="string">&quot;Test2&quot;</span>), deleteClass())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> TestSmartPtr(<span class="string">&quot;Test3&quot;</span>), deleteLamb)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">////给unique_ptr自定义删除器</span></span><br><span class="line">	<span class="comment">//cout &lt;&lt; &quot;------------给unique_ptr自定义删除器---------------&quot; &lt;&lt; endl;</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;TestSmartPtr, decltype(deleteFunc)*&gt; p4(new TestSmartPtr(&quot;Test decltype&quot;), deleteFunc);</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;TestSmartPtr, void(*)(TestSmartPtr *)&gt; p5(new TestSmartPtr(&quot;Test 函数指针&quot;), deleteFunc);</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;TestSmartPtr, deleteClass&gt; p6(new TestSmartPtr(&quot;Test 仿函数&quot;), deleteClass());</span></span><br><span class="line">	<span class="comment">//unique_ptr&lt;TestSmartPtr, decltype(deleteLamb)&gt; p7(new TestSmartPtr(&quot;Test Lambda&quot;), deleteLamb);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="weak_ptr">1.4.3.3 weak_ptr</h5>
<p><code>weak_ptr</code>是<code>shared_ptr</code>的<strong>弱引用</strong>，是为了解决<code>shared_ptr</code>的<strong>循环引用</strong>问题。它不控制对象的生命周期，但是可以判断对象是否存在。</p>
<p>由于<code>weak_ptr</code>只做引用不做计数，所以当指向的对象被释放时，<code>weak_ptr</code>是不知道的，因此需要用<code>lock</code>函数将<code>weak_ptr</code>提升为<code>shared_ptr</code>，这样就可以判断对象是否存在。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;TestSmartPtr&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> TestSmartPtr(<span class="string">&quot;Test&quot;</span>))</span></span>;</span><br><span class="line">    weak_ptr&lt;TestSmartPtr&gt; p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p2.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;对象还存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;对象已经过期&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当两个<code>shared_ptr</code>相互引用时，会导致<strong>引用计数永远不为0</strong>。如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSmartPtr2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSmartPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestSmartPtr</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; <span class="string">&quot;第一个类&quot;</span> &lt;&lt; <span class="string">&quot;的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">TestSmartPtr</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; <span class="string">&quot;第一个类&quot;</span> &lt;&lt; <span class="string">&quot;的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//weak_ptr&lt;TestSmartPtr2&gt; m_p;//引用TestSmartPtr2</span></span><br><span class="line">	shared_ptr&lt;TestSmartPtr2&gt; m_p;<span class="comment">//引用TestSmartPtr2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestSmartPtr2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TestSmartPtr2</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; <span class="string">&quot;第二个类&quot;</span> &lt;&lt; <span class="string">&quot;的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">TestSmartPtr2</span>() &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调用了&quot;</span> &lt;&lt; <span class="string">&quot;第二个类&quot;</span> &lt;&lt; <span class="string">&quot;的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//weak_ptr&lt;TestSmartPtr&gt; m_p;//引用TestSmartPtr</span></span><br><span class="line">	shared_ptr&lt;TestSmartPtr&gt; m_p;<span class="comment">//引用TestSmartPtr</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> TestSmartPtr())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr2&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> TestSmartPtr2())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行循环引用</span></span><br><span class="line">	p1-&gt;m_p = p2;</span><br><span class="line">	p2-&gt;m_p = p1;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：没有调用两个类的析构函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用了第一个类的构造函数</span><br><span class="line">调用了第二个类的构造函数</span><br></pre></td></tr></table></figure>
<p><strong>解决方法</strong>：</p>
<ul>
<li>将两个类中的<code>shared_ptr</code>改为<code>weak_ptr</code></li>
<li>在需要使用时通过<code>expired</code>函数判断是否过期（线程不安全）</li>
<li><code>weak_ptr</code><strong>不能直接访问资源、不控制对象生命周期</strong>，但是可以通过<code>lock</code>函数提升为<code>shared_ptr</code>，该函数同时也可以判断是否过期。（线程安全的）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> TestSmartPtr())</span></span>;</span><br><span class="line">	<span class="function">shared_ptr&lt;TestSmartPtr2&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> TestSmartPtr2())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//进行循环引用</span></span><br><span class="line">	p1-&gt;m_p = p2;</span><br><span class="line">	p2-&gt;m_p = p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//.lock()将weak_ptr提升为shared_ptr</span></span><br><span class="line">	<span class="keyword">if</span> (p1-&gt;m_p.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;对象1还存在，use_count：&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;对象1已经过期&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (p2-&gt;m_p.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;对象2还存在，use_count：&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;对象2已经过期&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用了第一个类的构造函数</span><br><span class="line">调用了第二个类的构造函数</span><br><span class="line">对象1还存在，use_count：1</span><br><span class="line">对象2还存在，use_count：1</span><br><span class="line">调用了第二个类的析构函数</span><br><span class="line">调用了第一个类的析构函数</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/adam2021/article/details/129849022">循环引用产生的原因和解决方法</a></p>
</blockquote>
<h3 id="this指针">1.5 this指针</h3>
<p><code>this</code>指针是一个<strong>隐式</strong>的指向<strong>当前对象首地址</strong>的<strong>指针</strong>。<strong>this指针只有在对象中的成员函数中才有定义</strong>，因此，你获得一个对象后，也不能通过对象使用此指针。（只能在类内部使用，且<strong>静态成员函数</strong>不能使用）</p>
<p><strong>静态成员函数</strong>与一般成员函数的唯一区别就是<strong>没有this指针</strong>，因此<strong>不能访问非静态数据成员</strong>。this指针不能访问<strong>全局函数和静态函数</strong>。而编译器会给普通成员函数隐式传参传入this指针（所以成员函数的作用周期就是this的作用周期）</p>
<p>由于成员函数是在代码区的，所以this指针隐式传入成员函数的作用就是让成员函数直到是那个实例化对象在调用该函数。所以<code>delete this</code>的话会释放掉该实例化对象的内存空间。而由于<code>delete this</code>本身就是释放内存会调用<strong>析构函数</strong>，所以如果在析构函数中调用<code>delete this</code>会导致<strong>无限递归调用析构</strong>，最终<strong>堆栈溢出</strong>从而导致<strong>程序崩溃</strong>。</p>
<p>要注意，<code>this</code>指针是<strong>常量指针</strong>，不能被赋值，也不能被删除。</p>
<ul>
<li>它会在<strong>构造函数</strong>和<strong>析构函数</strong>中<strong>自动</strong>被<strong>创建</strong>和<strong>销毁</strong>。</li>
<li>如果在<strong>析构函数</strong>中<strong>显式</strong>删除<code>this</code>指针，由于<code>delete this</code>的操作本身就会<strong>调用析构函数</strong>，所以会导致<strong>无限递归调用析构</strong>，最终<strong>堆栈溢出</strong>从而导致<strong>程序崩溃</strong>。</li>
</ul>
<p>this指针存在<strong>栈</strong>或者<strong>全局区</strong>或者<strong>寄存器</strong>中。标准情况下this为<strong>右值</strong>，不能通过取地址符号返回this指针的地址，但是可以返回this指针指向的地址。</p>
<h3 id="new和delete">1.6 new和delete</h3>
<h4 id="实现机制">1.6.1 实现机制</h4>
<p>new和delete是C++中用来<strong>动态分配</strong>和<strong>释放</strong>内存的运算符。</p>
<ul>
<li>new：首先执行标准库函数<code>operator new</code>分配内存 -&gt;
然后调用<strong>构造函数</strong>初始化对象 -&gt;
最后返回对象的指针（如果内存分配失败，会抛出<code>std::bad_alloc</code>异常）</li>
<li>delete：首先调用<strong>析构函数</strong> -&gt;
然后执行标准库函数<code>operator delete</code>释放内存</li>
</ul>
<h4 id="new和malloc的区别">1.6.2 new和malloc的区别</h4>
<p>new底层是通过malloc实现的，所以理论上是可以直接free掉new出来的实例化对象，但是这样的话不会调用实例化对象的析构函数</p>
<ul>
<li>new是C++运算符，malloc是C标准库函数</li>
<li>内存分配：new是自动计算大小的，malloc是需要手动输入分配的内存大小；new使用<code>operator new</code>分配内存</li>
<li>内存分配失败：new分配失败时会抛出异常报错，而malloc会直接返回空指针</li>
<li>初始化和释放：new初始化会调用构造函数、delete时会调用析构函数再释放，而malloc会直接释放内存</li>
<li>数据类型检查：new会有数据类型检查，而malloc直接申请一块内存，需要做类型强制转换，也不进行类型安全性检查</li>
</ul>
<h3 id="辨别几种指针的区别">1.7 辨别几种指针的区别</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">p</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>指针数组</strong>：存放多个指针的数组<code>int *p[10]</code></li>
<li><strong>数组指针</strong>：某个普通数组的指针，如<code>int (*p)[10]</code>表示一个int型数组的地址</li>
<li><strong>函数返回指针</strong>：<code>int * p(int)</code>表示函数返回一个int型的指针，传参为int</li>
<li><strong>函数指针</strong>：<code>int (*p)(int)</code>其中<code>p</code>表示某个函数的指针，返回值是int，传参是int</li>
</ul>
<h2 id="二多态">二、多态</h2>
<p>C++的多态有两种：<strong>静态多态</strong>和<strong>动态多态</strong>。</p>
<p>其中，<strong>静态多态</strong>是通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现的，而<strong>动态多态</strong>是通过<strong>虚函数</strong>实现的。</p>
<p>除此以外，C++还有<strong>模板多态</strong>，即通过<strong>模板</strong>实现的多态。（CRTP）</p>
<h3 id="动态多态">2.1 动态多态：</h3>
<p>C++的动态多态是通过父类定义<strong>虚函数</strong>实现和子类<strong>重写</strong>来实现。</p>
<ul>
<li>基类定义至少一个虚函数，此时该基类就会在<strong>编译</strong>时确定一个静态数组（也就是虚函数表），里面存放了所有虚函数的地址，每个类的所有类对象共享这个虚函数表。
<ul>
<li>其中，对于<strong>普通虚函数</strong>，父类可以选择声明实现or不实现虚函数</li>
<li>但是如果是<strong>纯虚函数</strong>，那么<strong>父类不能实现</strong>具体函数，只能由子类实现，且此时父类为抽象类，<strong>不能实例化</strong>。如果子类没有实现纯虚函数，那么子类也是抽象类，不能实例化。</li>
</ul></li>
</ul>
<p>接下来来具体从<strong>虚函数</strong>、<strong>虚函数表</strong>、<strong>虚函数指针</strong>这几个方面来进行讲解。</p>
<h4 id="虚函数">2.1.1 虚函数</h4>
<p>虚函数是在<strong>基类</strong>中使用<code>virtual</code>关键字声明的函数。在基类中声明虚函数后，派生类可以<strong>覆盖（重写）</strong>该函数，实现<strong>多态</strong>。<strong>虚函数</strong>在内存中存储于<strong>代码区</strong>，而<strong>虚函数表</strong>存储于<strong>常量区</strong></p>
<ul>
<li><strong>虚函数表</strong>：每个带有虚函数的<strong>类</strong>都有一个虚函数表</li>
<li><strong>虚函数指针</strong>：每个<strong>实例化对象</strong>都有一个虚函数8bytes的指针，指向虚函数表</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base fun1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base fun2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如上述代码，<code>fun</code>用<code>virtual</code>关键字声明，那么<code>fun</code>就是一个虚函数。结合下文将说到的<strong>虚函数指针</strong>，<strong>没有声明虚函数</strong>的类根本<strong>不会有虚表指针</strong>，也不支持多态（动态）。</p>
<h4 id="虚函数表vtbl">2.1.2 虚函数表vtbl</h4>
<p>虚函数表中存储了该类所有的<strong>虚函数</strong>的地址。一个类的所有对象共享一个虚函数表，这个表是在<strong>编译</strong>时就已经生成的。</p>
<p>如果有一个<code>Base</code>类，其中有一个虚函数<code>fun</code>，那么它的虚函数表中就会存储<code>fun</code>的地址。</p>
<table>
<thead>
<tr>
<th style="text-align: center;">Base中的函数</th>
<th style="text-align: center;">虚函数表地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">fun1</td>
<td style="text-align: center;">0x00f21569</td>
</tr>
<tr>
<td style="text-align: center;">fun2</td>
<td style="text-align: center;">0x00f21596</td>
</tr>
<tr>
<td style="text-align: center;">虚析构</td>
<td style="text-align: center;">0x00f21573</td>
</tr>
</tbody>
</table>
<p>虚函数表是在<strong>编译</strong>时确定的，且每个类的所有对象共享一个虚函数表。</p>
<h4 id="虚函数指针vptr">2.1.3 虚函数指针vptr</h4>
<p>虚函数指针是实例化对象中<strong>指向虚函数表的地址</strong>的指针。<strong>含有虚函数</strong>的类的对象或者<strong>继承了含有虚函数的类</strong>的对象都会有一个虚函数指针。</p>
<p><img src="/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/vptr.jpg"></p>
<ul>
<li><p>普通类：无虚函数，无虚函数表</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如上面的代码，<code>Base</code>类中没有虚函数，所以<code>Base</code>类是一个普通类，在编译时不会有虚函数表。</p>
<p>也因此，当我们创建一个<code>Base</code>类的对象时，该对象自然没有虚函数指针这个变量存在</p>
<p>所以当我们用<code>sizeof</code>函数查看对象的大小，得到的结果是<code>1</code>（因为对象的大小是由<strong>成员变量</strong>决定的，而<code>Base</code>类中没有虚函数也没有成员变量，所以对象的大小是<code>1</code>byte，因为对象的大小至少要为<code>1</code>）。</p>
<p>这也说明了普通函数的地址不存储在类对象中，而是存储在代码段中。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>虚函数类：有虚函数，有虚函数表</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如上面的代码，<code>Base</code>类中有虚函数，所以<code>Base</code>类是一个虚函数类，在编译时会有虚函数表。当我们创建一个<code>Base</code>类的对象时，用<code>sizeof</code>函数查看对象的大小，得到的结果是<code>4</code>（因为对象的大小是由<strong>成员变量</strong>决定的，而<code>Base</code>类中有虚函数，所以对象的大小是<code>4</code>byte，因为对象的大小至少要为<code>1</code>）。</p>
<p>这也说明了虚函数的地址存储在类对象中，而不是存储在代码段中。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(b) &lt;&lt; endl; <span class="comment">// 8(64位系统)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="虚函数的工作原理和多态体现">2.1.4
虚函数的工作原理和多态体现</h4>
<p>多态原理：</p>
<ul>
<li>常规的多态是指在<strong>基类</strong>中定义一个<strong>虚函数</strong>，然后在<strong>派生类</strong>中<strong>重写</strong>这个虚函数</li>
<li>这样在<strong>基类</strong>指针或者引用绑定<strong>派生类</strong>对象时，调用这个虚函数时，会调用<strong>派生类</strong>的虚函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base myvirfunc&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived myvirfunc&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    p-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">// 使用指针调用虚函数，属于多态</span></span><br><span class="line"></span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">myvirfunc</span>(); <span class="comment">// 使用普通对象调用虚函数，不属于多态</span></span><br><span class="line"></span><br><span class="line">    Base* ybase = &amp;b;</span><br><span class="line">    ybase-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">// 使用指针调用虚函数，属于多态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的情况都属于多态</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//父类的指针指向子类对象</span></span><br><span class="line">    Base * p = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    p-&gt;<span class="built_in">myvirfunc</span>();</span><br><span class="line">    <span class="comment">//or</span></span><br><span class="line">    Derived d;</span><br><span class="line">    Base * p2 = &amp;d;</span><br><span class="line">    p2-&gt;<span class="built_in">myvirfunc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父类引用绑定子类对象</span></span><br><span class="line">    Base &amp; r = d;</span><br><span class="line">    r.<span class="built_in">myvirfunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>内存布局</strong></p>
<p>拥有虚函数的基类会在内存中共享一个<strong>虚函数表</strong>，而这个虚函数表中存储了所有虚函数的地址。</p>
<p>当我们创建一个基类的对象时，这个对象会有一个<strong>虚函数指针</strong>，指向这个虚函数表。</p>
<p>而<strong>虚函数表</strong>和<strong>虚函数指针</strong>都是在<strong>编译</strong>时就已经生成的。</p>
<p><strong>存在继承关系时的内存布局</strong></p>
<p>假设基类<code>Base</code>有三个虚函数<code>f</code>、<code>g</code>、<code>h</code>，那么在编译时，<code>Base</code>类的虚函数表中会存储这三个虚函数的地址。</p>
<p>当派生类<code>Derived</code>继承<code>Base</code>类时，由于<code>Derived</code>类重写了其中的<code>f</code>函数，所以<code>Derived</code>类的虚函数表中会存储<code>f</code>函数的地址，而<code>g</code>和<code>h</code>函数在虚函数表中的值跟<code>Base</code>类一样。</p>
<p><img src="/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/vptr2.jpg"></p>
<p>当用<code>Base</code>类的指针指向<code>Derived</code>类的对象时，构造函数会先调用<code>Base</code>类的构造函数，然后调用<code>Derived</code>类的构造函数。由于虚函数指针是跟对象绑定的，所以此时其实用的还是<code>Derived</code>对象的内存空间，所以虚函数指针指向的是<strong>子类Derived类的虚函数表</strong>。</p>
<h4 id="为什么说继承属于动态的多态">2.1.5
为什么说继承属于动态的多态？</h4>
<ul>
<li>函数<strong>静态绑定</strong>：在<strong>编译</strong>期间绑定的，一般<strong>非虚函数</strong>都是静态绑定</li>
<li>函数<strong>动态绑定</strong>：在<strong>运行</strong>期间绑定的，一般<strong>虚函数</strong>都是动态绑定</li>
</ul>
<p>动态多态之所以被称为<strong>动态</strong>的原因在于，它是在<strong>程序运行</strong>时（而非编译时）确定对象的类型和应该调用的函数的。</p>
<p>虽然<strong>虚函数表</strong>和<strong>虚函数指针</strong>都是在<strong>编译</strong>时确定的（但是并没有分配内存，运行时才会分配内存），但是<strong>编译期间虚函数指针是没有具体指向的</strong>。</p>
<p>只有当构造函数调用时，虚函数指针才会指向具体的虚函数表，而构造函数的调用是在<strong>程序运行</strong>时才会发生的，这也是继承属于<strong>动态绑定</strong>的原因。</p>
<p>继承下构造函数的调用顺序：<strong>自上而下：自基类到派生类</strong></p>
<p>虚析构函数的调用顺序：<strong>自下而上：自派生类到基类</strong></p>
<p>总结：<strong>编译</strong>时查看的是 <code>Shape</code>
类有没有这个接口, 而在<strong>运行</strong>时会查虚函数表,
<strong>才决定具体调用哪个</strong>(动态多态)</p>
<h3 id="静态多态">2.2 静态多态</h3>
<p>静态多态是通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现的。具体不多说了</p>
<h3 id="模板多态crtp">2.3 模板多态（CRTP）</h3>
<p>模板多态是通过<strong>模板</strong>实现的多态，即<strong>CRTP</strong>（Curiously
Recurring Template
Pattern）。(也称为<strong>奇异递归模板模式</strong>)</p>
<p><code>CRTP</code>将<strong>模板</strong>和<strong>继承</strong>相结合，形成一种新的设计模式。</p>
<p>（1）通过<strong>继承</strong>实现的多态是<strong>绑定的和动态的</strong>：</p>
<ul>
<li>绑定的含义是：对于参与多态行为的类型，它们（具有多态行为）的接口是在公共基类的设计中就预先确定的（有时候也把绑定这个概念称为入侵的或者插入的）。</li>
<li>多态的含义是：接口的绑定是在运行期（动态）完成的。</li>
</ul>
<p>（2）通过<strong>模板</strong>实现的多态是<strong>非绑定的和静态的</strong>：</p>
<ul>
<li>非绑定的含义是：对于参与多态行为的类型，它们的接口是没有预先确定的（有时也称这个概念为非入侵的或者非插入的）。</li>
<li>静态的含义是：接口的绑定是在编译期（静态）完成的。</li>
</ul>
<h4 id="模板">2.3.1 模板</h4>
<p>模板是C++中的一种<strong>泛型编程</strong>技术，通过模板可以实现<strong>类型参数化</strong>，即可以将类型作为参数传递给类或者函数。我们常用的<code>vector &lt;int&gt;</code>
或
<code>vector &lt;string&gt;</code>等都是通过模板实现的。C++中<strong>编译器</strong>会从函数模板通过具体类型<strong>产生不同的函数</strong></p>
<ul>
<li><p>模板在<strong>函数</strong>中的使用</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getMax</span><span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt;= b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;getMax(2, 10):&quot;</span> &lt;&lt; <span class="built_in">getMax</span>(a, b) &lt;&lt; endl;<span class="comment">//getMax(2, 10):10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> a1 = <span class="number">44.2</span>;</span><br><span class="line">    <span class="keyword">double</span> b1 = <span class="number">10.2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;getMax(44.2, 10.2):&quot;</span> &lt;&lt; <span class="built_in">getMax</span>(a1, b1) &lt;&lt; endl;<span class="comment">//Max(44.2, 10.2):44.2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码例子可以看出，通过模板类的实现使<code>getMax</code>可以接受任意类型的输入参数。</p></li>
<li><p>模板在<strong>类</strong>中的使用</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testTemp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">testTemp</span>(T a1, T b1) :<span class="built_in">a</span>(a1), <span class="built_in">b</span>(b1) &#123;&#125;</span><br><span class="line">    T a;</span><br><span class="line">    T b;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;printMax:&quot;</span> &lt;&lt; <span class="built_in">getMax</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getMax</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T testTemp&lt;T&gt;::<span class="built_in">getMax</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt;= b ? a : b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">testTemp&lt;<span class="keyword">int</span>&gt; <span class="title">m_test</span><span class="params">(<span class="number">12</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    m_test.<span class="built_in">printMax</span>();<span class="comment">//printMax:22</span></span><br><span class="line"></span><br><span class="line">    <span class="function">testTemp&lt;<span class="keyword">double</span>&gt; <span class="title">m_test2</span><span class="params">(<span class="number">12.23</span>, <span class="number">22.45</span>)</span></span>;</span><br><span class="line">    m_test2.<span class="built_in">printMax</span>();<span class="comment">//printMax:22.45</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### 2.3.2 CRTP的实现</p></li>
</ul>
<p>CRTP是通过<strong>模板</strong>实现的多态，它的实现原理是通过<strong>模板</strong>实现<strong>继承</strong>。也就是创建一个<strong>模板类</strong>，然后其它类通过<strong>继承</strong>这个<strong>模板类</strong>来实现多态。</p>
<ul>
<li>首先创建一个模板基类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">static_cast</span>&lt;T*&gt;(<span class="keyword">this</span>)-&gt;<span class="built_in">printWord</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>然后创建两个继承这个模板基类的类</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过模板多态的方式基础模板类Base，此时模板传入的参数为类Child1</span></span><br><span class="line"><span class="comment">//Child1类需要有打印的函数printWord</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child1</span> :</span> <span class="keyword">public</span> Base&lt;Child1&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Child1: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base&lt;Child2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Child2: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>接着再提供一个函数，用来调用基类中的<code>foo</code>函数(委托函数printTest作为中间代理)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTest</span><span class="params">(Base&lt;T&gt;&amp; obj)</span> </span>&#123;</span><br><span class="line">	obj.<span class="built_in">foo</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后在<code>main</code>函数中调用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	Child1 c1;</span><br><span class="line">	Child2 c2;</span><br><span class="line">	<span class="built_in">printTest</span>(c1);</span><br><span class="line">	<span class="built_in">printTest</span>(c2);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>运行结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Child1: Hello</span><br><span class="line">Child2: Hello</span><br></pre></td></tr></table></figure>
<h3 id="c面向对象三大特性封装继承多态">2.4
C++面向对象三大特性：封装、继承、多态</h3>
<h4 id="封装">2.4.1 封装</h4>
<p>封装是指将<strong>数据</strong>和<strong>操作数据的函数</strong>封装在一起，形成一个<strong>类</strong>。封装可以<strong>隐藏</strong>类的<strong>实现细节</strong>，只提供<strong>公共接口</strong>给外部使用。</p>
<h4 id="继承">2.4.2 继承</h4>
<p>继承是让子类<strong>继承</strong>父类的<strong>属性和方法</strong>，修饰符<code>public</code>、<code>protected</code>、<code>private</code>用来控制继承的访问权限。</p>
<ul>
<li><code>public</code>：公有继承，子类可以访问父类的<code>public</code>成员</li>
<li><code>protected</code>：保护继承，子类可以访问父类的<code>protected+public</code>成员
<ul>
<li>但是再次继承该子类的类不能访问父类的<code>protected</code>成员</li>
<li>其实例化对象也不能访问父类的<code>protected</code>成员</li>
</ul></li>
<li><code>private</code>：私有继承，子类可以访问父类的<code>private+protected+public</code>成员</li>
</ul>
<h4 id="多态">2.4.3 多态</h4>
<p>多态如上面说的分为<strong>静态多态</strong>和<strong>动态多态</strong>，其中<strong>动态多态</strong>是通过<strong>虚函数</strong>实现的。</p>
<ul>
<li><strong>静态多态</strong>是通过<strong>函数重载</strong>和<strong>运算符重载</strong>实现的，是<strong>编译</strong>时的多态</li>
<li><strong>动态多态</strong>是通过<strong>虚函数</strong>实现的，是<strong>运行</strong>时的多态
<ul>
<li>将<strong>基类指针或者引用</strong>绑定<strong>派生类</strong>对象时，调用虚函数时，会调用<strong>派生类</strong>的虚函数</li>
</ul></li>
</ul>
<h2 id="三虚基类">三、虚基类</h2>
<p>虚基类是指在<strong>多重继承</strong>中，子类采用<code>: virtual public Base</code>的方式继承父类，是为了解决<strong>二义性</strong>问题而引入的</p>
<p><strong>二义性</strong>是指在菱形继承中，<strong>子类继承了两个父类</strong>，而这<strong>两个父类又继承了同一个父类</strong>，那么子类就会继承两份相同的父类，这就会导致二义性问题。</p>
<p><img src="/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/virtualBaseClass.png"></p>
<p>虚基类的使用可以有效防止菱形继承下调用两次（或多次）父类的构造函数。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/chlele0105/article/details/22654869">C++
虚基类</a></p>
</blockquote>
<h2 id="四深拷贝和浅拷贝">四、深拷贝和浅拷贝</h2>
<h3 id="浅拷贝">4.1 浅拷贝</h3>
<p>浅拷贝是指<strong>拷贝对象时，只是拷贝对象的值</strong>，而对于指针类型变量，不会重新分配内存，而是<strong>拷贝指针的地址</strong>。</p>
<p><strong>移动构造函数</strong>通常就是浅层拷贝，传参是右值引用（将亡值）。我们用对象a去实例化b时，实例化完后a其实就没用了，所以我们可以将a的资源直接转移到b，这样就不用再重新分配内存。因此传入<strong>右值或者将亡值时才会触发移动构造函数</strong></p>
<h3 id="深拷贝">4.2 深拷贝</h3>
<p>深拷贝相比浅拷贝，对于指针类型变量，会<strong>重新分配内存</strong>，并将<strong>指针指向的地址拷贝到新的内存空间</strong>，然后使用<code>memcpy</code>函数将原对象的值拷贝到新的内存空间。</p>
<p>深拷贝可以通过<strong>拷贝构造函数</strong>和<strong>赋值运算符重载</strong>实现。传参是左值参数。下面将展示这两种实现方法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testCopy</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数创建数组</span></span><br><span class="line">	<span class="built_in">testCopy</span>(<span class="keyword">int</span> size, <span class="keyword">int</span> start) :<span class="built_in">size_</span>(size) &#123;</span><br><span class="line">		data_ = <span class="keyword">new</span> <span class="keyword">int</span>[size_];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_; i++) &#123;</span><br><span class="line">			data_[i] = start + i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">testCopy</span>() &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data_;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拷贝构造函数实现深拷贝</span></span><br><span class="line">	<span class="built_in">testCopy</span>(<span class="keyword">const</span> testCopy&amp; copy) &#123;</span><br><span class="line">		<span class="keyword">delete</span>[] data_;</span><br><span class="line">		<span class="keyword">this</span>-&gt;size_ = copy.size_;</span><br><span class="line">		<span class="keyword">this</span>-&gt;data_ = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;size_];<span class="comment">//创建内存空间</span></span><br><span class="line">		<span class="built_in">memcpy</span>(data_, copy.data_, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * size_);<span class="comment">//复制所有数据</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//运算符重载实现深拷贝</span></span><br><span class="line">	testCopy&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> testCopy &amp; copy)&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;copy) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] data_;</span><br><span class="line">			<span class="keyword">this</span>-&gt;size_ = copy.size_;</span><br><span class="line">			<span class="keyword">this</span>-&gt;data_ = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>-&gt;size_];</span><br><span class="line">			<span class="built_in">memcpy</span>(data_, copy.data_, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) * size_);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size_; i++) &#123;</span><br><span class="line">			cout &lt;&lt; data_[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> size_;</span><br><span class="line">	<span class="keyword">int</span>* data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">testCopy <span class="title">t1</span><span class="params">(<span class="number">4</span>, <span class="number">7</span>)</span></span>;</span><br><span class="line">	<span class="function">testCopy <span class="title">t2</span><span class="params">(<span class="number">6</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t1 data:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	t1.<span class="built_in">printData</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t2 data:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	t2.<span class="built_in">printData</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//使用拷贝构造函数</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t3 data:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="function">testCopy <span class="title">t3</span><span class="params">(t1)</span></span>;</span><br><span class="line">	t3.<span class="built_in">printData</span>();</span><br><span class="line">	<span class="comment">//使用运算符重载实现深拷贝</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;t3 data:&quot;</span> &lt;&lt; endl;</span><br><span class="line">	t3 = t2;</span><br><span class="line">	t3.<span class="built_in">printData</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t1 data:</span><br><span class="line">7 8 9 10</span><br><span class="line">t2 data:</span><br><span class="line">2 3 4 5 6 7</span><br><span class="line">t3 data:</span><br><span class="line">7 8 9 10</span><br><span class="line">t3 data:</span><br><span class="line">2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<h2 id="五常用的stringvectormapset">五、常用的string、vector、map、set</h2>
<h3 id="string-vs-char">5.1 string VS char*</h3>
<ul>
<li><p><code>char*</code>是C语言中的字符串，指向一个字符数组，以<code>\0</code>结尾，其内存是由程序员分配和释放的，所以可能会有空间不足的问题。通过<code>const char *str = "hello";</code>的方式创建的字符串是<strong>只读的</strong>，不能修改。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>; <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure></p>
<p>但是通过<code>char str[] = "hello";</code>的方式创建的字符串是<strong>可读写</strong>的，可以修改。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>; <span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>string</code>是C++中的字符串，是<strong>标准库类型STL</strong>中的一个类，内部<strong>封装了很多字符串操作的方法</strong>（比如查找、替换、删除等），而且内存是由系统自动分配和释放的，所以除非内存不足，否则不会出现空间不足的问题。通过<code>string str = "hello";</code>的方式创建的字符串是<strong>可读写</strong>的，可以修改。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;H&#x27;</span>; <span class="comment">//编译通过</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>**1）string和char*的关系**</p>
<p>string底层是通过<code>char*</code>实现的，所以string和<code>char*</code>之间可以相互转换。</p>
<p>**2）string和char*的相互转换**</p>
<ul>
<li><p><code>string</code>转<code>char*</code>：<code>string</code>的<code>c_str()</code>函数可以将<code>string</code>转换为<code>char*</code>。通过转换可以在<code>printf</code>等函数中使用<code>string</code>。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">char</span>* cstr = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(str.<span class="built_in">c_str</span>());<span class="comment">//str.c_str()返回的是const char*，所以需要转换为char*</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>char*</code>转<code>string</code>：<code>string</code>的<strong>构造函数</strong>可以将<code>char*</code>转换为<code>string</code>。以及通过赋值运算符<code>=</code>也可以将<code>char*</code>转换为<code>string</code>。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(cstr)</span></span>;<span class="comment">//构造函数</span></span><br><span class="line">string str2 = cstr;<span class="comment">//赋值运算符</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="vector-vs-数组">5.2 vector VS 数组</h3>
<h4 id="vector的初始化">5.2.1 vector的初始化</h4>
<p><code>vector</code>的初始化可以通过<strong>构造函数</strong>、<strong>赋值运算符</strong>、<strong>列表初始化</strong>的方式进行。</p>
<ul>
<li><p>通过构造函数初始化</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v0</span><span class="params">(<span class="number">5</span>)</span></span>;<span class="comment">//初始化5个元素，每个元素的值为0</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;<span class="comment">//初始化5个元素，每个元素的值为1</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>通过赋值运算符初始化</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//初始化5个元素，每个元素的值为1, 2, 3, 4, 5</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v3 = v2;<span class="comment">//将v2的值赋给v3</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>通过列表初始化初始化</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//初始化5个元素，每个元素的值为1, 2, 3, 4, 5</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v5 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;<span class="comment">//初始化5个元素，每个元素的值为1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>二维vector的初始化</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">v6</span>(<span class="number">3</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">1</span>));<span class="comment">//初始化3行4列，每个元素的值为1</span></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="vector的迭代器遍历">5.2.2 vector的迭代器遍历</h4>
<p><code>vector</code>的迭代器遍历可以通过<strong>迭代器</strong>、<strong>auto关键字</strong>、<strong>范围for循环</strong>的方式进行。</p>
<ul>
<li><p>通过迭代器遍历：迭代器是一种<strong>指针</strong>，可以通过<code>begin()</code>和<code>end()</code>函数获取<code>vector</code>的<strong>首地址</strong>和<strong>尾地址</strong>。</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//通过*解引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it!=v.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">	cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p></li>
<li><p>通过范围for循环遍历</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">	cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="vector与数组的区别">5.2.3 vector与数组的区别</h4>
<ul>
<li>相同点
<ul>
<li><code>vector</code>和数组都是<strong>线性结构</strong>，都是<strong>连续的内存空间（这里的连续空间是指虚拟内存，在物理内存中不保证连续）</strong>。</li>
<li><code>vector</code>和数组都是<strong>有序的</strong>，都可以通过<strong>下标</strong>访问元素。</li>
</ul></li>
<li>不同点
<ul>
<li><code>vector</code>是<strong>动态数组</strong>，可以<strong>动态增加</strong>和<strong>删除</strong>元素，而数组是<strong>静态数组</strong>，长度是<strong>固定</strong>的。</li>
<li><code>vector</code>是<strong>STL</strong>中的<strong>容器</strong>，提供了很多<strong>成员函数</strong>，可以方便的进行<strong>插入</strong>、<strong>删除</strong>、<strong>查找</strong>等操作，而数组没有这些功能。</li>
<li><code>vector</code>是<strong>类</strong>，而数组是<strong>基本数据类型</strong>，所以<code>vector</code>可以<strong>继承</strong>，而数组不能继承。</li>
<li><code>vector</code>是可以通过<code>v1=v2</code>的方式进行<strong>赋值</strong>的，而数组不能直接通过这种方式进行赋值。</li>
</ul></li>
</ul>
<h3 id="set-和-map容器">5.3 set 和 map容器</h3>
<h4 id="set">5.3.1 set</h4>
<p><code>set</code>是<strong>集合</strong>，是一种<strong>关联式容器</strong>，它的主要特点如下：</p>
<ul>
<li><code>set</code>底层是<strong>红黑树RBTree</strong>，是一种<strong>平衡二叉树</strong>，所以<strong>查找</strong>、<strong>插入</strong>、<strong>删除</strong>的时间复杂度都是<strong>O(logn)</strong>。</li>
<li>其元素只有<strong>key</strong>，没有<strong>value</strong>（或者说value就是key）</li>
<li><code>set</code>中的元素是<strong>唯一</strong>的，不允许重复。</li>
<li><code>set</code>中的元素是<strong>有序</strong>的，是按照<strong>key</strong>的<strong>升序</strong>排列的。</li>
<li><code>set</code>中的元素是<strong>不可修改</strong>的，如果要修改元素，需要先删除再插入。（否则的话修改会破坏红黑树的平衡性）</li>
</ul>
<p><code>set</code>的基本函数操作有：</p>
<ul>
<li><code>insert</code>：插入元素</li>
<li><code>erase</code>：删除元素</li>
<li><code>find</code>：查找元素</li>
<li><code>count</code>：统计元素个数（因为元素是唯一的，所以相当于判断元素是否存在）</li>
<li><code>begin</code>：返回指向第一个元素的迭代器</li>
<li><code>end</code>：返回指向最后一个元素的迭代器</li>
<li><code>size</code>：返回元素个数</li>
<li><code>empty</code>：判断是否为空</li>
</ul>
<p>操作举例:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="number">1</span>) != s.<span class="built_in">end</span>())&#123;</span><br><span class="line">	s.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">count</span>(<span class="number">2</span>))&#123;<span class="comment">//返回1</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;2存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="map">5.3.2 map</h4>
<p><code>map</code>跟<code>set</code>类似，也是一种<strong>关联式容器</strong>，底层也是由<strong>红黑树RBTree</strong>实现的，<code>key</code>具有<strong>唯一性</strong>和<strong>有序性</strong>。但是<code>map</code>中的元素是<strong>pair键值对的形式存在的</strong>，<code>key</code>是<strong>唯一</strong>的，而<code>value</code>可以重复。</p>
<p><code>map</code>的基本函数操作有：</p>
<ul>
<li><code>insert</code>：插入元素</li>
<li><code>erase</code>：删除元素</li>
<li><code>find</code>：查找元素</li>
<li><code>count</code>：统计元素个数（因为元素是唯一的，所以相当于判断元素是否存在）</li>
<li><code>begin</code>：返回指向第一个元素的迭代器</li>
<li><code>end</code>：返回指向最后一个元素的迭代器</li>
<li><code>size</code>：返回元素个数</li>
<li><code>empty</code>：判断是否为空</li>
</ul>
<p>操作举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ulitity&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	map&lt;<span class="keyword">int</span>, string&gt; m_map;</span><br><span class="line">	<span class="comment">//三种插入数据的方式：make_pair、pair、类似数组的方式</span></span><br><span class="line">	m_map.<span class="built_in">insert</span>(make_pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;Hello1&quot;</span>));</span><br><span class="line">	m_map.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;Hello2&quot;</span>));</span><br><span class="line">	m_map[<span class="number">3</span>] = <span class="string">&quot;Hello3&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (m_map.<span class="built_in">find</span>(<span class="number">1</span>) != m_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">		cout &lt;&lt; m_map[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_map.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (m_map.<span class="built_in">count</span>(<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;无2这个key&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="multiset和multimap">5.3.3 multiset和multimap</h4>
<p>扩展讲一下<code>multiset</code>和<code>multimap</code>，<code>multiset</code>和<code>multimap</code>是<code>set</code>和<code>map</code>的<strong>多重集合</strong>版本，特点是允许<code>key</code>重复。底层也是由<strong>红黑树RBTree</strong>实现的。</p>
<h2 id="六自动类型推导">六、自动类型推导</h2>
<p>自动类型推导有两种方式：<code>auto</code>和<code>decltype</code>。</p>
<h3 id="auto">6.1 auto</h3>
<p><code>auto</code>是C++11新特性，可以<strong>自动推导变量的类型</strong>，可以用于<strong>变量声明</strong>、<strong>函数返回值</strong>、<strong>模板参数</strong>等。</p>
<p>auto是编译器通过<strong>初始值</strong>去判断类型的</p>
<h3 id="decltype">6.2 decltype</h3>
<p><code>decltype</code>是C++11新特性，可以<strong>获取表达式的类型</strong>，可以用于<strong>变量声明</strong>、<strong>函数返回值</strong>、<strong>模板参数</strong>等。</p>
<p>decltype是编译器通过<strong>变量或表达式</strong>去判断类型的</p>
<p>使用<code>decltype</code>有两种方式：<strong>decltype(表达式)</strong>和<strong>decltype(变量)</strong>。</p>
<ul>
<li><p>变量方法</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">decltype</span>(a) b = <span class="number">20</span>;<span class="comment">//b的类型和a的类型相同</span></span><br><span class="line">	<span class="keyword">auto</span> c = a;<span class="comment">//c的类型和a的类型相同</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>表达式方法</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">decltype</span>(a) b = <span class="number">20</span>;<span class="comment">//b的类型和a的类型相同</span></span><br><span class="line">	<span class="keyword">auto</span> c = a;<span class="comment">//c的类型和a的类型相同</span></span><br><span class="line">	<span class="keyword">decltype</span>(a + <span class="number">1</span>) d = <span class="number">30</span>;<span class="comment">//d的类型和a+1的类型相同</span></span><br><span class="line">	<span class="keyword">auto</span> e = a + <span class="number">1</span>;<span class="comment">//e的类型和a+1的类型相同</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="七c11新特性">七、C++11新特性</h2>
<ul>
<li><code>auto</code>：自动类型推导</li>
<li><code>decltype</code>：获取表达式的类型</li>
<li><code>lambda</code>：是一种内嵌的匿名函数（闭包实例）
<ul>
<li>可以捕获变量（值分为捕获和引用捕获两种）、传递参数、返回值等</li>
</ul></li>
<li><code>nullptr</code>：用来代替<code>NULL</code>，<code>NULL</code>在C++中是一个宏定义，跟0是一样的，所以在重载函数时会出现<strong>二义性问题</strong>，而<code>nullptr</code>是一个关键字</li>
<li><code>智能指针</code>：<code>shared_ptr</code>、<code>unique_ptr</code>、<code>weak_ptr</code></li>
<li><code>初始化列表</code>：<code>&#123;&#125;</code>，用来初始化数组、结构体、类等，其中list列表变量初始化的顺序是<strong>由参数声明的顺序决定的</strong>，不是初始化列表的顺序决定的</li>
<li><code>基于范围的for循环</code>：for(auto i : v)</li>
<li><code>右值引用</code>：<code>&amp;&amp;</code>，用来实现移动语义
<ul>
<li>右值（将亡值/纯右值）不能取地址，左值可以取地址</li>
<li>右值引用不能绑定到任何左值，如果想实现绑定，需要使用<code>std::move</code>函数</li>
<li>左值引用就是普通的引用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//左值是a，右值是10</span></span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="comment">//int &amp;c = 10;//编译报错，10是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;c = <span class="number">10</span>;</span><br><span class="line">c = <span class="number">20</span>;<span class="comment">//修改右值</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><code>noexcept</code>：用来指定函数是否抛出异常</li>
<li><code>explicit</code>：用来修饰构造函数，<strong>取消隐式转换</strong></li>
</ul>
<h2 id="九c-stl">九、C++ STL</h2>
<p>C++中STL是指：</p>
<ul>
<li>算法：排序、查找、替换等方法</li>
<li>容器：vector、list、deque、set、map等数据结构的容器，可以容纳不同类型的数据</li>
<li>迭代器：指针用来遍历容器的数据</li>
</ul>
<p>顺序式容器有：<code>vector</code>、<code>list</code>、<code>deque</code>（双向开口线性空间）、<code>queue</code>、<code>stack</code>、<code>priority_queue</code></p>
<ul>
<li>除了list外，插入删除(insert/erase)都会<strong>使原先取出的迭代器失效</strong></li>
</ul>
<p>关联式容器有：<code>set</code>、<code>map</code>、<code>multiset</code>、<code>multimap</code></p>
<ul>
<li>插入删除<strong>不会使迭代器失效</strong>（只有删除的那个元素的迭代器失效）</li>
<li>set和map是红黑树实现的，所以查找、插入、删除的时间复杂度都是O(logn)</li>
</ul>
<p>各种容器的迭代器类别如下表：</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 71%">
<col style="width: 14%">
</colgroup>
<thead>
<tr>
<th>容器</th>
<th>迭代器类别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector deque</td>
<td>随机访问迭代器</td>
<td>支持<code>+</code>、<code>-</code>、<code>+=</code>、<code>-=</code>、<code>[]</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code></td>
</tr>
<tr>
<td>stack queue priority_queue</td>
<td>不支持迭代器（不能被遍历）</td>
<td>无法遍历</td>
</tr>
<tr>
<td>list (multi)map/set</td>
<td>双向迭代器</td>
<td>支持<code>++</code>、<code>--</code>、<code>*</code>、<code>-&gt;</code></td>
</tr>
<tr>
<td>unordered_map/set forward_list</td>
<td>前向迭代器（只能向前移动）</td>
<td>支持<code>++</code>、<code>*</code>、<code>-&gt;</code></td>
</tr>
</tbody>
</table>
<h3 id="stl动态分配空间">9.1 STL动态分配空间</h3>
<p>从堆上分配空间的话有<strong>一级配置器</strong>和<strong>二级配置器</strong>：</p>
<ul>
<li>一级配置器是通过<code>malloc</code>和<code>free</code>实现的</li>
<li>二级配置器是<strong>默认的</strong>分配方式（需要分配的空间小于128Byte时使用的），是通过维护<strong>内存池+自由链表</strong>实现的
<img src="/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/memoryPool.png"></li>
</ul>
<h3 id="vector">9.2 vector</h3>
<p><strong>1）基础知识</strong></p>
<p><code>vector</code>是分配的<strong>连续地址空间</strong>，所以假设我们提前获取了vector中某个元素的地址，然后再插入元素，由于要保证vector的连续性，所以这个<strong>地址就会失效</strong>。</p>
<ul>
<li>而<code>deque</code>是由一段一段连续的空间拼接起来的</li>
</ul>
<p><strong>2）vector的双倍扩容</strong></p>
<p>vector中有效元素个数是<code>size()</code>，而分配的空间大小是<code>capacity()</code>，当插入元素且有<code>size()==capacity()</code>时，说明vector中的空间已经分配完了，这时就需要重新分配空间</p>
<ul>
<li>而<code>dequeue、stack、queue</code>也需要提前分配内存，但是是一次分配固定大小的内存，且不用重新拷贝，而是通过指针指向下一段的内存。</li>
</ul>
<p>vector当分配的空间不足时，新分配的空间会是<strong>原来的2倍</strong>，因为每次扩容就需要拷贝原先的数据，所以多分配内存的话能够减少<strong>内存分配和拷贝的次数</strong>，提高效率。</p>
<p>扩容有两种方法：</p>
<ul>
<li><code>resvser(n)</code>：预先分配空间，但是不会改变<code>size()</code>，只会改变<code>capacity()</code>，将<code>capacity()</code>预先扩大到n</li>
<li><code>resize(n,t)</code>：同时改变<code>size()</code>和<code>capacity()</code>都扩大到n，同时将新增的元素初始化为<code>t</code></li>
</ul>
<p><strong>3）vector释放内存</strong></p>
<p>vector有两种方式清楚数组：</p>
<ul>
<li><code>clear()</code>：清空数组，但是不会释放内存，<code>size()</code>变为0，<strong><code>capacity()</code>不变</strong></li>
<li><code>swap(vector&lt;int&gt;())</code>：清空数组，释放内存，<code>size()</code>和<code>capacity()</code>都变为0</li>
</ul>
<h3 id="list">9.3 list</h3>
<p><code>list</code>是<strong>双向链表</strong>实现的，所以各元素之间<strong>地址空间不连续</strong>，因此可以在任意位置插入元素，不会影响其他元素的地址。（这与vector不同）</p>
<p>vector和list的区别：</p>
<ul>
<li>vector<strong>随机访问效率更高</strong>（可以通过下标访问），而list只能通过迭代器访问O(n)</li>
<li>list在<strong>中间插入时效率高</strong>，因为vector插入时需要挪动后面的元素，且插入后后面的地址失效，而list依然有效</li>
</ul>
<h3 id="hashunordered_map">9.4 Hash（unordered_map）</h3>
<p><code>unordered_map</code>是C++11中引入的新容器，是<strong>哈希表</strong>，是一种<strong>关联式容器</strong>，底层是<strong>哈希表</strong>实现的，<code>key</code>具有<strong>唯一性</strong>和<strong>无序</strong>。哈希表查询时间复杂度是<strong>O(1)</strong>。</p>
<p>其中解决哈希冲突的方式是<strong>开链法</strong>，C++中哈希表中的哈希槽<code>bucket</code>是用<code>vector</code>实现的，但是每个<code>bucket</code>中存储的是<strong>链表</strong>，因此<code>unordered_map</code>插入新元素时<strong>原先的迭代器指针也不会失效</strong>。当然也可以使用其他方法解决哈希冲突问题：</p>
<ul>
<li>线性探测</li>
<li>再散列：维护多个不同的<strong>哈希函数</strong>，当发生冲突时，再使用另一个哈希函数，直到找到空槽</li>
</ul>
<p><img src="/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/unordered_map.png"></p>
<h2 id="九ccpython的区别">九、C++、C、Python的区别</h2>
<h3 id="c和c的区别">1. C++和C的区别</h3>
<ul>
<li>编译链接不同：C++因为有<strong>重载</strong>，所以函数名会在C++编译器中进行<strong>名称改编</strong>，而C语言不会。C++编译后会生成<code>.obj</code>文件，C语言编译后会生成<code>.o</code>文件</li>
<li>C++支持<strong>面向对象</strong>，而C语言不支持</li>
<li>C++中内存分配和释放是通过<code>new</code>和<code>delete</code>，而C语言只能通过<code>malloc</code>和<code>free</code></li>
<li>C++中有<strong>引用</strong>，而C语言没有</li>
<li>C++中有<strong>try/catch/throw的异常处理</strong></li>
<li>C++中有<strong>模板</strong>，而C语言没有</li>
<li>C++新增了关键字：namespace、bool、true、false、new等</li>
</ul>
<h3 id="c和python的区别">2. C++和Python的区别</h3>
<ul>
<li>C++是<strong>编译型语言</strong>，Python是<strong>解释型语言</strong></li>
<li>Python支持的库很多，但是运行速度比C++慢</li>
<li>Python有严格的<strong>缩进规则，用缩进代表代码块</strong>，而C++用<strong>花括号{}</strong>代表代码块</li>
<li>C++变量需要<strong>声明</strong>，而Python不需要</li>
</ul>
]]></content>
      <categories>
        <category>C++知识点</category>
      </categories>
  </entry>
  <entry>
    <title>C++底层学习</title>
    <url>/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一程序预编译-编译-链接-运行的过程">一、程序预编译-编译-链接-运行的过程</h1>
<h2 id="基础知识操作系统相关">1.1 基础知识（操作系统相关）</h2>
<h3 id="可执行文件格式及数据">1.1.1 可执行文件格式及数据</h3>
<p><strong>1）Windows和Linux的可执行文件格式</strong></p>
<p>以C++为例，Windows下的可执行文件格式是<code>.exe</code>，格式为<strong>PE</strong>；Linux下的可执行文件是<strong>ELF</strong>格式。</p>
<p><strong>2）数据和指令的区别</strong></p>
<p>无论用什么语言编写的程序，最终都是一堆<strong>二进制</strong>数据，这些数据有两种类型：<strong>指令</strong>和<strong>数据</strong>。指令是CPU执行的，数据是CPU读写的。</p>
<p>其中<strong>函数调用</strong>、<strong>循环</strong>、<strong>条件判断</strong>等最终都会被编译成一系列的<strong>指令</strong>存在<strong>文本段</strong>，而<strong>变量</strong>、<strong>常量</strong>等则会被编译成<strong>数据</strong>存储在**数据段。</p>
<p><strong>3）文本段和数据段</strong></p>
<ul>
<li><strong>文本段</strong>：存放程序的<strong>指令</strong>，是<strong>只读</strong>的，不允许写入。（代码区）
<ul>
<li>静态成员函数、普通成员函数</li>
</ul></li>
<li><strong>数据段</strong>：存放程序的<strong>数据</strong>，是<strong>可读写</strong>的。数据段又可以分为<strong>数据段</strong>和<strong>BSS段</strong>
<ul>
<li><strong>数据段</strong>存放<strong>初始化的全局变量</strong></li>
<li><strong>BSS段</strong>存放<strong>未初始化的全局变量</strong>。</li>
</ul></li>
</ul>
<p>这些<strong>段</strong>组成了<strong>可执行文件</strong>，在程序运行时会被加载到进程的<strong>虚拟内存</strong>中，然后通过<strong>页表</strong>映射到<strong>物理内存</strong>中。</p>
<p><strong>4）虚拟地址空间</strong></p>
<p>前面提到<strong>段</strong>在程序运行时会被加载到<strong>虚拟内存</strong>中，当程序运行时，操作系统会为每个进程分配一个<strong>虚拟地址空间</strong>（Linux下是<strong>4G</strong>），其中<strong>0-3G</strong>是用户空间，<strong>3-4G</strong>是内核空间。</p>
<p>其中用户空间组成为（从低位到高位）：</p>
<ul>
<li><strong>预留空间</strong>：<code>128M</code></li>
<li><strong>文本段.text</strong>：存放程序的<strong>指令</strong></li>
<li><strong>数据段.data</strong>：存放程序的<strong>已初始化的数据</strong></li>
<li><strong>BSS段.bss</strong>：存放<strong>未初始化的全局变量</strong></li>
<li><strong>堆heap</strong></li>
<li><strong>栈stack</strong></li>
</ul>
<p>虚拟空间由<strong>用户空间</strong>和<strong>内核空间</strong>组成，因此<strong>32位</strong>系统下虚拟内存的最大空间为<strong>3G+1G</strong>，<strong>64位系统是128T+128T</strong>：</p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/memory.png"></p>
<p>访问栈区的数据比访问堆区的数据快：</p>
<ul>
<li>栈区数据直接由寄存器访问；堆区需要由指针访问，先将指针加载到寄存器，然后再访问数据</li>
<li>栈区可以利用连续空间的特性缓存数据；堆区数据是离散的，无法充分利用CPU缓存</li>
</ul>
<h3 id="cpu寄存器内存的关系">1.1.2 CPU、寄存器、内存的关系</h3>
<p>计算机的三个核心组成部分：<strong>CPU</strong>、<strong>内存</strong>、<strong>I/O</strong>。</p>
<ul>
<li><strong>CPU</strong>：是计算机的大脑，属于高速设备，用来频繁地读取、执行指令（数据）。</li>
<li><strong>内存</strong>：属于中速设备，用来存储程序的指令和数据。</li>
<li><strong>I/O</strong>：属于低速设备，用来输入输出数据。</li>
</ul>
<p>而<strong>寄存器</strong>是<strong>CPU内部的</strong>一块高速缓存，用来存储CPU执行指令时的临时数据，如<strong>程序计数器</strong>、<strong>指令寄存器</strong>、<strong>通用寄存器</strong>等。</p>
<p>一般来说，程序运行中会先从<strong>内存</strong>中读取指令到<strong>寄存器</strong>中，然后<strong>CPU</strong>执行这些指令，最后将结果通过<strong>寄存器</strong>写回到<strong>内存</strong>中。也就是说，<strong>寄存器</strong>是<strong>CPU</strong>和<strong>内存</strong>之间的桥梁。</p>
<h2 id="生成可执行文件的过程">1.2 生成可执行文件的过程</h2>
<p>以Linux下的C程序为例，生成可执行文件的过程主要分为四个阶段：</p>
<ul>
<li><strong>预编译</strong>（Preprocessing）-&gt;<code>.i</code>文件</li>
<li><strong>编译</strong>（Compilation）-&gt;<code>.s</code>文件</li>
<li><strong>汇编</strong>（Assembly）-&gt;<code>.o</code>文件</li>
<li><strong>链接</strong>（Linking）-&gt;可执行文件</li>
</ul>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/Compiler_Work.png"></p>
<p>当我们有一个<code>.c</code>文件时，我们可以通过<code>gcc</code>命令将其编译成可执行文件:
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hello.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc hello.c <span class="comment"># 编译</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.out <span class="comment"># 执行</span></span></span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure></p>
<p>而生成可执行文件过程就是<code>gcc</code>这个语句实现的，这句语句就实现了上述说到的4个步骤，接下来我们将剖析一下这四个步骤的具体实现。</p>
<h3 id="预编译">1.2.1 预编译</h3>
<p>预编译的主要工作是将<strong>头文件以及宏定义替换成其真正的内容</strong>，得到一个<code>.i</code>文件。所以预编译后得到的文件将比原文件大很多。</p>
<p>在Linux中我们可以通过<code>gcc -E</code>命令来分解编译过程，使其停留在预编译阶段，并通过<code>-o</code>指定文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -E hello.c -o hello.i</span></span><br></pre></td></tr></table></figure>
<p>结果预编译后文件的大小变大，因为预编译后的文件中包含了很多头文件的内容：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">时间</th>
<th style="text-align: center;">文件名</th>
<th style="text-align: center;">大小</th>
<th style="text-align: center;">代码行数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">预处理前</td>
<td style="text-align: center;">hello.c</td>
<td style="text-align: center;">50</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: center;">预处理后</td>
<td style="text-align: center;">hello.i</td>
<td style="text-align: center;">1.1K</td>
<td style="text-align: center;">3</td>
</tr>
</tbody>
</table>
<p><strong>C++中宏定义与函数的区别</strong></p>
<ul>
<li><strong>宏定义</strong>在预编译阶段就完成了替换，相当于直接插入了代码，不存在函数调用，也没有返回值、不做类型检查、不加分号</li>
<li><strong>函数</strong>是在编译阶段才会被调用，有返回值、有类型检查、需要在最后加分号。</li>
</ul>
<h3 id="编译">1.2.2 编译</h3>
<p>编译的主要工作是将<strong>预编译后的文件</strong>转换成<strong>汇编代码</strong>，得到一个<code>.s</code>文件。</p>
<p>在Linux中我们可以通过<code>gcc -S</code>命令来分解编译过程，使其停留在编译阶段，并通过<code>-o</code>指定文件名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -S hello.i -o hello.s</span></span><br></pre></td></tr></table></figure>
<p>最终得到的文件是一个汇编代码文件，内容如下： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    .file	&quot;hello.c&quot;</span><br><span class="line">    .text</span><br><span class="line">    .globl	main</span><br><span class="line">    .type	main, @function</span><br><span class="line">main:</span><br><span class="line">    .LFB0:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">    pushq	%rbp</span><br><span class="line">    .cfi_def_cfa_offset 16</span><br><span class="line">    .cfi_offset 6, -16</span><br><span class="line">    movq	%rsp, %rbp</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></p>
<h3 id="汇编">1.2.3 汇编</h3>
<p>汇编的主要工作是将<strong>汇编代码</strong>转换成<strong>机器码Machine
Code</strong>（二进制），得到一个<code>.o</code>文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc -c hello.s -o hello.o</span></span><br></pre></td></tr></table></figure>
<p>前面我们提到，可执行文件是由<strong>文本段</strong>和<strong>数据段</strong>组成的，其实每个<code>.o</code>文件就是一个<strong>目标文件</strong>，其中包含了<strong>文本段</strong>和<strong>数据段</strong>的内容。因此单独一个<code>.o</code>文件是无法运行的分布如下：</p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/memory_o.png"></p>
<h3 id="链接">1.2.4 链接</h3>
<p>假设我们代码不止一个文件，那么我们需要先将这些文件都全部生成为汇编代码<code>.o</code>，然后再将这些汇编代码链接成一个可执行文件<code>a.out</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc hello.o hello2.o -o a.out</span></span><br></pre></td></tr></table></figure>
<p>在链接的过程中，会将多个<code>.o</code>文件中的<strong>文本段</strong>和<strong>数据段</strong>合并成一个可执行文件，也就是将所有<code>.text</code>合并成一个<code>.text</code>，将所有<code>.data</code>合并成一个<code>.data</code>。最终的布局如下：</p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/combine_o.png" width="80%"></p>
<h3 id="运行">1.2.5 运行</h3>
<p>运行时会先将可执行文件<code>a.out</code>加载到<strong>虚拟内存</strong>中，然后通过<strong>页表</strong>映射到<strong>物理内存</strong>中，最终通过<strong>CPU</strong>执行这些指令。</p>
<h2 id="静态链接和动态链接">1.3 静态链接和动态链接</h2>
<p>静态链接和动态链接的主要区别在于<strong>链接</strong>的时机不同</p>
<ul>
<li>静态链接是在<strong>编译</strong>时进行的</li>
<li>动态链接是在<strong>运行</strong>时进行的。</li>
</ul>
<p>其库存储的<strong>位置</strong>不同</p>
<ul>
<li>静态链接库是<strong>编译</strong>时链接集成到<strong>可执行文件</strong>中</li>
<li>动态链接库是作为独立的共享库存储的，<strong>运行</strong>时再加载到<strong>内存</strong>中。</li>
</ul>
<h3 id="静态链接">1.3.1 静态链接</h3>
<p><strong>静态链接</strong>是指在<strong>链接</strong>阶段将程序中所有的<strong>静态库</strong>（如Linux下的<code>.a</code>文件、Windows下的<code>.lib</code>文件）都链接到可执行文件中，生成一个<strong>独立的可执行文件</strong>。</p>
<p><strong>1）优点</strong></p>
<p>静态链接的方式包含了程序运行需要的所有代码和数据，因此可以独立运行，不需要依赖其他文件。</p>
<p><strong>2）缺点</strong></p>
<p>每个使用该库的程序都会有一份该库的拷贝，因此会<strong>占用更多的磁盘空间</strong>。</p>
<p>同时，如果库文件更新了，那么所有使用该库的程序都需要重新编译，<strong>维护成本高</strong>。</p>
<h3 id="动态链接">1.3.2 动态链接</h3>
<p><strong>动态链接</strong>是指在<strong>链接</strong>阶段只将程序中的<strong>引用</strong>链接到可执行文件中，实际<strong>链接</strong>库是在<strong>运行</strong>时进行的，操作系统执行时会根据需要加载<strong>共享库</strong>（如Linux下的<code>.so</code>文件、Windows下的<code>.dll</code>文件）。</p>
<p><strong>1）优点</strong></p>
<p>由于多个程序运行时只需要一个共享库，因此<strong>节省了磁盘空间</strong>。</p>
<p>如果库文件更新了，只需要更新一份库文件，所有使用该库的程序都会<strong>自动更新</strong>。</p>
<p><strong>2）缺点</strong></p>
<p>程序运行时需要加载共享库，因此<strong>启动速度慢</strong>。</p>
<p>如果共享库出现问题（丢失或损坏），那么所有使用该库的程序都会受到影响。</p>
<blockquote>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/88255667">C/C++编译链接</a></p>
<p>参考：<a href="https://blog.csdn.net/Mr_H9527/article/details/81156112">C++：深入理解编译和链接过程</a></p>
</blockquote>
<h1 id="二内存管理">二、内存管理</h1>
<h2 id="c内存分区">2.1 C++内存分区</h2>
<p>C++程序在运行时会将内存分为<strong>5个区域</strong>：</p>
<ul>
<li><strong>栈区</strong>：存放<strong>局部变量</strong>等，由<strong>系统自动</strong>分配和释放。</li>
<li><strong>堆区</strong>：存放<strong>动态分配</strong>的内存，由<strong>程序员</strong>分配和释放。</li>
<li><strong>全局/静态区</strong>：存放<strong>全局变量</strong>和<strong>静态变量</strong>，程序启动时分配，程序结束时释放。</li>
<li><strong>常量区</strong>：存放<strong>常量</strong>，如字符串常量。</li>
<li><strong>代码区</strong>：存放<strong>函数体的二进制代码</strong>。所有成员函数、全局函数都放在代码区。所以函数不占用对象的内存</li>
</ul>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/memory_fenpei.png" width="80%"></p>
<p>其实还有个<strong>自由存储区</strong>，也会被认为是<strong>堆区</strong>的一部分，用于存放<strong>new</strong>和<strong>delete</strong>的内存。</p>
<h2 id="内存池">2.2 内存池</h2>
<h2 id="内存泄漏">2.3 内存泄漏</h2>
<p>内存泄漏在前面的博客中已经提到过：<a href="https://akirazheng.github.io/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/">C++基础知识学习</a></p>
<p>内存泄漏主要是由<strong>new</strong>或<strong>malloc</strong>分配的内存没有被释放，长时间运行后如果内存满了会导致内存溢出、造成程序崩溃。建议通过<strong>析构函数</strong>、<strong>智能指针</strong>、<strong>RAII</strong>等方式来避免内存泄漏。</p>
<h2 id="this指针">2.4 this指针</h2>
<p>同样在前面的博客中也提到过：<a href="https://akirazheng.github.io/2024/03/09/C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/">C++基础知识学习</a></p>
<p>主要注意的是它只能在类的<strong>成员函数</strong>中使用，且<strong>静态成员函数</strong>中不能使用。</p>
<h2 id="类的内存分配">2.5 类的内存分配</h2>
<p>这部分包括类内的对齐在后面的<strong>内存对齐</strong>中会详细介绍。</p>
<p>一些特殊数据类型的大小：</p>
<ul>
<li>指针：32位下是4字节，64位下是8字节</li>
<li>union：取最大的成员的大小</li>
</ul>
<h1 id="三内存对齐">三、内存对齐</h1>
<p>内存对齐是编译器为了提高<strong>内存访问效率</strong>而采取的一种措施，能<strong>减少内存访问次数</strong>。</p>
<p>以32位系统为例，寄存器只能从能<strong>被4整除的地址</strong>（4bytes=32bits）中读取数据，因此如果数据不是4的整数倍，那么就需要<strong>两次</strong>内存访问才能读取完整的数据。</p>
<p>至于对齐字节是多少，这跟硬件的颗粒度有关，比如32位系统的寄存器是32bits，64位系统的寄存器是64bits。</p>
<h2 id="内存对齐的好处">3.1 内存对齐的好处</h2>
<ul>
<li><strong>方便平台移植</strong>
<ul>
<li>某些硬件平台不能访问任意地址的内存，只能访问某些特定地址的内存，因此需要对齐来<strong>兼容</strong>这些硬件平台。</li>
</ul></li>
<li><strong>提高内存访问效率</strong>
<ul>
<li>未对齐的数据在内存中需要访问两次，而对齐的数据只需要访问一次，因此对齐能<strong>提高内存访问效率</strong>。（对于数据结构特别是栈，最好是在<strong>自然边界</strong>上对齐）</li>
</ul></li>
</ul>
<h2 id="c中结构体及类的内存对齐">3.2 C++中结构体及类的内存对齐</h2>
<p><strong>1）结构体的内存对齐</strong></p>
<p>C++中结构体的内存对齐是由<strong>最宽基本类型</strong>决定的，即结构体中的<strong>每个成员</strong>都要对齐到<strong>最宽基本类型（结构体中变量类型最大值）</strong>的整数倍。</p>
<ul>
<li><p>point：union的话会以union中最大的成员的大小为对齐基准，union的大小也是最大成员的大小</p></li>
<li><p>对齐原则：</p>
<ul>
<li><strong>确定对齐基准字节数</strong>：找到结构体中<strong>最宽的基本类型</strong>，如最宽的是<code>double</code>，那么对齐基准字节数就是<code>8</code>。后面的数据都要按照<code>8</code>的整数倍对齐，不足的补0。</li>
<li><strong>每个成员对齐规则</strong>：每个成员的<strong>距离整个结构体初始位置的offset必须是min(该成员大小，对齐基准字节数)的整数倍</strong>。</li>
<li><strong>整体对齐原则</strong>：最后结构体的大小<code>sizeof(structA)</code>必须是<strong>对齐基准字节数</strong>的整数倍。</li>
</ul></li>
</ul>
<p>举例说明： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structA</span> &#123;</span></span><br><span class="line">    <span class="comment">//最大的是int，因此对齐基准字节数是4，最终大小为12</span></span><br><span class="line">    <span class="keyword">char</span> a;  <span class="comment">//a - - -</span></span><br><span class="line">    <span class="keyword">int</span> b;   <span class="comment">//b b b b</span></span><br><span class="line">    <span class="keyword">short</span> c; <span class="comment">//c c - -</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(structA);<span class="comment">//12</span></span><br></pre></td></tr></table></figure></p>
<p>优化后将<code>int</code>放在最前面或者最后面： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">structA</span> &#123;</span></span><br><span class="line">    <span class="comment">//最大的是int，因此对齐基准字节数是4，最终大小为8，放在末尾同理</span></span><br><span class="line">    <span class="keyword">int</span> b;   <span class="comment">//b b b b</span></span><br><span class="line">    <span class="keyword">char</span> a;  <span class="comment">//a - - -</span></span><br><span class="line">    <span class="keyword">short</span> c; <span class="comment">//c c - -</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2）类的内存对齐</strong></p>
<ul>
<li>如果是类中的成员变量，也是按照上述规则进行对齐</li>
<li>同时如果类中有<strong>虚函数</strong>，那么类中会有一个<strong>虚函数表指针</strong>，这个指针大小为<strong>4</strong>也要进行对齐。</li>
<li>类中的<strong>成员函数</strong>不占实例化对象内的空间，因为<strong>成员函数</strong>是<strong>共享</strong>的。</li>
<li>所以一个类中如果只有普通函数，没有任何变量，那么这个类的大小是<strong>1</strong>。（因为类的大小最小是<strong>1</strong>）</li>
<li><strong>类中的static静态变量</strong>也不占类的大小，因为<strong>静态变量</strong>是<strong>共享</strong>的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="comment">//最大的是int，因此对齐基准字节数是4，最终大小为12</span></span><br><span class="line">    <span class="keyword">int</span> a;<span class="comment">//a a a a</span></span><br><span class="line">    <span class="keyword">char</span> b;<span class="comment">//b - - -</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//虚函数表指针:- - - -</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;<span class="comment">//成员函数不占空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(A);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(A);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p><strong>3）C++内存对齐最终还会再操作系统再次检查对齐</strong></p>
<p>比如我们在一个结构体中设置两个<code>char</code>型数据，那么根据C++的对齐规则，该结构体的大小是<code>2</code>，但是操作系统会再次检查对齐，如果操作系统要求对齐是<code>4</code>（32位），那么最终该结构体的大小是<code>4</code>（通过检查两个类对象的地址差发现的）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test2</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当用<code>sizeof</code>和通过地址差来检查对齐时，会发现<code>sizeof(test2)</code>是<code>2</code>，但是两个类对象的地址差是<code>4</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    test2 t1;</span><br><span class="line">    test2 t2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(test2) &lt;&lt; endl;<span class="comment">//1</span></span><br><span class="line">    cout &lt;&lt; &amp;t2&lt;&lt; endl;<span class="comment">//000000D4769CF384</span></span><br><span class="line">    cout &lt;&lt; &amp;t1&lt;&lt; endl;<span class="comment">//000000D4769CF3A4</span></span><br><span class="line">    <span class="comment">//发现前后差了4，说明跟我们想象中的一个对象占用1个字节不一样，猜测操作系统也进行了对齐操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四内存池设计">四、内存池设计</h1>
<h2 id="c默认的内存管理函数">4.1 C++默认的内存管理函数</h2>
<h3 id="系统分配内存空间">4.1.1 系统分配内存空间</h3>
<p>系统在接收到<strong>内存分配请求</strong>时，会有以下的操作：</p>
<ul>
<li>查找<strong>内存空闲表</strong></li>
<li>按照一定算法分配不小于申请需求的<strong>内存块</strong></li>
<li>切割成合适的大小返回给用户</li>
<li>更新内存表</li>
<li>如果涉及多线程，由于多线程共享一块内存空间，所以还会统一进行<strong>锁竞争</strong></li>
</ul>
<p>那么就会存在<strong>内存碎片</strong>和<strong>效率性能</strong>的问题：</p>
<p><strong>1）内存碎片</strong></p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/memory_sui.png"></p>
<ul>
<li>由于<strong>堆</strong>上内存的分配和释放是程序员控制的、<strong>不连续</strong>的，所以会产生内存碎片，导致<strong>内存利用率低</strong>。</li>
<li>内存碎片又分为<strong>外部碎片</strong>和<strong>内部碎片</strong>
<ul>
<li><strong>外部碎片</strong>是指已经被释放的内存，但是由于<strong>大小不合适</strong>无法分配给新的内存请求。</li>
<li><strong>内部碎片</strong>是指<strong>已分配的空间</strong>如C++中的<code>new</code>分配的内存，由于<strong>对齐</strong>等原因导致的<strong>浪费</strong>。</li>
</ul></li>
</ul>
<p><strong>2）效率性能问题</strong></p>
<ul>
<li>在多线程环境下，并发加锁会导致<strong>性能下降</strong>。</li>
<li>就像前面提到的系统分配内存的方式需要经过<strong>查找</strong>、<strong>分配</strong>、<strong>更新</strong>等操作，这些操作都会<strong>消耗时间</strong>，因此会影响<strong>效率</strong>。</li>
</ul>
<p>所以需要引入<strong>内存池</strong>来<strong>优化性能</strong>以及减少<strong>内存碎片</strong>问题。</p>
<p><strong>内存池</strong>是一种<strong>预先分配</strong>一定数量的内存，然后<strong>按需分配</strong>给用户，用户使用完后再<strong>归还</strong>给内存池，这样就可以<strong>减少内存碎片</strong>、<strong>减少频繁地向系统申请和释放资源来提高效率</strong>。</p>
<h3 id="malloc内存分配机制">4.1.2 malloc内存分配机制</h3>
<p>malloc分配内存有两种方式：<code>brk</code>和<code>mmap</code></p>
<ul>
<li>malloc不是系统调用，由于使用了池化技术会从提前申请的内存中分配，所以<strong>不会陷入内核态</strong></li>
<li><code>brk</code>和<code>mmap</code>是系统调用，会陷入内核态</li>
</ul>
<p><strong>1）C++内存回收</strong></p>
<p>C/C++是编译型语言，<strong>没有内存回收机制</strong>，程序员需要自己释放不需要的内存。</p>
<p>C++中的内存管理方式主要有<strong>运算操作符new</strong>和<strong>函数malloc</strong>两种，其中<strong>new</strong>也是基于<strong>malloc</strong>实现的。所以我们这里主要讨论<strong>malloc</strong>。</p>
<p>在C++程序中进行内存回收的方式有<strong>全局变量自动回收</strong>、<strong>delete、free回收</strong>、<strong>RAII通过析构函数自动回收</strong>等方式</p>
<p>对于<strong>堆</strong>上的资源，由于上面提到的<strong>效率</strong>和<strong>内存碎片</strong>问题，C++不会直接向堆申请资源，而是借助<strong>malloc</strong>函数来向<strong>系统</strong>申请资源。</p>
<p><strong>2）malloc内存分配机制</strong></p>
<p><strong>malloc</strong>属于<strong>标准库用于接口操作层</strong>，而用户调用<strong>malloc接口</strong>属于在<strong>用户层</strong>实现的，就像上面提到的，出于性能考虑，<strong>malloc</strong>是通过<strong>内存池</strong>的方式来管理内存的。</p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/memory_malloc.png"></p>
<p><strong>malloc</strong>的实现机制简单来说是，当我们申请一块如8B内存时，会实际上向<strong>系统</strong>申请一块更大的如1M内存，然后后面申请内存时都是从这1M内存中分配，当这1M内存不够时，再向系统申请1M内存。同时<strong>malloc</strong>内部还尝试通过<strong>空闲链表</strong>的设计方式来<strong>减少内存碎片</strong>。</p>
<p>其中最主要的分配内存思想是<strong>分配时会搜索空闲链表，找到第一个大于等于所需空间的空闲区块</strong>来进行分配，并根据<strong>不同的编译器</strong>具有不同的分配方式（一般不同编译器平台用的都是不同的内存分配算法）：</p>
<ul>
<li>如windows下的采用的是微软的一套方案</li>
<li>Linux下gcc用的<strong>glibc</strong>采用的内存分配器是<strong>ptmalloc</strong></li>
</ul>
<p><strong>malloc的优点：减少内存碎片</strong></p>
<p>malloc 只分配几种固定大小的内存块，可以减少外部碎片。</p>
<p><strong>malloc的缺点：多线程下性能问题</strong></p>
<ul>
<li>malloc的分配区有<strong>互斥锁</strong>来保证线程安全，但是进程中多个线程是<strong>共享</strong>一个malloc的分配区的，加锁的<strong>时间代价</strong>高。</li>
<li>由于需要查找合适的空闲区块，因此还有<strong>查找</strong>耗时的问题。</li>
</ul>
<h2 id="经典内存池的设计">4.2 经典内存池的设计</h2>
<h3 id="设计思路">4.2.1 设计思路</h3>
<p>最基础的内存池设计类似于<strong>malloc</strong>的设计，主要包括<strong>内存分配</strong>和<strong>内存释放</strong>两个操作。操作是由<strong>空闲链表</strong>来实现的。</p>
<ul>
<li><p>首先是提前向<strong>OS</strong>申请一块<strong>大内存</strong>，然后将这块内存均分成<strong>小块</strong>（后面优化可以分割成不同大小的内存块）</p></li>
<li><p>用链表表头<code>freeNodeHead</code>来存储<strong>空闲内存块</strong>，当用户申请内存时，就从<code>freeNodeHead</code>中取出一块内存块分配给用户</p></li>
<li><p>分割后的内存块通过链表组成<strong>内存节点</strong></p></li>
<li><p>每次分配内存时从<strong>空闲链表</strong>中取出一个<strong>头节点，时间复杂度为O(1)</strong></p></li>
<li><p>每次释放内存时将<strong>内存节点</strong>插入到<strong>空闲链表</strong>的<strong>头部</strong>，时间复杂度为O(1)</p></li>
<li><p>当空间不够用时，再向<strong>OS</strong>申请一块<strong>大内存</strong></p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/memory_pool.png"></p></li>
</ul>
<h3 id="内存池的结构体设计">4.2.2 内存池的结构体设计</h3>
<h4 id="变量">1）变量</h4>
<ul>
<li>申请的内存块头指针：<code>pBlockHeader</code>
<ul>
<li>内存池可以申请<strong>多块内存</strong></li>
</ul></li>
<li>上述每个内存块的<strong>空闲链表</strong>头指针：<code>pFreeNodeHead</code>
<ul>
<li>每个内存块可以被分割成更小的内存</li>
<li>每个内存块的<strong>空闲链表</strong>都是<strong>独立</strong>的</li>
</ul></li>
</ul>
<p>节点间的关系如下：</p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/memory_pool.png"></p>
<h4 id="结构体">2）结构体</h4>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/StructNode.png"></p>
<ul>
<li><strong>内存块结构体</strong>：<code>MemoryBlock</code>
<ul>
<li>包括<strong>内存块</strong>的<strong>所有空闲节点</strong>和<strong>空闲链表</strong>的<strong>头指针</strong>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    MemBlock *pNext;</span><br><span class="line">    FreeNode data[NumofObjects];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><strong>空闲节点结构体</strong>：<code>FreeNode</code>
<ul>
<li>包括<strong>空闲节点</strong>的<strong>数据</strong>和<strong>下一个空闲节点</strong>的<strong>指针</strong>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FreeNode</span> &#123;</span></span><br><span class="line">    FreeNode* pNext;</span><br><span class="line">    <span class="keyword">char</span> data[ObjectSize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="tcmlloc内存池">4.3 tcmlloc内存池</h2>
<p>tcmalloc 是 Google
开发的内存分配器，在<strong>多线程</strong>场景下性能表现比<strong>malloc</strong>更好。</p>
<p>主要表现在<strong>tcmalloc</strong>会为每个单独的线程申请一块<strong>独享内存空间</strong>，在线程级实现了缓存，使得用户在申请内存时大多情况下是<strong>无锁内存分配</strong>。</p>
<h3 id="tcmalloc的架构">4.3.1 tcmalloc的架构</h3>
<p><strong>tcmalloc</strong>的架构在应用层由上至下主要包括：多个<strong>Thread-cache线程缓存</strong>、一个<strong>Central-cache中央缓存</strong>和一个<strong>Page-cache页缓存</strong>三部分。</p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/tcmalloc.png"></p>
<ul>
<li><strong>Thread-cache线程缓存</strong>：每个线程都有一个<strong>线程缓存</strong>，用于存储<strong>小块内存</strong>，线程在申请内存时优先从<strong>线程缓存</strong>中申请，如果<strong>线程缓存</strong>中没有内存，那么再从<strong>中央缓存</strong>中申请。
<ul>
<li>由于<strong>线程缓存</strong>是<strong>独享</strong>的，因此<strong>线程缓存</strong>是<strong>无锁</strong>的。</li>
</ul></li>
<li><strong>Central-cache中央缓存</strong>：用于存储<strong>大块内存</strong>，<strong>线程缓存</strong>中没有内存时会从<strong>中央缓存</strong>中申请。
<ul>
<li><strong>中央缓存</strong>是<strong>共享</strong>的，因此需要<strong>加锁</strong>。</li>
<li>但是<strong>tcmalloc</strong>设计中，用<strong>哈希桶</strong>来减少<strong>锁竞争</strong>，每个<strong>哈希桶</strong>对应一个<strong>锁</strong>，因此<strong>锁竞争</strong>的概率会降低。</li>
</ul></li>
<li><strong>Page-cache页缓存</strong>：用于存储<strong>大块内存</strong>，<strong>中央缓存</strong>中没有内存时会从<strong>页缓存</strong>中申请。
<ul>
<li><strong>页缓存</strong>是<strong>共享</strong>的，且为串行方式，每次仅有一个线程可以访问，因此<strong>页缓存</strong>是<strong>有锁</strong>的。</li>
</ul></li>
</ul>
<h3 id="tcmalloc的性能优化">4.3.2 tcmalloc的性能优化</h3>
<h4 id="效率优化">1）效率优化</h4>
<p><strong>查找时间优化</strong></p>
<p>为了减少<strong>查找合适内存块的时间</strong>，<strong>tcmalloc</strong>采用了<strong>哈希桶</strong>的方式来设计内存块的分割：</p>
<p>前面讲到分割一块<strong>内存块</strong>是<strong>线性</strong>的，而且首次分割是等值的。而<strong>tcmalloc</strong>通过<strong>空间换时间</strong>的方式，将<strong>内存块</strong>分割成<strong>不同大小</strong>的内存块，然后将这些内存块放到<strong>哈希桶</strong>中，这样在分配内存时就可以<strong>直接按照对应大小找到合适的内存块</strong>，而不需要<strong>线性查找</strong>。</p>
<p>这里大小不同是按照<strong>2的幂次</strong>来分割的，如<code>16</code>、<code>32</code>、<code>64</code>等。</p>
<p><img src="/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/hashCache.png"></p>
<p><strong>多线程竞争优化</strong></p>
<ul>
<li><strong>线程缓存</strong>独享的无锁机制</li>
<li><strong>中央缓存</strong>采用<strong>哈希桶</strong>来减少<strong>锁竞争</strong>（多线程访问同一个哈希桶的概率降低）</li>
<li><strong>加锁</strong>使用更高效的<strong>自旋锁</strong>（自旋锁减少上下文切换、持锁时间短）</li>
</ul>
<h4 id="减少内存碎片">2）减少内存碎片</h4>
<p><code>central cache</code>释放回一个span，则依次寻找<code>page cache</code>中span所管理的页号的前后页号的页有没有空闲，看是否可以<strong>合并</strong>，如果合并继续向前寻找。这样就可以将切小的内存合并收缩成大的span，减少内存碎片。</p>
<h3 id="tcmalloc的缺点">4.3.3 tcmalloc的缺点</h3>
<p><strong>所需内存较大</strong>的服务时，独享<code>Thread-cache</code>保守的小内存空间会失去意义，这种情况下当请求量上来，锁冲突严重，CPU使用率将指数暴增。</p>
<p>实际生成环境我们可以选择用<strong>jemalloc</strong>。</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/m0_62782700/article/details/135443352?spm=1001.2014.3001.5502">【项目】九万字手把手教你写高并发内存池（化简版tcmalloc）</a></p>
<p>参考：<a href="https://blog.csdn.net/K346K346/article/details/49538975?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%2249538975%22%2C%22source%22%3A%22m0_46220956%22%7D">C++
内存池介绍与经典内存池的实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>C++知识点</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP协议的迭代（HTTP：应用层）</title>
    <url>/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h2 id="一从浏览器输入url到页面显示的过程">一、从浏览器输入URL到页面显示的过程</h2>
<h3 id="url到显示的全过程">1.1 URL到显示的全过程</h3>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/URL_to_display.png"></p>
<ul>
<li><strong>URL解析</strong>：浏览器解析URL，得到服务器的域名（www.baidu.com）和端口号，以及请求资源的路径
<ul>
<li>在<strong>缓存</strong>中<strong>找得到</strong>该域名对应的IP地址：直接访问服务器发送请求</li>
<li>在<strong>缓存</strong>中<strong>找不得到</strong>该域名：发起<strong>DNS迭代查询</strong>，得到服务器的IP地址</li>
</ul></li>
<li><strong>DNS域名解析</strong>：<strong>客户端</strong>发起<strong>迭代查询</strong>；<strong>DNS服务器</strong>之间通过<strong>递归查询</strong>得到域名对应的IP地址
<ul>
<li>浏览器 ---&gt; 本地DNS</li>
<li>本地DNS ---&gt; 根DNS ---&gt;
向本地DNS<strong>返回顶级DNS</strong>的IP地址</li>
<li>本地DNS ---&gt; 顶级DNS ---&gt;
向本地DNS<strong>返回权威DNS</strong>的IP地址</li>
<li>本地DNS ---&gt; 权威DNS ---&gt;
向本地DNS<strong>返回域名对应的IP地址</strong></li>
</ul></li>
<li><strong>客户端发起TCP连接</strong>：三次握手</li>
<li><strong>客户端发送HTTP请求</strong>：请求报文</li>
<li><strong>服务器发送HTTP响应</strong>：响应<strong>报文</strong>与<strong>状态码</strong></li>
<li><strong>浏览器解析渲染页面</strong>：解析HTML、CSS、JS等文件</li>
<li><strong>客户端发起断开TCP连接</strong>：四次挥手</li>
</ul>
<h3 id="dns域名解析">1.2 DNS域名解析</h3>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/DNS.png"></p>
<ul>
<li><strong>DNS域名解析</strong>：<strong>客户端</strong>发起<strong>迭代查询</strong>；<strong>DNS服务器</strong>之间通过<strong>递归查询</strong>得到域名对应的IP地址
<ul>
<li>浏览器 ---&gt; 本地DNS</li>
<li>本地DNS ---&gt; 根DNS ---&gt;
向本地DNS<strong>返回顶级DNS</strong>的IP地址</li>
<li>本地DNS ---&gt; 顶级DNS ---&gt;
向本地DNS<strong>返回权威DNS</strong>的IP地址</li>
<li>本地DNS ---&gt; 权威DNS ---&gt;
向本地DNS<strong>返回域名对应的IP地址</strong></li>
</ul></li>
</ul>
<p>DNS域名解析过程如下：</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/DNS2.png"></p>
<p><strong>DNS可能出现的一些网络攻击问题：</strong></p>
<ul>
<li><strong>DNS劫持</strong>：黑客劫持DNS服务器并<strong>篡改解析结果</strong>，使用户访问的网站<strong>跳转到恶意网站</strong>
<ul>
<li>解决：换个<strong>DNS服务器</strong>，躲过被劫持的<strong>DNS服务器</strong></li>
</ul></li>
<li><strong>DNS污染</strong>：黑客监听某些DNS查询，并伪装成目标服务器返回虚假结果（禁用google就是通过DNS污染实现的）
<ul>
<li>解决：直接在本机绑定hosts绕过DNS，或者更换成没被污染的DNS服务器</li>
</ul></li>
</ul>
<h3 id="正向代理和反向代理">1.3 正向代理和反向代理</h3>
<ul>
<li><strong>正向代理</strong>：代理客户端，<strong>向服务端隐藏客户端</strong>的真实IP地址
<ul>
<li>如平时通过VPN访问外网使用的技术就是正向代理</li>
</ul></li>
<li><strong>反向代理</strong>：代理服务器，<strong>向客户端隐藏服务器</strong>的真实IP地址
<ul>
<li>如Nginx就是一个反向代理服务器</li>
</ul></li>
</ul>
<h2 id="二http协议的特点">二、HTTP协议的特点</h2>
<h3 id="web构建的技术">2.1 Web构建的技术</h3>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/Web_build.png"></p>
<h3 id="http1http1.0与http1.1">2.2 HTTP1：HTTP1.0与HTTP1.1</h3>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTP1.png"></p>
<h3 id="http2">2.3 HTTP2</h3>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTP2.png"></p>
<p>HTTP2的很大特点是采用了<strong>stream</strong>技术，可以<strong>同时发送多个请求</strong>，并且<strong>不需要按照顺序来发送</strong>，这样可以<strong>提高传输效率</strong>，并且<strong>减少延迟</strong>。</p>
<p>stream中一个TCP连接可以有多个stream，每个stream都有一个唯一的标识符;一个stream中可以有多个message；每个message可以有多个frame。frame是HTTP2的最小单位。</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTP2_stream.png"></p>
<h3 id="http3">2.4 HTTP3</h3>
<p>HTTP3是基于UDP的，使用了<strong>QUIC</strong>协议，可以<strong>减少延迟</strong>，并且<strong>提高传输效率</strong>。</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTP3.png"></p>
<h3 id="http1http3的应用层到链路层的区别">2.5
HTTP1~HTTP3的应用层到链路层的区别</h3>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTP1~HTTP3.jpg"></p>
<h2 id="三http缓存">三、HTTP缓存</h2>
<p>客户端中存储缓存副本，<strong>有效的缓存副本</strong>在下一次可以<strong>直接使用</strong>而<strong>不需要再次请求服务器</strong></p>
<p>HTTP实现缓存的方式有：强制缓存和协商缓存</p>
<ul>
<li>强缓存：通过<strong>Cache-Control</strong>和<strong>Expires</strong>字段设置<strong>缓存时间</strong>，当缓存时间<strong>未过期</strong>时，直接使用缓存，<strong>不需要与服务器通信</strong></li>
<li>协商缓存：通过<strong>Last-Modified</strong>和<strong>Etag</strong>字段，向服务器<strong>发送请求</strong>，服务器<strong>判断资源是否能直接使用缓存</strong></li>
</ul>
<p>HTTP实现缓存的方式如下：</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTP_cache.png"></p>
<p>其中HTTP协商缓存的流程图如下：</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTP_cache_2.jpg"></p>
<h2 id="四https">四、HTTPS</h2>
<p>HTTPS是在HTTP的基础上加入了<strong>SSL/TLS</strong>协议，可以<strong>保证数据传输的安全性</strong>。具有数据加密、校验、身份认证等特点。</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/HTTPS.png"></p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/SSL.png"></p>
<h3 id="对称加密">4.1 对称加密</h3>
<p>对称加密是指<strong>加密</strong>和<strong>解密</strong>使用的是<strong>同一个密钥</strong>，加密和解密的速度非常快，但是密钥的安全是一个问题。</p>
<p>密钥安全问题是指：<strong>密钥的传输</strong>和<strong>存储</strong>是一个问题，如果<strong>密钥被泄露</strong>，那么加密的数据也就不安全了。</p>
<p>所以如果要安全使用对称加密，我们需要有一个保证密钥被安全传输到双方的措施，这个措施我们后面会讲，就是通过<strong>非对称加密</strong>对密钥进行加密，然后将加密后的密钥传输给对方，这样才能保证后续通信过程中的<strong>密钥安全</strong>。</p>
<h3 id="非对称加密rsa">4.2 非对称加密RSA</h3>
<p>非对称加密是指加密和解密使用的是<strong>不同的密钥</strong>，加密使用的是<strong>公钥</strong>，解密使用的是<strong>私钥</strong>。</p>
<h4 id="rsa加密过程公钥对密文进行加密如下">RSA加密过程（公钥对密文进行加密）如下：</h4>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_public.png"></p>
<p>也就是说RSA加密是对明文进行<code>E</code>次方后求对<code>N</code>的余数，得到密文。</p>
<p>从公式可以知道，<code>E</code>和<code>N</code>是公钥，所有人都可以获得，并通过公钥对信息进行加密，所以我们用<code>(E,N)</code>来表示公钥。</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_public_key.png"></p>
<p>神奇的点在于，只有拥有对应<strong>私钥</strong>的才能对密文进行解密，得到明文。（一般私钥都在服务端处保存）</p>
<h4 id="rsa解密过程私钥对密文进行解密如下">RSA解密过程（私钥对密文进行解密）如下：</h4>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_private.png"></p>
<p>也就是说RSA解密是对密文进行<code>D</code>次方后求对<code>N</code>的余数，得到明文，所以我们用<code>(D,N)</code>来表示私钥。</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_private_key.png"></p>
<h4 id="生成密钥对的过程">生成密钥对的过程</h4>
<p>生成密钥对需要求<code>N</code>、<code>L</code>、<code>E</code>、<code>D</code>的值</p>
<ul>
<li>求<code>N</code>的值：<code>N</code>是两个大质数<code>p</code>和<code>1</code>的乘积，当<code>p</code>和<code>q</code>都是大质数时，<code>N</code>的值很难被分解，也就是基本不可能从公钥<code>N</code>的值反推出<code>p</code>和<code>q</code>的值（所以不能反推出私钥的值）
<ul>
<li><code>N = p * q</code></li>
</ul></li>
<li>求<code>L</code>的值：<code>L</code>是<code>p-1</code>和<code>q-1</code>的最小公倍数
<ul>
<li><code>L = LCM(p-1, q-1)</code></li>
</ul></li>
<li>求<code>E</code>的值：<code>E</code>是一个小于<code>L</code>的数，且<code>E</code>和<code>L</code>的最大公约数为1</li>
<li>求<code>D</code>的值：<code>D</code>是<code>E</code>的逆元，即<code>E * D % L = 1</code></li>
</ul>
<p>求完之后，我们就得到了公钥<code>(E,N)</code>和私钥<code>(D,N)</code>。</p>
<p><strong>我们只需要记得私钥<code>D</code>的值是几乎不可能被通过公钥反推回来的就行，且通过公钥加密的密文只有对应的私钥才能解密。</strong></p>
<p>RSA神奇的点就在于，<strong>私钥</strong>可以<strong>解密公钥</strong>加密的密文，而<strong>公钥</strong>可以解密<strong>私钥</strong>加密的密文。但是由于公钥是公开的，所以我们一般不用私钥进行加密（不然所有拥有公钥的都能解密数据了），只有在<strong>数字签名</strong>的时候才会用到私钥进行加密。</p>
<h4 id="采用rsa除了加密外还可以用于数字签名">采用RSA除了加密外，还可以用于数字签名</h4>
<p>数字签名其实是加密的反过程，是为了<strong>验证服务端的身份</strong>（也就是说数据是不是从服务端发送过来的）</p>
<p>最主要的过程是：<strong>服务端</strong>用<strong>私钥</strong>对数据进行<strong>加密</strong>（这里说加密其实不准确，我们可以称为<strong>签名</strong>），然后<strong>客户端</strong>用<strong>公钥</strong>对数据进行<strong>解密</strong>（这里说法也不准确，应该称为<strong>验证签名</strong>），如果解密后的数据和原数据一样（通过同步送过来的<strong>哈希值</strong>来判断是否一样），那么就说明数据是从服务端发送过来的。</p>
<p>数字签名的过程如下：</p>
<ul>
<li>服务端用私钥对<strong>原始消息的哈希值</strong>进行签名</li>
<li>发送给客户端：<strong>原始消息</strong>和<strong>签名</strong></li>
<li>客户端用公钥对<strong>签名</strong>进行解密，并计算同步发送过来的<strong>原始消息的哈希值</strong>，如果<strong>解密后的哈希值</strong>和<strong>同步发送过来的哈希值</strong>一样，那么就说明数据是从服务端发送过来的</li>
</ul>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_sign.jpg"></p>
<h3 id="https采用的混合加密模式">4.3 HTTPS采用的混合加密模式</h3>
<p>HTTPS采用的是<strong>混合加密模式</strong>，即<strong>对称加密</strong>和<strong>非对称加密</strong>结合使用。</p>
<ul>
<li><strong>非对称加密</strong>：用于<strong>传输对称加密的密钥</strong>
<ul>
<li>服务端发送自己的<strong>数字证书</strong>给客户端，请求<strong>身份认证</strong></li>
<li>客户端用CA认证过的服务端的<strong>公钥</strong>对服务端的<strong>数字证书</strong>进行验证（防止中间人发送伪造的证书来伪造服务端）</li>
<li>客户端验证通过后用<strong>公钥</strong>对自己随机生成的<strong>对称加密的密钥</strong>进行加密，然后发送给服务端</li>
<li>由于只有服务端有<strong>私钥</strong>，所以只有服务端能解密得到<strong>对称加密的密钥</strong>，所以此时只有服务端能解开并得到<strong>对称加密的密钥</strong></li>
</ul></li>
<li><strong>对称加密</strong>：客户端和服务端验证完并获取安全的<strong>对称加密的密钥</strong>后，就用于后续的<strong>传输数据</strong></li>
</ul>
<p>为什么要采用混合加密模式呢？</p>
<p>因为<strong>对称加密</strong>的速度很快，但是<strong>密钥安全</strong>是个问题，所以我们首次建立TLS连接的时候，采用<strong>非对称加密</strong>用于<strong>传输对称加密的密钥</strong>，可以确保<strong>密钥的安全</strong>。然后后面正常通信的时候使用这个<strong>安全的密钥</strong>，就可以保证在安全情况下进行快速通信。</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_mix.jpg"></p>
<h3 id="https的数字证书">4.4 HTTPS的数字证书</h3>
<p>数字证书是由权威的CA机构颁发的，用于<strong>证明服务端身份</strong>的一种证书。</p>
<p>如果没有权威公开的CA机构颁发的数字证书，那么就会出现<strong>中间人攻击</strong>，即中间人有自己的公钥和私钥，然后伪造了一个数字证书，客户端用伪造的公钥验证通过后，就会误认为是服务端发送的数据，这样就会出现中间人攻击<strong>安全问题</strong>。</p>
<p>而如果通过<strong>CA的私钥对服务器的公钥</strong>进行数字签名，那么这个证书就是只能由权威的CA公钥进行解密验证，所以客户端可以用CA的公钥验证服务端发来的数字证书，验证通过后才会从发来的数据中获取服务端的<strong>公钥</strong>。SSL/TLS建立安全连接的过程如下：</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_certificate.jpg"></p>
<p>CA能确保数据安全的图解：</p>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RSA_certificate_2.png"></p>
<h1 id="五rpc">五、RPC</h1>
<h2 id="rpc的通信流程">5.1 RPC的通信流程</h2>
<p>RPC是一种<strong>远程调用</strong>框架，目的是使得<strong>调用远程服务</strong>和<strong>调用本地</strong>一样简单，而开发者更专注于业务开发，不需要考虑<strong>网络编程</strong>等细节。</p>
<p>RPC实现的主要流程为：</p>
<p>前提：服务提供端向<strong>注册中心</strong>注册接口服务</p>
<ul>
<li><strong>注册中心</strong>根据<strong>服务名</strong>找到<strong>服务提供端</strong>的<strong>IP地址</strong>和<strong>端口号</strong></li>
<li><strong>Netty客户端</strong>将数据<strong>序列化</strong>成<strong>二进制格式</strong>然后请求网络调用</li>
<li><strong>服务端</strong>在TCP通道中接收数据，将<strong>二进制数据</strong>反序列后分割成<strong>接口地址和参数对象</strong>，然后通过<strong>反射</strong>找到接口然后执行调用</li>
<li><strong>服务端</strong>处理完接口后将结果<strong>序列化</strong>成<strong>二进制数据</strong>返回给<strong>Netty客户端</strong></li>
<li><strong>Netty客户端</strong>接收到<strong>二进制数据</strong>后将数据<strong>反序列化</strong>成<strong>结果对象</strong></li>
</ul>
<p><img src="/2024/03/09/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E8%BF%AD%E4%BB%A3/RPCStructure.png" width="70%"></p>
<h2 id="rpc与http的区别">5.2 RPC与HTTP的区别</h2>
<ul>
<li><p>1）RPC和HTTP都是基于TCP封装的协议</p></li>
<li><p>2）<strong>RPC适用于C/S模式</strong>，比如PC上用的<strong>电脑管家等软件、公司内部微服务通信</strong>只需要跟自家的服务器通信；而<strong>HTTP适用于B/S模式</strong>，比如<strong>浏览器</strong>需要和<strong>其他公司的服务器</strong>通信，这时候就需要一个统一的协议也就是HTTP了。</p></li>
<li><p>3）<strong>RPC域名获取</strong>时一般都是有<strong>专门的中间服务</strong>去获取，而<strong>HTTP</strong>更统一于使用<strong>DNS</strong>去获取域名</p></li>
<li><p>4）<strong>RPC</strong>跟<strong>HTTP1.1</strong>一样保持的长连接，此外，<strong>RPC</strong>实现<strong>连接池</strong>来复用连接（不少编程语言在HTTP中也会用连接池复用）</p></li>
<li><p>5）<strong>RPC</strong>一般通过Protobuf实现序列化，而<strong>HTTP</strong>一般通过JSON实现序列化，Protobuf序列化后的数据量更小，传输效率更高</p></li>
</ul>
<p>因此不难看出，RPC定制化程度比HTTP更高</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>DELL系统重装教程</title>
    <url>/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>重装系统记得把<strong>重要文件备份</strong>，建议tb买个便宜的号备份到百度网盘，虽然一般重装只有C盘文件会全部被覆盖，不影响DEF盘，但是把重要文件都备份好总是没错的；</p>
<p>写个txt文件记录<strong>需要下载的软件</strong>，便于重装系统后下载软件，生产力软件（VScode、hexo博客搭建等）要记录下来，真的对以后重新安装软件的环境配置很有用，能节省很多时间！</p>
<p>本文主要针对电脑可以使用下，重装系统清理C盘的情况。</p>
<h1 id="系统重装">系统重装</h1>
<h2 id="一重装前软件下载">一、重装前软件下载</h2>
<ul>
<li>软件下载步骤主要是为了制作系统U盘，因此如果电脑无法正常使用，本步骤可以用其他电脑完成。</li>
<li>本步骤需要准备一个U盘，注意安装系统到U盘会格式化U盘，因此需要提前备份好U盘。</li>
<li>完成该步骤将得到一个系统盘，因此只要不删除U盘内的系统，以后重装系统可以直接跳过一步骤，从二开始。</li>
</ul>
<h3 id="下载系统到电脑">1.下载系统到电脑</h3>
<p>用迅雷下载下面的种子到电脑中，得到win10系统的iso镜像文件</p>
<pre><code>magnet:?xt=urn:btih:5C66F9BE1E46D0D4F7EC418D54C3A3FB03679D6D&amp;dn=zh-cn_windows_10_business_editions_version_21h1_updated_sep_2021_x64_dvd_023d42d3.iso&amp;xl=5709488128</code></pre>
<h3 id="下载系统到u盘会将u盘格式化">2.下载系统到U盘（会将U盘格式化）</h3>
<ul>
<li><p>用下面链接将<a href="http://rufus.ie/zh/">rufus</a>软件下载到电脑中</p></li>
<li><p>按win + R，然后输入命令diskmgmt.msc并点击回车键</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/1.png" width="80%" height="80%"></p>
<p>得到<strong>磁盘管理</strong>的界面，将界面截图下来备用，便于重装时系统的分区</p>
<p>在磁盘管理下面的磁盘0处<strong>右键-&gt;卷</strong>截图该页面备用</p>
<p>（请确定本机的系统是装在C盘的）</p></li>
<li><p><strong>插入U盘</strong></p></li>
<li><p>先把杀毒软件关了，避免误杀，然后打开双击下载好的rufus，在rufus界面中完成剩下的设置选择</p>
<ul>
<li><p><strong>设备</strong>：选择你的U盘</p></li>
<li><p><strong>引导类型选择</strong>：点击选择按钮选择1中得到的iso镜像文件</p></li>
<li><p><strong>镜像选项</strong>：标准Windows安装</p></li>
<li><p><strong>分区类型</strong>：GPT</p></li>
<li><p><strong>目标系统类型</strong>：UEFI（非CSM）</p></li>
<li><p><strong>卷标</strong>：默认就行</p></li>
<li><p><strong>文件系统</strong>：NTFS</p></li>
<li><p><strong>簇大小</strong>：选带默认的那个</p></li>
<li><p>上述步骤最后在Rufus中表现如下图所示：</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/5.png" width="80%" height="80%"></p></li>
</ul></li>
<li><p>rufus设置完成后点击<strong>开始</strong>，需要等待挺久时间的，等待到100%后系统将变成对应的Win10系统U盘，同时该步骤会把U盘格式化。</p></li>
</ul>
<h2 id="二重装系统">二、重装系统</h2>
<ul>
<li><p><strong>插入U盘</strong></p></li>
<li><p>桌面搜索打开<strong>Windows更新设置</strong>界面，选<strong>恢复</strong>，点击<strong>立即重新启动</strong>按钮</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/7.png" width="80%" height="80%"></p></li>
<li><p>选择<strong>疑难解答</strong>-&gt;<strong>高级选项</strong>-&gt;<strong>UEFI固件设置</strong>-&gt;<strong>重启</strong>，得到下面的界面</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/12.jpg"></p></li>
<li><p>在得到的页面中进行下述操作</p>
<ul>
<li><p>选Advanced Boot Options，取消勾选Enable Legacy Option
ROMs</p></li>
<li><p>Secure Boot Enable，选择Enabled（Secure Boot Enable在Secure
Boot里面）</p></li>
<li><p>保存后退出重启，重启后在黑色界面时疯狂按f12（不同电脑品牌需要按的快捷键不同，可百度查询需要按得快捷键）</p></li>
<li><p>得到如下界面</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/13.jpg"></p></li>
<li><p>UEFI
BOOT选第二项（既选择U盘进入，我这里是uefi：sandisk），然后按enter进入</p></li>
<li><p>得到如下界面</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/15.jpg" width="100%" height="100%"></p></li>
<li><p>点击<strong>下一步</strong>-&gt;<strong>现在安装</strong>-&gt;<strong>专业版</strong>-&gt;<strong>下一步</strong>-&gt;<strong>自定义：仅安装Windows(高级)(C)</strong></p></li>
</ul></li>
<li><p>在得到的界面中进行分区操作（确保重要文件已拷贝）</p>
<ul>
<li><p>删除下列分区(逐个点击后按下方的<strong>删除</strong>按钮)</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/19.png" width="80%" height="80%"></p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/20.png" width="80%" height="80%"></p></li>
<li><p>点击<strong>驱动器 1
未分配的空间</strong>，下方选择<strong>新建</strong>按钮</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/23.jpg" width="80%" height="80%"></p></li>
<li><p>大小调整到最大，然后点击上图的应用，出现个弹窗点确定就行</p></li>
<li><p>分区那往下滑<strong>选择驱动器 1
分区3</strong>，也就是主分区类型的分区，点击后按下一步，系统开始进行重新安装，等待一会即可</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/25.jpg" width="80%" height="80%"></p></li>
</ul></li>
<li><p>最后安装完后微软还会继续采集信息，这部分按自己的需求设置就行</p></li>
</ul>
<h2 id="三激活系统">三、激活系统</h2>
<ul>
<li><p>装完进入桌面后，用win10的更新功能安装驱动</p>
<p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/27.png" width="80%" height="80%"></p></li>
<li><p>用下面链接下载软件进行Win10的激活</p>
<p><a href="https://mp.weixin.qq.com/s/TkAiq6naVPGBmQZU4PuPFg">激活Win10</a></p>
<p>链接：https://pan.baidu.com/s/1s4yF2aSmuAaaqxrWSRWE9g
提取码：<code>5l32</code></p></li>
<li><p>自带的office的软件不太全，你想重装可以从这个网站下</p>
<p><a href="https://msdn.itellyou.cn/">Office重装</a></p>
<p>office的激活同理可以用Win10的激活软件进行激活</p></li>
</ul>
<h2 id="四windows一些奇奇怪怪的问题解决">四、Windows一些奇奇怪怪的问题解决</h2>
<ul>
<li><p>USB口损坏导致电涌过大</p>
<ul>
<li><p><img src="/2022/02/03/DELL%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A3%85%E6%95%99%E7%A8%8B/USBError.png"></p></li>
<li><p>如果老是弹出USB电流过大的提示，可以进入<code>设置</code>-&gt;<code>设备</code>-&gt;<code>USB</code>，然后把<code>如果在连接到USB设备时出现问题，请通知我</code>的选项关掉，这样就不会再频繁弹出<code>USB电流过大</code>的提示了。</p></li>
<li><p>但是上面的方法只是解决了提示的问题，如果USB口真的损坏了，那么还是需要维修的。最省钱的方法就是把坏掉的USB口用绝缘胶带封住，强制禁用这个USB口就行。</p></li>
</ul></li>
</ul>
<h1 id="结语">结语</h1>
<p>至此，Win10的安装就全部完成了，正常来说除了C盘外其它盘的文件都还在，可以开始重新安装自己需要的软件了，该重装教程还有不完善的地方，后续会继续补充改正~</p>
<p>本文涉及的软件资源可以从百度网盘获取</p>
<ul>
<li>链接：https://pan.baidu.com/s/1AfsgEPr0I22hDr6yQZ1wUg
提取码：<code>i7g5</code></li>
</ul>
]]></content>
      <categories>
        <category>重装-环境配置-计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/2024/04/29/KMP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>最主要是掌握KMP算法的<strong>next数组</strong>的构建过程，具体的解法看参考的文章，讲得很好</p>
</blockquote>
<h1 id="一kmp算法next构建">一、KMP算法Next构建</h1>
<p><img src="/2024/04/29/KMP%E7%AE%97%E6%B3%95/createNext.png" width="70%"></p>
<h1 id="二代码实现c">二、代码实现（C++）</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;next, string templateStr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//后缀结尾</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//前缀结尾</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> str_size = templateStr.<span class="built_in">size</span>();</span><br><span class="line">	next = vector&lt;<span class="keyword">int</span>&gt;(str_size);</span><br><span class="line">	next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; str_size; ++i) &#123;</span><br><span class="line">		<span class="comment">//前缀跟后缀不相等的话，说明得往前查找</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; templateStr[j] != templateStr[i]) &#123;</span><br><span class="line">			j = next[j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//前缀跟后缀相等的话，说明可以往后移一位了</span></span><br><span class="line">		<span class="keyword">if</span> (templateStr[j] == templateStr[i]) &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//构建当前后缀的最长前缀</span></span><br><span class="line">		next[i] = j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; next, string templateStr, string searchStr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">//searchStr的</span></span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//templateStr的</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; i &lt; searchStr.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		<span class="comment">//跟模板不相等则跳转到模板对应的位置</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; templateStr[j] != searchStr[i]) &#123;</span><br><span class="line">			j = next[j<span class="number">-1</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//跟模板相等则模板指针加一，说明可以对下一个字符进行判断</span></span><br><span class="line">		<span class="keyword">if</span> (templateStr[j] == searchStr[i]) &#123;</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//已经找全了（模板指针指向末尾）</span></span><br><span class="line">		<span class="keyword">if</span> (j == templateStr.<span class="built_in">size</span>()) <span class="keyword">return</span> i-templateStr.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//没找到</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三测试">三、测试</h1>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; next;</span><br><span class="line">	string s = <span class="string">&quot;ababaca&quot;</span>;</span><br><span class="line"></span><br><span class="line">	myKMP kmp;</span><br><span class="line">	kmp.<span class="built_in">getNext</span>(next, s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">		cout &lt;&lt; next[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; kmp.<span class="built_in">KMP</span>(next, s, <span class="string">&quot;bacbababadababacambabacaddababacasdsd&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四相关leetcode题目">四、相关leetcode题目</h1>
<ul>
<li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28.
实现 strStr()</a></li>
<li><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">459.
重复的子字符串</a></li>
</ul>
<h1 id="总结">总结</h1>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/lijingran/p/8619711.html">字符串匹配KMP算法的讲解C++</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>LOVE_打火机与公主裙</title>
    <url>/2022/11/15/LOVE/</url>
    <content><![CDATA[
<!DOCTYPE html>
<!-- saved from url=(0062)file:///D:/OneDrive/%E6%A1%8C%E9%9D%A2/%E7%88%B1%E5%BF%83.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	<title></title>
<style>
  *{
    padding: 0;
    margin: 0;
  }
  html, body {
  height: 100%;
  padding: 0;
  margin: 0;
  background: #000;
}
canvas {
  position: absolute;
  width: 100%;
  height: 100%;
}
.aa{
  position: fixed;
  left: 50%;
  bottom: 10px;
  color: #ccc
}
</style></head>

<body>
    <canvas id="pinkboard" width="989" height="805"></canvas>
 
    <script>
       
/*
 * Settings
 */
var settings = {
  particles: {
    length:   500, // maximum amount of particles
    duration:   2, // particle duration in sec
    velocity: 100, // particle velocity in pixels/sec
    effect: -0.75, // play with this for a nice effect
    size:      30, // particle size in pixels
  },
};
 
/*
 * RequestAnimationFrame polyfill by Erik M?ller
 */
(function(){var b=0;var c=["ms","moz","webkit","o"];for(var a=0;a<c.length&&!window.requestAnimationFrame;++a){window.requestAnimationFrame=window[c[a]+"RequestAnimationFrame"];window.cancelAnimationFrame=window[c[a]+"CancelAnimationFrame"]||window[c[a]+"CancelRequestAnimationFrame"]}if(!window.requestAnimationFrame){window.requestAnimationFrame=function(h,e){var d=new Date().getTime();var f=Math.max(0,16-(d-b));var g=window.setTimeout(function(){h(d+f)},f);b=d+f;return g}}if(!window.cancelAnimationFrame){window.cancelAnimationFrame=function(d){clearTimeout(d)}}}());
 
/*
 * Point class
 */
var Point = (function() {
  function Point(x, y) {
    this.x = (typeof x !== 'undefined') ? x : 0;
    this.y = (typeof y !== 'undefined') ? y : 0;
  }
  Point.prototype.clone = function() {
    return new Point(this.x, this.y);
  };
  Point.prototype.length = function(length) {
    if (typeof length == 'undefined')
      return Math.sqrt(this.x * this.x + this.y * this.y);
    this.normalize();
    this.x *= length;
    this.y *= length;
    return this;
  };
  Point.prototype.normalize = function() {
    var length = this.length();
    this.x /= length;
    this.y /= length;
    return this;
  };
  return Point;
})();
 
/*
 * Particle class
 */
var Particle = (function() {
  function Particle() {
    this.position = new Point();
    this.velocity = new Point();
    this.acceleration = new Point();
    this.age = 0;
  }
  Particle.prototype.initialize = function(x, y, dx, dy) {
    this.position.x = x;
    this.position.y = y;
    this.velocity.x = dx;
    this.velocity.y = dy;
    this.acceleration.x = dx * settings.particles.effect;
    this.acceleration.y = dy * settings.particles.effect;
    this.age = 0;
  };
  Particle.prototype.update = function(deltaTime) {
    this.position.x += this.velocity.x * deltaTime;
    this.position.y += this.velocity.y * deltaTime;
    this.velocity.x += this.acceleration.x * deltaTime;
    this.velocity.y += this.acceleration.y * deltaTime;
    this.age += deltaTime;
  };
  Particle.prototype.draw = function(context, image) {
    function ease(t) {
      return (--t) * t * t + 1;
    }
    var size = image.width * ease(this.age / settings.particles.duration);
    context.globalAlpha = 1 - this.age / settings.particles.duration;
    context.drawImage(image, this.position.x - size / 2, this.position.y - size / 2, size, size);
  };
  return Particle;
})();
 
/*
 * ParticlePool class
 */
var ParticlePool = (function() {
  var particles,
      firstActive = 0,
      firstFree   = 0,
      duration    = settings.particles.duration;
  
  function ParticlePool(length) {
    // create and populate particle pool
    particles = new Array(length);
    for (var i = 0; i < particles.length; i++)
      particles[i] = new Particle();
  }
  ParticlePool.prototype.add = function(x, y, dx, dy) {
    particles[firstFree].initialize(x, y, dx, dy);
    
    // handle circular queue
    firstFree++;
    if (firstFree   == particles.length) firstFree   = 0;
    if (firstActive == firstFree       ) firstActive++;
    if (firstActive == particles.length) firstActive = 0;
  };
  ParticlePool.prototype.update = function(deltaTime) {
    var i;
    
    // update active particles
    if (firstActive < firstFree) {
      for (i = firstActive; i < firstFree; i++)
        particles[i].update(deltaTime);
    }
    if (firstFree < firstActive) {
      for (i = firstActive; i < particles.length; i++)
        particles[i].update(deltaTime);
      for (i = 0; i < firstFree; i++)
        particles[i].update(deltaTime);
    }
    
    // remove inactive particles
    while (particles[firstActive].age >= duration && firstActive != firstFree) {
      firstActive++;
      if (firstActive == particles.length) firstActive = 0;
    }
    
    
  };
  ParticlePool.prototype.draw = function(context, image) {
    // draw active particles
    if (firstActive < firstFree) {
      for (i = firstActive; i < firstFree; i++)
        particles[i].draw(context, image);
    }
    if (firstFree < firstActive) {
      for (i = firstActive; i < particles.length; i++)
        particles[i].draw(context, image);
      for (i = 0; i < firstFree; i++)
        particles[i].draw(context, image);
    }
  };
  return ParticlePool;
})();
 
/*
 * Putting it all together
 */
(function(canvas) {
  var context = canvas.getContext('2d'),
      particles = new ParticlePool(settings.particles.length),
      particleRate = settings.particles.length / settings.particles.duration, // particles/sec
      time;
  
  // get point on heart with -PI <= t <= PI
  function pointOnHeart(t) {
    return new Point(
      160 * Math.pow(Math.sin(t), 3),
      130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
    );
  }
  
  // creating the particle image using a dummy canvas
  var image = (function() {
    var canvas  = document.createElement('canvas'),
        context = canvas.getContext('2d');
    canvas.width  = settings.particles.size;
    canvas.height = settings.particles.size;
    // helper function to create the path
    function to(t) {
      var point = pointOnHeart(t);
      point.x = settings.particles.size / 2 + point.x * settings.particles.size / 350;
      point.y = settings.particles.size / 2 - point.y * settings.particles.size / 350;
      return point;
    }
    // create the path
    context.beginPath();
    var t = -Math.PI;
    var point = to(t);
    context.moveTo(point.x, point.y);
    while (t < Math.PI) {
      t += 0.01; // baby steps!
      point = to(t);
      context.lineTo(point.x, point.y);
    }
    context.closePath();
    // create the fill
    context.fillStyle = '#ea80b0';
    context.fill();
    // create the image
    var image = new Image();
    image.src = canvas.toDataURL();
    return image;
  })();
  
  // render that thing!
  function render() {
    // next animation frame
    requestAnimationFrame(render);
    
    // update time
    var newTime   = new Date().getTime() / 1000,
        deltaTime = newTime - (time || newTime);
    time = newTime;
    
    // clear canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    
    // create new particles
    var amount = particleRate * deltaTime;
    for (var i = 0; i < amount; i++) {
      var pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
      var dir = pos.clone().length(settings.particles.velocity);
      particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
    }
    
    // update and draw particles
    particles.update(deltaTime);
    particles.draw(context, image);
  }
  
  // handle (re-)sizing of the canvas
  function onResize() {
    canvas.width  = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
  }
  window.onresize = onResize;
  
  // delay rendering bootstrap
  setTimeout(function() {
    onResize();
    render();
  }, 10);
})(document.getElementById('pinkboard'));
 
 
 
 
    </script>


</body></html>]]></content>
      <tags>
        <tag>杂货铺-休闲</tag>
      </tags>
  </entry>
  <entry>
    <title>Mine-重装系统后软件相关设置</title>
    <url>/2022/12/04/Mine-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一zotero设置">一、Zotero设置</h1>
<h2 id="恢复文献数据">1.1 恢复文献数据</h2>
<ul>
<li><p>首先拷贝Zotero中<strong>存放Data的路径</strong>中的所有内容到新电脑中（如果是重装系统可忽略），如本人存放于<code>E:\zotero files</code>，需要将该目录下的所有文件拷贝一份</p>
<p><img src="/2022/12/04/Mine-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/papers_local_zotero.png" width="50%" heigh="50%"></p></li>
<li><p>然后打开新下载的zotero软件，依次点击：<code>编辑(E)</code>-&gt;<code>首选项(N)</code>-&gt;<code>高级</code>-&gt;<code>文件和文件夹</code></p></li>
<li><p>点击<code>数据存储位置</code>的<code>自定义</code>选项，填入第一步Data的路径后点击<code>OK</code>，如本人存放于<code>E:\zotero files</code></p>
<p><img src="/2022/12/04/Mine-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/optional.png" width="50%" heigh="50%"></p></li>
<li><p>最后重启zotero软件</p></li>
</ul>
<h2 id="安装插件">1.2 安装插件</h2>
<ul>
<li><p>插件安装方式</p>
<ul>
<li><ol type="1">
<li>先下载相关插件的<code>.spi</code>文件</li>
</ol></li>
<li><ol start="2" type="1">
<li>在zotero软件中点击<code>工具(T)</code>-&gt;<code>插件</code>-&gt;<code>小齿轮</code>-&gt;<code>Install Add-on from file...</code>-&gt;<code>选择对应.spi文件</code>-&gt;<code>Install now</code>-&gt;<code>重启</code></li>
</ol></li>
</ul>
<p><img src="/2022/12/04/Mine-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/zotero_extensions1.png" width="50%" heigh="50%">
<img src="/2022/12/04/Mine-%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8E%E8%BD%AF%E4%BB%B6%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE/zotero_extensions_installnow.png" width="50%" heigh="50%"></p></li>
<li><p><a href="https://zotero-chinese.gitee.io/zotero-plugins/#/">zotero</a>插件镜像网站</p></li>
<li><p><a href="https://github.com/l0o0/jasminum/releases">jasminum</a>插件用于中文文献条目的自动抓取</p>
<ul>
<li>可通过github链接或搜索：https://github.com/l0o0/jasminum/releases</li>
</ul></li>
<li><p><a href="https://github.com/windingwind/zotero-pdf-translate/releases/tag/v0.9.4">pdf-translate</a>插件用于pdf便捷翻译</p>
<ul>
<li>可通过github链接或搜索：https://github.com/windingwind/zotero-pdf-translate/releases/tag/v2.0.3</li>
</ul></li>
</ul>
<h1 id="二浏览器设置">二、浏览器设置</h1>
<h2 id="开启实时字幕翻译功能">2.1 开启实时字幕翻译功能</h2>
<ul>
<li>谷歌：<code>设置</code>-&gt;<code>无障碍</code>-&gt;<code>实时字幕</code></li>
<li>Edge：<code>设置</code>-&gt;<code>辅助功能</code>-&gt;<code>实时字幕</code>（Edge102有该功能，Edge103没有）</li>
</ul>
<h2 id="安装插件-1">2.2 安装插件</h2>
<h1 id="三遇到软件无法被搜索到的情况">三、遇到软件无法被搜索到的情况</h1>
<p>如<code>everything</code>软件无法搜索到</p>
<ul>
<li><p>先在桌面对软件建立桌面快捷键</p></li>
<li><p>将快捷方式复制到<code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs</code></p></li>
</ul>
<p>参考自：https://blog.csdn.net/qq_40579464/article/details/105342847</p>
<h1 id="四qt安装">四、QT安装</h1>
<h2 id="配置msvc参考qt编程经验文章的配置方法">4.1
配置MSVC（参考“QT编程经验”文章的配置方法）</h2>
<h2 id="安装qt-creator5.12.6版本">4.2 安装QT Creator5.12.6版本</h2>
<p>参考：https://blog.csdn.net/qq_41453285/article/details/89853671</p>
<h2 id="配置mysql">4.3 配置MySQL</h2>
<p>参考：https://subingwen.cn/qt/sql-driver/ &amp;
https://zhuanlan.zhihu.com/p/188416607</p>
<pre><code>- LIBS += &quot;D:\Project\Wireless_communication_software\mysql_v8.0.32\MySQL Server 8.0\lib\libmysql.lib&quot;
- INCLUDEPATH += &quot;D:\Project\Wireless_communication_software\mysql_v8.0.32\MySQL Server 8.0\include&quot;
- DEPENDPATH += &quot;D:\Project\Wireless_communication_software\mysql_v8.0.32\MySQL Server 8.0\include&quot;</code></pre>
<h2 id="nivicate破解版安装">4.4 Nivicate破解版安装</h2>
<ul>
<li><a href="https://www.cnblogs.com/kkdaj/p/16260681.html">NavicatPremium16破解</a></li>
</ul>
<h1 id="五vscode相关编译器配置">五、Vscode相关编译器配置</h1>
<h2 id="cc配置">5.1 C/C++配置</h2>
<ul>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/610895870">用vscode优雅配置c/c++环境！</a>
<ul>
<li>下载好vscode后从<code>3</code>部分下载MinGW开始进行配置</li>
<li><a href="https://blog.csdn.net/woxingzou/article/details/113746142）：https://pan.baidu.com/s/1ylj4YG7CBtv4C_RtVEtZ9Q">MinGW下载安装</a>
验证码：ftk5</li>
</ul></li>
<li>下载完MinGW后，配置VScode的部分参考<a href="https://zhuanlan.zhihu.com/p/87864677">VSCode配置C/C++环境</a>的第<code>3</code>部分</li>
<li>C++在vscode中运行是否每次都需要配置环境：https://www.zhihu.com/question/456362523</li>
</ul>
<h2 id="vscode中配置keil">5.2 Vscode中配置Keil</h2>
<ul>
<li>参考：(VS Code编写Keil uVison
5工程)[https://blog.csdn.net/weixin_43576926/article/details/107736692]</li>
</ul>
<h1 id="六jetbrains全家桶">六、JetBrains全家桶</h1>
<h2 id="clion配置c">6.1 CLion配置C++</h2>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_45571585/article/details/126977413">MacOS
配置Clion的C/C++环境的详细步骤及mac终端报错问题解决</a></p>
</blockquote>
]]></content>
      <categories>
        <category>重装-环境配置-计算机</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>QT编程经验</title>
    <url>/2023/03/18/QT%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="一小经验">一、小经验</h1>
<h2 id="组件复制">1.1 组件复制</h2>
<ul>
<li>在进行组件复制时，需要先把准备复制到的地方取消布局才能进行复制</li>
</ul>
<h2 id="tableview">1.2 tableview</h2>
<ul>
<li>在设计table内容时，为了方便后续修改表格，需要设计表格的model为<code>QStandardItemModel*</code>，后面对表格的修改都在model中进行，而不直接对table进行操作（QComBobox页也同理）</li>
</ul>
<h2 id="stacked的布局以及自适应缩放">1.3
stacked的布局以及自适应缩放</h2>
<ul>
<li>stack中各个界面整体不能单独布局，需要对stack进行统一布局</li>
<li>要实现自适应缩放需要把控件进行布局，同时如果缩放效果不符合预想可以通过修改Layout里面的layoutstretch的比值就可以实现</li>
</ul>
<h2 id="sql">1.4 sql</h2>
<h3 id="qt驱动sql">1.4.1 QT驱动sql</h3>
<ul>
<li><p>QT操作的前提：使用者能自己通过SQL语句实现数据库表数据的增删改查</p>
<ul>
<li>本地MySql的配置参考文章：https://subingwen.cn/qt/sql-driver/ &amp;
https://www.cnblogs.com/ShineLeBlog/p/14908927.html
<ul>
<li>在根据教程配置时需要注意.pro文件中添加INCLUDE等三个路径时，如果有路径中有空格需要在路径中添加双引号</li>
<li>还需要注意如果出现文件缺失错误，大概率是配置路径有问题，在添加双引号后先执行qmake然后在构建，参考https://blog.csdn.net/hhhuang1991/article/details/84060977</li>
<li>LIBS += "D:_communication_software_v8.0.32Server 8.0.lib"</li>
<li>INCLUDEPATH += "D:_communication_software_v8.0.32Server 8.0
"</li>
<li>DEPENDPATH += "D:_communication_software_v8.0.32Server 8.0
"</li>
</ul></li>
</ul></li>
<li><p>需要先将sql添加到.pro文件中：<code>QT += sql</code></p></li>
<li><p>qt提供的数据库类：</p>
<ul>
<li><ul>
<li>QSqlDatabase：通过这个类增/删/复制/关闭数据库，配置数据库信息</li>
</ul></li>
<li><ul>
<li>QSqlQuery：提供增删查改功能</li>
</ul></li>
<li>QSqlRecord：数据库记录</li>
<li>QSqlField：数据类型、列名等</li>
<li>QSqlQueryModel：遍历结果集的高级接口（模型视图结构，一般大型才需要）</li>
<li><ul>
<li>QSqlError：数据操作失败可以通过这个类获取错误信息</li>
</ul></li>
</ul></li>
</ul>
<h3 id="安装navicat">1.4.2 安装navicat</h3>
<p>参考：(NavicatPremium16破解)[https://www.cnblogs.com/kkdaj/p/16260681.html]</p>
<h3 id="sql事务操作-数据回滚">1.4.3 sql事务操作-数据回滚</h3>
<ul>
<li>在进行增、删、更新操作时需要添加事务操作来保护数据</li>
</ul>
<h3 id="sqlite使用">1.4.4 sqlite使用</h3>
<ul>
<li><a href="https://blog.csdn.net/weixin_42380257/article/details/81360237">SQLite数据库的创建和使用</a>,
<a href="https://blog.csdn.net/java_xiaoo/article/details/120868412">Navicat怎么连接Sqlite数据库</a></li>
</ul>
<h3 id="qt驱动sql出现问题">1.4.5 QT驱动sql出现问题</h3>
<ul>
<li>参考https://www.jianshu.com/p/6efaf46fec75 &amp;
https://subingwen.cn/qt/sql-driver</li>
<li><code>D:\Project\Wireless_communication_software\QT_v5.12.6\Qt\Qt5.12.6\5.12.6\mingw73_64\plugins\sqldrivers</code>路径中找不到<code>qsqlmysql.dll</code>和<code>qsqlmysql.dll</code>文件，因此需要想办法编译</li>
<li>在<code>D:\Project\Wireless_communication_software\QT_v5.12.6\Qt\Qt5.12.6\5.12.6\Src\qtbase\src\plugins\sqldrivers\mysql</code>目录下找到<code>mysql.pro</code>双击打开</li>
</ul>
<h2 id="qt实现web界面交互">1.5 QT实现web界面交互</h2>
<ul>
<li>参考<a href="https://blog.csdn.net/qq_34578785/article/details/106671018">Qt嵌入百度地图API的详细流程与常见问题</a>,
<a href="https://blog.csdn.net/qq_39295354/article/details/124655026?">QT加载百度在线地图</a></li>
<li>待参考<a href="https://blog.csdn.net/qq_41961619/article/details/107104622">qt使用高德地图并与之简单交互</a>,
<a href="https://www.cnblogs.com/feiyangqingyun/p/12150216.html">Qt编写百度地图综合应用（在线+离线+区域）</a>,
<a href="https://blog.csdn.net/Sakuya__/article/details/106031095">QT
QWebEngineView加载百度地图</a>,</li>
</ul>
<h2 id="qt利用sql的用户登录界面">1.6 QT利用sql的用户登录界面</h2>
<ul>
<li>参考：<a href="https://blog.csdn.net/qq_42179526/article/details/105845303">QT连接SQLite数据库（实现登陆注册）</a>,
<a href="https://blog.csdn.net/qq_16488989/article/details/108884580">Qt
手把手教你实现漂亮的登录界面</a>, <a href="https://www.bilibili.com/video/BV1ov4y1P7Vb/?">基于QT开发项目管理系统（附源码）-视频</a>,
<a href="https://blog.csdn.net/weixin_45739654/article/details/125702849">Qt设计精美的登录注册界面（包含SQLite数据库应用）</a></li>
</ul>
<h2 id="qt利用生成pri文件">1.7 QT利用生成pri文件</h2>
<p>参考：https://zhuanlan.zhihu.com/p/489685702</p>
<ul>
<li><p>先在工程的文件夹中创建一个新的文件夹</p></li>
<li><p>在新的文件夹中创建一个txt文件，并将名字后缀改成<code>pri</code></p></li>
<li><p>在工程的<code>.pro</code>文件下添加pri对应的文件夹地址信息</p>
<p><img url="addPri.png" width="%50" height="%50"></p></li>
<li><p>在<code>.pri</code>文件中添加需要加入的自定义类文件的地址信息</p>
<p><img url="pri.png" width="%50" height="%50"></p></li>
</ul>
<h1 id="二qt配置">二、QT配置</h1>
<h2 id="qt中配置msvc环境">2.1 QT中配置MSVC环境</h2>
<ul>
<li><p>先到<code>MaintenanceTool.exe</code>中添加对应MSVC版本的组件</p></li>
<li><p>参考：https://blog.csdn.net/Copperxcx/article/details/122540629
和 https://blog.csdn.net/zujiasheng/article/details/125302904</p>
<ul>
<li>QT5.12.6是可以配置MSVC的，但是只有在安装了VS后添加里面才会显示MSVC选项</li>
<li>大坑：VS中需要同时安装MSVC 2015版本的才能被QT自动识别</li>
</ul></li>
<li><p>完成后编译可能还会出错，因此需要将以下环境添加进环境变量中</p>
<ul>
<li>C:Files (x86)Kits\10</li>
<li>C:Files (x86)Kits\10</li>
<li>问题解决：http://t.csdn.cn/LkidD
https://bbs.csdn.net/topics/396205896 和
https://blog.csdn.net/dsn3S/article/details/121042651</li>
<li>出现：无法打开包括文件type_traits错误的话可以尝试在cmd这执行<code>"C:\Program Files (x86)\Microsoft Visual Studio\2022\BuildTools\VC\Auxiliary\Build\vcvarsall.bat" x64</code></li>
<li>出现缺少shell32.dll问题
<ul>
<li>需要加入自己的Windows
Kits下lib下的的um文件路径到系统环境变量中:</li>
<li>比如我的路径:<code>C:\Program Files (x86)\Windows Kits\10\Lib\10.0.18362.0\um\x64</code>，如果没有um文件夹则重新下载windows
kits</li>
</ul></li>
<li>出现头文件缺失：https://blog.csdn.net/skye_95/article/details/81076456
和 https://blog.csdn.net/hhhuang1991/article/details/84060977</li>
</ul></li>
<li><p>解决MSVC中文出错问题</p>
<ul>
<li>在所有头文件<code>.h</code>中添加下面的语句
<ul>
<li><code>//解决MSVC中文乱码 #if _MSC_VER &gt;= 1600    // MSVC2015 &gt; 1899, MSVC_VER = 14.0 #pragma execution_character_set("utf-8") #endif</code></li>
</ul></li>
</ul></li>
</ul>
<h2 id="qt组件添加">2.2 QT组件添加</h2>
<ul>
<li>参考：https://blog.csdn.net/Arcofcosmos/article/details/122413626</li>
<li>参考：https://blog.csdn.net/qq_36170958/article/details/108679509
用到<code>MaintenanceTool.exe</code>
<ul>
<li>清华镜像：https://mirrors.tuna.tsinghua.edu.cn/qt/online/qtsdkrepository/windows_x86/root/qt/</li>
</ul></li>
</ul>
<h1 id="三qt打包exe可执行文件">三、QT打包EXE可执行文件</h1>
<p>参考：https://blog.csdn.net/ColinFhz/article/details/107879769</p>
<ul>
<li>1.打开<code>Qt5.12.6（MinGW...）</code>，如我的电脑是在搜索栏中点击<code>Qt5.12.6（MinGW 7.3.0 64-bit）</code></li>
<li>2.将QT
Creator运行得到的<code>.exe</code>文件复制到一个空文件夹中</li>
<li>3.在<code>Qt5.12.6（MinGW...）</code>打开的cmd控制台中cd到第2步中的文件夹处</li>
<li>4.输入<code>windeployqt text.exe</code>自动打包，其中<code>text</code>自己改成对应的文件名称就行</li>
</ul>
<h1 id="四qt云服务器中部署websocket通信">四、QT云服务器中部署websocket通信</h1>
<h2 id="云服务器配置-选用阿里云">1. 云服务器配置-选用阿里云</h2>
<ul>
<li><p>注意：新用户有<a href="https://help.aliyun.com/zh/ecs/3-month-free-trial">三个月免费使用的优惠</a></p></li>
<li><p>注意：学生用完三个月优惠后可以申请<a href="https://developer.aliyun.com/plan/student?userCode=r3yteowb">一个月学生免费试用优惠</a></p></li>
<li><p>参考<a href="https://blog.csdn.net/qq21497936/article/details/115409124?">阿里云服务器建立公网物联网服务器</a></p>
<ul>
<li>其中<code>添加端口</code>步骤是给公网映射一个端口，这样就可以通过公网IP+端口号访问到服务器了，除了安全组里面的端口号外，其它PC是无法通过公网IP访问到服务器的。这里可以测试，在服务器上监听服务器内网的安全组端口号，此时其它PC可以通过<code>公网IP+端口号</code>与服务器通信；若服务器监听的是非安全组的端口号，则其它PC无法通过<code>公网IP+端口号</code>与服务器通信。</li>
</ul></li>
<li><p>云服务器上部署服务端，实际上就是在云本机的内网IP上开放端口号，通过地址映射关系将公网IP与内网IP对应起来，这样就可以通过公网IP访问到云服务器了。</p></li>
</ul>
<p><img src="/2023/03/18/QT%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/port_mapping.png" width="%50" height="%50"></p>
<h2 id="sqlite加密设置">2. sqlite加密设置</h2>
<p>将下面四个文件拷贝到QT下载路径下对于编译器的sql驱动文件夹中，比如我的是<code>\QT\Qt5.12.6\5.12.6\mingw73_64\plugins\sqldrivers</code>，然后在QT的.pro文件中添加<code>sqlcipher</code>库。</p>
<ul>
<li><code>libsqlcipher.a</code></li>
<li><code>libsqlcipher.a</code></li>
<li><code>sqlcipher.dll</code></li>
<li><code>sqlcipherd.dll</code></li>
</ul>
<p><img url="sqlitecipher.png" width="%50" height="%50"></p>
<h2 id="openssl配置">3. openssl配置</h2>
<p>参考：https://blog.csdn.net/byzzw/article/details/118390933</p>
]]></content>
      <tags>
        <tag>杂货铺-休闲</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库学习</title>
    <url>/2024/09/21/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一redis数据结构">一、Redis数据结构</h1>
<h2 id="string">1. string</h2>
<h3 id="基本操作增删改查">1.1 基本操作：增删改查</h3>
<p>创建：</p>
<ul>
<li><code>set key value</code></li>
<li><code>setnx key value</code>：如果key不存在则设置，否则失败</li>
</ul>
<p>查询</p>
<ul>
<li><code>get key</code></li>
<li><code>mget key1 key2</code>：一次获取多个key的值</li>
</ul>
<p>更新</p>
<ul>
<li><code>set key value</code></li>
</ul>
<p>删除</p>
<ul>
<li><code>del key</code></li>
</ul>
<h3 id="底层实现">1.2 底层实现</h3>
<p>编码格式：</p>
<ul>
<li><code>int</code>：存储整数</li>
<li><code>embstr</code>：小于等于44字节的字符串（浮点型会被转换为字符串存储）</li>
<li><code>raw</code>：大于44字节的字符串</li>
</ul>
<h2 id="list">2. list</h2>
<p>list就是一个列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">&quot;a&quot;, </span><br><span class="line">&quot;1234&quot;, </span><br><span class="line">&quot;@!=#&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="基本操作">2.1 基本操作</h3>
<p>list是允许双端操作的，不是完全的先入先出，也不是完全的后入先出</p>
<p>创建</p>
<ul>
<li><code>lpush key value1 value2</code>：从左边插入</li>
<li><code>rpush key value1 value2</code>：从右边插入</li>
</ul>
<p>查询</p>
<ul>
<li><code>llen key</code>：获取列表长度</li>
<li><code>lrange key start end</code>：获取指定范围的元素</li>
</ul>
<p>更新</p>
<ul>
<li><code>lpush key value1 value2</code>：从左边插入</li>
<li><code>rpush key value1 value2</code>：从右边插入</li>
<li><code>lpop key</code>：从左边弹出</li>
<li><code>rpop key</code>：从右边弹出</li>
</ul>
<p>删除</p>
<ul>
<li><code>del key</code></li>
<li><code>lrem key count value</code>：删除指定数量的元素，时间复杂度O(n)</li>
<li><code>ltrim key start end</code>：删除指定范围的元素，时间复杂度O(n)</li>
</ul>
<h3 id="底层实现-1">2.2 底层实现</h3>
<ul>
<li><code>ziplist</code>：压缩列表，用类似数组的结构存储数据，修改效率低</li>
<li><code>linkedlist</code>：双向链表，修改效率高</li>
<li><code>quicklist</code>：ziplist和linkedlist的结合体</li>
</ul>
<h2 id="set">3. set</h2>
<p>set适用于<strong>去重</strong>场景和<strong>交集场景</strong>，可以在<strong>点赞</strong>和<strong>共同关注</strong>等场景中使用</p>
<h3 id="基本操作-1">3.1 基本操作</h3>
<p>创建</p>
<ul>
<li><code>sadd key value1 value2</code>：添加元素</li>
</ul>
<p>查询</p>
<ul>
<li><code>sismember key value</code>：判断元素是否存在</li>
<li><code>smembers key</code>：获取所有元素的列表</li>
<li><code>SUNION key1 key2</code>：求并集，如用于共同关注的人</li>
</ul>
<p>更新</p>
<ul>
<li><code>sadd key value1 value2</code>：添加元素</li>
<li><code>srem key value1 value2</code>：删除元素</li>
</ul>
<p>删除</p>
<ul>
<li><code>del key</code></li>
</ul>
<h3 id="底层实现-2">3.2 底层实现</h3>
<ul>
<li><code>intset</code>：整数集合，元素都是整数（有序的，整体来看不依赖set的顺序）</li>
<li><code>hashtable</code>：哈希表，元素都是字符串（无序的）</li>
</ul>
<p>存在元素个数阈值，当元素个数小于512个时会用<code>intset</code>，否则会用<code>hashtable</code></p>
<h2 id="hash">4. hash</h2>
<h3 id="基本操作-2">4.1 基本操作</h3>
<p>创建</p>
<ul>
<li><code>hset key field1 value1 field2 value2</code>：添加元素</li>
<li><code>hsetnx key field value</code>：如果field不存在则设置，否则失败</li>
</ul>
<p>查询</p>
<ul>
<li><code>hget key field</code>：获取元素</li>
<li><code>hgetall key</code>：获取所有元素</li>
</ul>
<p>更新</p>
<ul>
<li><code>hset key field value</code>：添加元素</li>
<li><code>hdel key field</code>：删除元素</li>
</ul>
<p>删除</p>
<ul>
<li><code>del key</code></li>
</ul>
<h3 id="底层实现-3">4.2 底层实现</h3>
<p>都是无序的</p>
<ul>
<li><code>ziplist</code>：压缩列表，用类似数组的结构存储数据，修改效率低</li>
<li><code>hashtable</code>：哈希表，元素都是字符串（无序的）</li>
</ul>
<h2 id="zset">5. zset</h2>
<h3 id="基本操作-3">5.1 基本操作</h3>
<h3 id="底层实现-4">5.2 底层实现</h3>
<ul>
<li><code>ziplist</code>：压缩列表，用类似数组的结构存储数据，修改效率低，查找速度为<code>O(n)</code></li>
<li><code>skiplist</code>：<strong>跳表</strong>，类似于二分法，查找速度为<code>O(logn)</code></li>
</ul>
<p><strong>为什么用跳表而不用红黑树？</strong></p>
<p>跳表跟红黑树的查询时间复杂度都是<code>O(logn)</code>，但是跳表的<strong>实现更简单</strong>，而且跳表的<strong>范围查询效率更高</strong>；而<strong>平衡树插入和删除</strong>涉及<strong>旋转</strong>等操作，较为复杂</p>
<p>但是跳表的<strong>层数比较高</strong></p>
<p><strong>跳表插入一个数的层高是随机的，一开始默认1层，然后每增加一层的概率都是25%，最高为32层</strong></p>
<h1 id="二redis基础知识">二、Redis基础知识</h1>
<p>redis常用在<strong>热点词、排行榜、分布式锁<code>setnx</code></strong>等场景中</p>
<h2 id="redis的优点">1. redis的优点</h2>
<ul>
<li>读写性能高：redis是基于<strong>内存</strong>的，读写性能高</li>
<li>数据结构类型多：支持多种数据结构，如string、list、set、hash等
<ul>
<li>功能：支持<strong>事务、哨兵模式、主从复制、集群</strong>等功能来保证数据的<strong>安全性和高可用性</strong></li>
</ul></li>
</ul>
<h2 id="redis的单线程与多线程">2. redis的单线程与多线程</h2>
<p>redis<strong>主要处理逻辑是单线程</strong>的，主要的数据crud是短平快的，本身不会消耗很多时间，而如果像mysql一样用多线程还要考虑资源竞争、线程上下文切换、同步机制等开销，增加了维护难度，提高了系统复杂度，得不偿失：</p>
<ul>
<li>数据读写上：redis数据是通过内存的，所以瓶颈不在cpu</li>
</ul>
<p>随着高并发场景的普及，单核cpu也逐渐不够用了（不过redis的多线程是默认关闭的，可以在redis.config配置文件中打开）</p>
<p>redis的主要瓶颈在<strong>I/O处理</strong>上，所以采用<strong>epoll多路复用用+reactor模式</strong>来提高I/O处理效率。</p>
<ul>
<li>解包、回包用的是<strong>多线程</strong></li>
<li><strong>RDB</strong>全量备份时属于耗时操作，开一个单独进程来执行</li>
</ul>
<h2 id="缓存穿透缓存击穿缓存雪崩">3. 缓存穿透、缓存击穿、缓存雪崩</h2>
<ul>
<li>缓存穿透：<strong>Redis和MySQL都没有这个key</strong></li>
<li>缓击击穿：<strong>某个热点key失效</strong></li>
<li>缓存雪崩：<strong>大量key同时失效</strong></li>
</ul>
<h3 id="缓存穿透">3.1 缓存穿透</h3>
<p>缓存穿透是指<strong>查询一个一定不存在的数据</strong>，也就是<strong>redis和mysql都不存在这个key</strong>，会导致数据库压力过大</p>
<p>解决方案：</p>
<p><strong>1）布隆过滤器</strong></p>
<p>布隆过滤器将<strong>可能存在的key的哈希存到一个足够大的位数组</strong>中</p>
<ul>
<li><strong>能通过</strong>布隆过滤器的key<strong>不一定存在</strong></li>
<li>但是<strong>不能通过</strong>的key<strong>一定不存在</strong></li>
</ul>
<p><img src="/2024/09/21/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/blooming.png"></p>
<p><img src="/2024/09/21/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/blooming2.png"></p>
<p><strong>2）限流策略：漏斗算法、令牌桶</strong></p>
<ul>
<li><strong>漏斗算法</strong>：漏斗的流出速度是固定的，如果流入速度大于流出速度，那么就会溢出</li>
<li><strong>令牌桶</strong>：固定速率往桶里放令牌，请求来了就拿一个令牌，如果没有令牌则拒绝请求
<ul>
<li>优点：空闲时攒着令牌，用于应对突发流量</li>
</ul></li>
</ul>
<h3 id="缓存击穿">3.2 缓存击穿</h3>
<p>缓存击穿是指<strong>某个热点key失效</strong>，导致<strong>大量请求直接打到数据库</strong></p>
<p>解决方案：</p>
<p><strong>1）热点数据永不过期</strong></p>
<p>对于某些热点数据，可以设置<strong>永不过期</strong></p>
<p><strong>2）延迟过期时间</strong></p>
<p>设置<strong>窗口时间</strong>，窗口时间内key被频繁访问则<strong>延长过期时间</strong></p>
<h3 id="缓存雪崩常见于主redis宕机">3.3 缓存雪崩：常见于主redis宕机</h3>
<p>缓存雪崩是指<strong>大量key同时失效</strong>，导致<strong>大量请求直接打到数据库</strong></p>
<p>解决方案：</p>
<p>如果是普通失效，可以通过设置<strong>随机过期时间</strong>来避免同时失效，也可以类似于<strong>缓存击穿</strong>的解决方式设置<strong>窗口时间或永不过期</strong></p>
<p>如果是<strong>主redis宕机</strong>，可以通过<strong>从redis</strong>来解决</p>
<p><strong>1）主从redis</strong></p>
<p>设置<strong>主从redis集群</strong>，当主redis宕机时，可以通过<strong>重新选举新的主redis</strong>来继续提供缓存服务</p>
<p><strong>2）熔断</strong></p>
<p>当主redis宕机时，可以通过<strong>熔断</strong>来避免大量请求直接打到数据库，直接<strong>关掉</strong>缓存相关的一些<strong>次要服务</strong>，保证核心功能的正常运行</p>
<h2 id="redis持久化rdb和aof">4. redis持久化：RDB和AOF</h2>
<p>redis持久化是通过<strong>RDB和AOF</strong>实现，其中<strong>RDB</strong>（二进制文件）是使用<strong>快照</strong>可持久化，<strong>AOF</strong>（文本文件）是<strong>追加型日志</strong>；其中RDB在宕机时会出现较大的丢失，而AOF是用于恢复的，用默认everysec的话最多允许1s的数据丢失</p>
<p><strong>1）RDB</strong></p>
<p><strong>RDB</strong>是<strong>全量保存</strong>，操作量大，所以一般5min保存一次</p>
<p><strong>2）AOF</strong></p>
<p><strong>AOF是追加</strong>，操作量小，所以一般频率较高（1s）</p>
<p><strong>3）RDB和AOF的混合使用</strong></p>
<p>RDB是做备份用的，从缓存可以直接恢复，会比从db恢复快，所以一般也建议开启RDB。</p>
<p>在恢复时先将RDB的二进制数据以二进制的格式写入新的AOF文件中，其余的没来得及全量备份的数据可以通过以前的AOF来恢复</p>
<p>之后追加进AOF的新数据继续以AOF的文本格式追加</p>
<h2 id="redis的过期策略">5. redis的过期策略</h2>
<h3 id="定时删除">5.1 定时删除</h3>
<p><strong>每个key都会有一个定时</strong>器，到期后会被删除</p>
<p>缺点：每个key都要维护一个定时器，占用内存</p>
<h3 id="惰性删除">5.2 惰性删除</h3>
<p>当<strong>用户访问取key时才删除</strong></p>
<p>缺点：如果长期无操作则会逐渐导致内存泄漏</p>
<h3 id="定期删除">5.3 定期删除</h3>
<p>适合cpu能力较差的，所有key<strong>定期检查是否过期</strong></p>
<p>缺点：及时性有限，可能会存在有key过期了但还没被删除的情况</p>
<h3 id="定期惰性">5.4 定期+惰性</h3>
<p>redis采用的是<strong>定期+惰性</strong>的策略</p>
<h2 id="redis的内存淘汰策略">6. redis的内存淘汰策略</h2>
<p>内存回收触发时机：每次<strong>读写时都会检查内存是否超过限制</strong>，如果超过则会触发内存回收</p>
<h3 id="noeviction不淘汰默认的">6.1 noeviction不淘汰（默认的）</h3>
<p>redis默认采用不淘汰的方式，当内存超过限制时<strong>拒绝写入</strong></p>
<h3 id="lru淘汰最久未使用的key">6.2 lru：淘汰最久未使用的key</h3>
<p>lru是<strong>最久未使用</strong>的key</p>
<p>但是redis使用的是<strong>近似lru</strong>，因为标准lru是<strong>维护双端链表</strong>，内存成本大</p>
<p>近似lru是通过<strong>随机采样</strong>来实现的：每次淘汰时<strong>随机选取一部分key</strong>，然后淘汰其中最久未使用的key（<strong>根据最近使用时间排序</strong>）</p>
<h3 id="lfu淘汰使用频率最低的key">6.3 lfu：淘汰使用频率最低的key</h3>
<p>lfu记录上次访问的时间戳和累计访问次数，每次淘汰时<strong>选取访问次数最少的key</strong></p>
<p>其中如果一段时间内没有被访问，那么该key的访问次数会逐渐衰减</p>
<p>lfu相比lru好处在于：lru按照最近使用时间排序，可能会删除某个<strong>热点key</strong>，而lfu则是按照<strong>访问次数</strong>排序</p>
<h3 id="random随机淘汰设置了过期时间的key">6.4
random：随机淘汰设置了过期时间的key</h3>
<h2 id="redis的使用场景">7. redis的使用场景</h2>
<h3 id="redismysql保持一致性的方式旁路缓存">7.1
redis+mysql保持一致性的方式：旁路缓存</h3>
<p>旁路缓存遵循<strong>读更新redis、写删除redis</strong>的原则</p>
<ul>
<li>读：
<ul>
<li>先读redis</li>
<li>如果没有再读mysql，然后重新写入redis</li>
</ul></li>
<li>写：
<ul>
<li>先写mysql，再删除redis</li>
</ul></li>
<li>过期兜底：设置一个较短的过期时间，避免数据不一致</li>
</ul>
<h3 id="redis在秒杀中的作用削峰">7.2 redis在秒杀中的作用：削峰</h3>
<p>将redis当做<strong>消息队列</strong>使用，记录库存，当库存量少于0时，直接拒绝客户端请求</p>
<h3 id="redis的分布式锁">7.3 redis的分布式锁</h3>
<h4 id="加锁way1setnxpx">加锁way1：set+nx&amp;px</h4>
<p><strong>1）不直接使用setnx的原因：无法保证原子性</strong></p>
<p>在redis中，如果使用<code>setnx</code>无法直接设置过期时间，必须<code>setnx+expire</code></p>
<p>但是这样<strong>两个指令就无法保证原子性</strong>了</p>
<p>因此一般使用<strong>set+nx和px参数</strong></p>
<ul>
<li><code>nx</code>：如果key不存在则设置</li>
<li><code>px</code>：设置过期时间</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set lock_key unique_value nx px 10000</span><br></pre></td></tr></table></figure>
<p><strong>2）解锁：用lua保证原子性</strong></p>
<p>解锁有两个操作:</p>
<ul>
<li>判断锁的unique_value是否为准备执行解锁的客户端（key是锁的名字，values是owner保证原子性的，是锁持有者的id）</li>
<li>然后再解锁</li>
</ul>
<p>需要执行两个操作，不符合原子性，所以要用<code>lua脚本</code>来保证原子操作（lua本身不是原子操作，但是redis是单线程，所以可以保证操作的原子性）</p>
<h3 id="加锁way2redlock红锁">加锁way2：redlock红锁</h3>
<p><strong>1）用红锁的原因：单点故障锁尚未同步到子节点</strong></p>
<p>集群下有多个redis节点，客户端向主节点申请加锁，此时如果<strong>主节点单点故障</strong>了，新的主节点并没有同步锁的信息，导致其他客户端可以继续加锁</p>
<p><strong>2）解决方案：红锁保证超过半数子节点成功加锁</strong></p>
<ul>
<li>记录客户端刚发出加锁请求的时间点为<strong>t1</strong></li>
<li>客户端加锁操作不仅对主节点进行，还需要<strong>同时向超过半数的节点成功加锁</strong></li>
<li>拿到半数用户加锁的时间点<strong>t2-t1&lt;锁过期时间</strong>，则认为加锁成功
<ul>
<li>tips：如果完成加锁操作后锁已经过期了，那么也没有意义</li>
</ul></li>
</ul>
<h2 id="redis的集群模式主从复制模式哨兵模式hash切片集群">8.
redis的集群模式：主从复制模式、哨兵模式、hash切片集群</h2>
<p>redis提供三种集群模式：<strong>主从复制模式、哨兵模式、hash切片集群</strong></p>
<h3 id="主从复制模式读写分离">8.1 主从复制模式：读写分离</h3>
<p>多个节点，读写分离降低主节点压力，该模式下，主节点宕机不会自动选举新的主节点，因此需要<strong>手动恢复</strong></p>
<p>且数据同步跟主节点返回操作结果给客户端之间是<strong>异步</strong>的，所以可能会有<strong>数据不一致</strong>的情况</p>
<p><strong>redis主从复制的方式</strong>：</p>
<p>redis主从节点之间的连接方式是<strong>长连接</strong>的</p>
<ul>
<li><strong>新节点加入：全量复制</strong>：主节点将数据全部复制给<strong>新的从节点</strong></li>
<li><strong>旧的从节点：增量复制</strong>：主节点将<strong>增量数据</strong>复制给<strong>旧的从节点</strong>，从节点<strong>掉线后</strong>如果落后的不多也会用增量复制</li>
</ul>
<p><img src="/2024/09/21/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/redis主从复制.png"></p>
<h3 id="哨兵模式自动选举新的主节点">8.2
哨兵模式：自动选举新的主节点</h3>
<p>哨兵模式通过新增一个<strong>哨兵节点</strong>来监控主节点的状态，当主节点宕机时，哨兵节点会自动<strong>投票选举</strong>新的主节点，实现<strong>主从节点故障转移</strong></p>
<p><img src="/2024/09/21/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/redis哨兵模式.png"></p>
<h3 id="hash切片集群数据分片">8.3 hash切片集群：数据分片</h3>
<p>当一台机器无法承载时，可以通过切片方案将数据分布在不同机器上</p>
<p>redis<strong>没有一致性哈希</strong>的概念，而是使用<strong>2^14的哈希槽</strong>来实现的切片</p>
<p><img src="/2024/09/21/Redis%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/redis切片.png"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>SolveProgramLearningProblem</title>
    <url>/2022/12/08/SolveProgramLearningProblem/</url>
    <content><![CDATA[<h1 id="一python">一、Python</h1>
<h2 id="in-vscode">1.1 In VScode</h2>
<p>根据python的文件路径问题，其相对路径是从当前文件夹开始的，而不是从.py文件对应的文件夹开始的</p>
<ul>
<li>若有文件如下所示</li>
</ul>
<p><img src="/2022/12/08/SolveProgramLearningProblem/python_vscode_setpath1.png" width="%50" height="%50"></p>
<ul>
<li><p>想在<code>q_learning_agent.py</code>代码中调用<code>rectangle.png</code>文件</p></li>
<li><p>在<code>q_learning_agent.py</code>代码中相对路径应从最外层的文件夹开始写，也就是写成当前文件夹<code>./</code>而不是上一层文件夹<code>../</code></p>
<ul>
<li><p>正确写法：<code>imgpath="./img/rectangle.png"</code>，该写法的相对路径是从最外层文件夹开始的</p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/python_vscode_setpath3.png" width="%50" height="%50"></p></li>
<li><p>错误写法：<code>imgpath="../img/rectangle.png"</code>，该写法认为相对路径是从<code>Q-learning</code>文件夹开始的</p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/python_vscode_setpath4.png" width="%50" height="%50"></p></li>
</ul></li>
</ul>
<h1 id="二git使用">二、Git使用</h1>
<h2 id="git指令下载开源项目到本地">2.1 git指令下载开源项目到本地</h2>
<ul>
<li><p>先下载<code>Git for windows</code>软件</p></li>
<li><p>在本地盘中右键点击<code>Git Bash Here</code></p></li>
<li><p>进行基础配置，告诉git你是谁</p>
<ul>
<li>git config --global user.name "你的名字或昵称"
<ul>
<li>如：AkiraZheng</li>
</ul></li>
<li>git config --global user.email "你的邮箱"
<ul>
<li>如：1428384878@qq.com</li>
</ul></li>
</ul></li>
<li><p>克隆项目</p>
<ul>
<li>git clone 项目地址
<ul>
<li>其中项目地址是github项目<code>code</code>中的<code>http</code>链接,
项目地址形式为:https://gitee.com/xxx/xxx.git或者
git@gitee.com:xxx/xxx.git</li>
</ul></li>
<li>在弹出的窗口输入你的github账号密码信息
<ul>
<li>如果没弹出窗口则先输入<code>git config --system --unset credential.helper</code>再重新执行<code>git clone</code>指令</li>
</ul></li>
</ul></li>
</ul>
<h2 id="在linux下使用git上传项目">2.2 在Linux下使用git上传项目</h2>
<ul>
<li><a href="https://blog.csdn.net/qq_32348883/article/details/123035279">参考</a></li>
</ul>
<h3 id="将本地项目push到远程仓库的main分支中">2.2.1
将本地项目push到远程仓库的main分支中</h3>
<ul>
<li><p>1.进入项目文件夹</p>
<ul>
<li><code>cd 项目文件夹</code></li>
</ul></li>
<li><p>2.将项目上传到服务器</p></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd existing_repo</span><br><span class="line">git remote add origin git@github.com:AkiraZheng/MyWebServer.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -uf origin main</span><br></pre></td></tr></table></figure>
<ul>
<li><ol start="3" type="1">
<li>添加readme文件</li>
</ol></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;添加 README&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<h3 id="常用指令">2.2.2 常用指令</h3>
<ul>
<li><p>查看当前远程仓库地址</p>
<ul>
<li><code>git remote -v</code></li>
</ul></li>
<li><p>删除远程仓库地址</p>
<ul>
<li><code>git remote rm origin</code></li>
<li><code>git remote -v</code></li>
</ul></li>
<li><p>添加远程仓库地址</p>
<ul>
<li><code>git remote add origin git@github.com:AkiraZheng/MyWebServer.git</code></li>
</ul></li>
<li><p>将当前文件夹添加到新分支</p>
<ul>
<li><code>git branch -M master</code></li>
</ul></li>
<li><p>将当前文件夹上传到远程仓库的master分支</p>
<ul>
<li><code>git push -u origin master</code></li>
</ul></li>
<li><p>删除某个分支</p>
<ul>
<li><code>git branch -d 分支名</code></li>
</ul></li>
</ul>
<h3 id="举例更新项目到远程仓库">2.2.3 举例更新项目到远程仓库</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add *</span><br><span class="line">git commit -m &quot;更新项目&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<h1 id="三云服务器远程连接">三、云服务器远程连接</h1>
<h2 id="阿里云">1 阿里云</h2>
<h2 id="windows系统">1.1 windows系统</h2>
<ul>
<li><p>创建用于部署的端口号</p>
<ul>
<li><p>进入<a href="https://ecs.console.aliyun.com/server/">阿里云服务器控制台</a>选择对应的服务器点击进入</p></li>
<li><p>点击上方Tab的<code>安全组</code>-&gt;<code>管理规则</code>-&gt;<code>手动添加</code></p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/aliyun_add_port.png" width="%50" height="%50"></p></li>
</ul></li>
<li><p>修改系统登录密码</p>
<ul>
<li><p>进入<a href="https://ecs.console.aliyun.com/server/">阿里云服务器控制台</a>选择对应的服务器点击进入</p></li>
<li><p>点击上方Tab的<code>实例详情</code>-&gt;<code>基本信息</code>-&gt;<code>重置密码</code></p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/aliyun_change_password.png" width="%50" height="%50"></p></li>
<li><p>注意：不能修改登录名<code>administrator</code>，只能修改密码，否则会修改失败</p></li>
</ul></li>
<li><p>远程登录</p>
<ul>
<li><p>在自己的电脑主机中点击<code>开始</code>-&gt;<code>运行</code>-&gt;输入<code>mstsc</code>-&gt;<code>确定</code>-&gt;输入服务器的公网IP地址-&gt;<code>连接</code>-&gt;输入用户名<code>administrator</code>-&gt;输入密码-&gt;<code>确定</code></p></li>
<li><p>或者在电脑的搜索栏中搜索<code>远程桌面连接</code>，然后输入服务器的公网IP地址-&gt;<code>连接</code>-&gt;输入用户名<code>administrator</code>-&gt;输入密码-&gt;<code>确定</code></p></li>
</ul></li>
<li><p>远程文件传输</p>
<ul>
<li><a href="https://help.aliyun.com/zh/ecs/use-cases/use-mstsc-exe-to-upload-a-file-to-a-windows-instance">阿里云提供的上传文件功能</a>
<ul>
<li>1.在远程桌面连接前点击<code>显示选项</code>-&gt;<code>常规</code>Tab中<code>本地资源</code></li>
<li>2.直接在本机中通过复制粘贴传递文件</li>
</ul></li>
</ul></li>
</ul>
<h1 id="四使用visual-studio与github进行代码管理出现的问题">四、使用Visual
Studio与Github进行代码管理出现的问题</h1>
<h2 id="突然出现未能推送到远程仓库的问题">1.1
突然出现“未能推送到远程仓库”的问题</h2>
<ul>
<li><p>问题如下：</p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/vs_pushError_code.png" width="%50" height="%50"></p></li>
<li><p><a href="https://blog.csdn.net/harry_yaya/article/details/107484793">解决方案</a></p>
<ul>
<li>1）首先先使用魔法科学上网</li>
<li>2）接着在cmd中测试能不能ping通github.com。<code>ping github.com</code>，针对ping不通的情况，需要修改hosts文件。</li>
<li>3）打开<code>C:\Windows\System32\drivers\etc</code>目录下的hosts文件</li>
</ul>
<p><img src="/2022/12/08/SolveProgramLearningProblem/vs_pushError_fixHosts.png" width="%50" height="%50"></p>
<ul>
<li>4）在hosts文件中添加如下内容并保存
<code>markdown       192.30.255.112  github.com git        185.31.16.184 github.global.ssl.fastly.net</code><br>
</li>
<li>5）再次在cmd中测试能不能ping通github.com。<code>ping github.com</code>，如果能ping通，就可以在vscode中进行push操作了。</li>
</ul></li>
</ul>
<h2 id="右侧工具栏消失">1.2 右侧工具栏消失</h2>
<ul>
<li><p>问题如下：</p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/vs_no_rightTool.png" width="%50" height="%50"></p></li>
<li><p>解决方案</p>
<p>在VS软件的顶部点击<code>视图</code>,在试图下方点击<code>解决方案资源管理器</code></p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/vs_no_rightTool_fix.jpg" width="%50" height="%50"></p></li>
<li><p>解决效果</p>
<p><img src="/2022/12/08/SolveProgramLearningProblem/vs_no_rightTool_result.png" width="%50" height="%50"></p></li>
<li><p>参考链接：<a href="https://blog.csdn.net/weixin_44143600/article/details/118654089#">Visual
Studio 2019解决右侧工具栏消失</a></p></li>
</ul>
]]></content>
      <tags>
        <tag>杂货铺-休闲</tag>
      </tags>
  </entry>
  <entry>
    <title>VScode+Anaconda+Pycharm+JDK的Python和Java环境配置</title>
    <url>/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一python部分">一、Python部分</h1>
<h2 id="首先安装anaconda">1.1 首先安装Anaconda</h2>
<p>Anaconda包含Python环境，可以建立管理多个不同版本的Python环境，安装它后就默认安装了python、IPython、集成开发环境Spyder和众多的包和模块，让你在管理环境和包时更加方便。</p>
<ul>
<li><p>从官网中下载Anaconda的exe文件</p></li>
<li><p>安装过程中注意勾选<strong>Alls Users</strong>和<strong>Add
Anaconda to the system PATH environment
variable</strong>，便于以后不用再配置路径</p></li>
</ul>
<h2 id="安装vscode">1.2 安装VScode</h2>
<p>我这里直接用Anaconda进行VScode下载</p>
<ul>
<li><p>运行Anaconda Navigator后，点击VS
Code位置下方的Install直接进行下载（由于我已经下载过了，因此按钮变成了Launch，没下载过的话按钮显示的是Install）</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/1.png" width="80%" height="80%"></p></li>
</ul>
<h2 id="vscode中配置python环境">1.3 VScode中配置Python环境</h2>
<ul>
<li><p>安装Python插件</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.png" width="80%" height="80%"></p></li>
<li><p>安装Code Runner插件</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.png" width="80%" height="80%"></p></li>
<li><p>安装中文插件</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.png" width="80%" height="80%"></p></li>
<li><p>安装python函数快速注释插件<code>autoDocstring</code></p>
<ul>
<li>使用方法：输入<code>"""</code>后回车</li>
</ul></li>
</ul>
<p>此时运行.py代码可以正常运行了，VScode中Pyhon环境搭建完毕</p>
<p>VScode中Pyhon环境搭建参考文章：<a href="https://zoyi14.smartapps.cn/pages/note/index?origin=share&amp;slug=ef1ae10ba950&amp;_swebfr=1&amp;_swebFromHost=baiduboxapp">Anaconda
+ VSCode 最详细教程</a></p>
<h2 id="pycharm中配置python环境">1.4 Pycharm中配置Python环境</h2>
<ul>
<li><p>Pycahrm需要在<strong>settings</strong>中跟conda的解析器关联起来</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.png" width="60%" height="60%"></p></li>
<li><p>点击<strong>Project
Interpreter</strong>，点击右方的锯齿轮后点击<strong>Add</strong>,点击<strong>Conda
Environment</strong>和右边的<strong>Existing
environment</strong>，一路点OK即可</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.png" width="100%" height="100%"></p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.png" width="100%" height="100%"></p></li>
</ul>
<h1 id="二java部分">二、Java部分</h1>
<h2 id="安装jdk">2.1 安装JDK</h2>
<ul>
<li><p>若有安装过Java，则首先在控制面板中卸载以前版本的Java</p></li>
<li><p>到<a href="https://www.oracle.com/java/technologies/downloads/#java11">甲骨文的官网中下载JDK</a>，我这里选择的是JDK11，直接下载exe文件</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/8.png" width="80%" height="80%"></p></li>
<li><p>双击下载的exe文件一路无脑安转(只需要更改并记住安装路径)</p></li>
</ul>
<h2 id="配置java环境">2.2 配置Java环境</h2>
<ul>
<li><p>我的电脑处右键点击属性，找到并点击高级系统设置，点击环境变量</p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/9.png" width="50%" height="50%"></p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/10.png" width="60%" height="60%"></p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/11.png" width="60%" height="60%"></p></li>
<li><p>在系统变量(S)中点击新建</p>
<ul>
<li>设置JAVA_HOME：Name: <code>JAVA_HOME</code>，Value:
<code>你java的安装路径,bin文件夹所在的那个文件夹的路径</code></li>
</ul>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/12.png" width="80%" height="80%"></p>
<ul>
<li>双击系统变量(S)中的Path，添加两个变量<code>%JAVA_HOME%\bin</code>和<code>%JAVA_HOME%\jre\bin</code></li>
</ul>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/13.png" width="80%" height="80%"></p>
<ul>
<li>一路点确定即可</li>
</ul></li>
</ul>
<h2 id="vscode中配置java">2.3 VScode中配置Java</h2>
<ul>
<li><p>打开VScode安转Java插件<code>Extension Pack for Java</code></p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/14.png" width="80%" height="80%"></p></li>
<li><p>在设置中找到并打开settings.json文件，添加语句<code>"java.home": "你java的安装路径,bin文件夹所在的那个文件夹的路径",</code></p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/15.png" width="40%" height="40%"></p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/16.png" width="50%" height="50%"></p>
<p><img src="/2022/02/03/VScode-Anaconda-Pycharm-JDK%E7%9A%84Python%E5%92%8CJava%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/17.png" width="100%" height="100%"></p></li>
</ul>
<p>此时运行.java代码可以正常运行了，VScode中Java环境搭建完毕</p>
<p>VScode中Java环境搭建参考视频：<a href="https://www.bilibili.com/video/BV16y4y177b9?from=search&amp;seid=14977310378351523965&amp;spm_id_from=333.337.0.0">保姆级Java环境配置与VSCode配置</a></p>
]]></content>
      <categories>
        <category>重装-环境配置-计算机</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库学习</title>
    <url>/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="一mysql数据库在linux中的使用方法">一、Mysql数据库在Linux中的使用方法</h2>
<h3 id="修改密码">1.1 修改密码</h3>
<p>进入mysql前终端指令：</p>
<ul>
<li>查看mysql服务状态：<code>systemctl status mysql.service</code></li>
<li>查看mysql密码：<code>sudo cat /etc/mysql/debian.cnf</code></li>
</ul>
<p>根据查到的账号密码进入mysql：</p>
<ul>
<li><code>mysql -u debian-sys-maint -p</code></li>
<li>输入密码：（输入<code>debian-sys-maint</code>对应的密码即可）</li>
</ul>
<p>进入mysql后终端指令（指令以<code>;</code>结尾）：</p>
<ul>
<li>查看数据库：<code>show databases;</code></li>
<li>选择数据库：<code>use 数据库名;</code></li>
<li>查看表：<code>show tables;</code></li>
<li>查询表：<code>select * from 表名;</code></li>
<li>查看当前mysql用户：
<ul>
<li>先进入mysql数据库：<code>use mysql;</code></li>
<li>查看用户：<code>select user,host from user;</code></li>
<li>修改密码：<code>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'root';</code>后刷新权限：<code>flush privileges;</code></li>
<li>修改完密码后退出mysql：<code>exit;</code></li>
</ul></li>
</ul>
<p>修改完密码后，可以用新密码进入mysql：<code>mysql -u root -p</code></p>
<p>输入密码：<code>root</code>就可以进入</p>
<h3 id="终端使用mysqlsh来操作数据库">1.2
终端使用mysqlsh来操作数据库</h3>
<ul>
<li>下载mysql-shell：<code>sudo apt-get install mysql-shell</code></li>
<li>启动mysql-shell：<code>mysqlsh</code></li>
<li>连接数据库：<code>\connect root@localhost</code></li>
<li>输入上面修改后的密码：<code>root</code></li>
<li>查看数据库：<code>\sql show databases;</code></li>
</ul>
<h3 id="vscode中使用mysqlsh">1.3 vscode中使用mysqlsh</h3>
<ul>
<li>安装插件：<code>Mysql Shell for VS Code</code></li>
</ul>
<p>可能会出现错误：</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/err1.png"></p>
<p>根据错误提示在终端安装即可：</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/install.png"></p>
<p>然后<code>restart</code>即可</p>
<ul>
<li><p>重启后点击<code>New Connection</code>，输入连接信息(用户名、密码、端口等)，点击<code>OK</code>即可</p></li>
<li><p>配置完成后就可以在vscode中使用mysqlsh了，需要注意的是输入语句后需要按<code>ctrl+enter</code>才能执行</p></li>
</ul>
<h2 id="二mysql数据库基础操作">二、Mysql数据库基础操作</h2>
<h3 id="数据库的数据库表创建表格增删改查">2.1
数据库的数据库&amp;表创建、表格增删改查</h3>
<ul>
<li>创建数据库：<code>create database 数据库名;</code></li>
<li>删除数据库：<code>drop database 数据库名;</code></li>
<li>选择数据库：<code>use 数据库名;</code></li>
<li>创建表格：<code>create table 表名(字段名1 类型1, 字段名2 类型2, ...);</code></li>
<li>删除表格：<code>drop table 表名;</code></li>
<li>查看表格：<code>show tables;</code></li>
<li>查看表格结构：<code>desc 表名;</code></li>
<li>插入数据：<code>insert into 表名(字段1, 字段2, ...) values(值1, 值2, ...);</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> game;</span><br><span class="line">USE game;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> player (</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">	level <span class="type">INT</span>,</span><br><span class="line">	exp <span class="type">INT</span>,</span><br><span class="line">	gold <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> player MODIFY <span class="keyword">COLUMN</span> name <span class="type">VARCHAR</span>(<span class="number">200</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> player <span class="keyword">Add</span> <span class="keyword">COLUMN</span> last_login DATETIME;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> player;</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> player (id, name, level, exp, gold) <span class="keyword">VALUES</span> (<span class="number">1</span>, &quot;王五&quot;, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> player (id, name) <span class="keyword">VALUES</span> (<span class="number">2</span>, &quot;狂徒&quot;);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> player <span class="keyword">VALUES</span> (<span class="number">3</span>, &quot;某某&quot;, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> player MODIFY level <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> player (id, name) <span class="keyword">VALUES</span> (<span class="number">4</span>, &quot;张三&quot;), (<span class="number">5</span>, &quot;李四&quot;);</span><br><span class="line">UPDATE player <span class="keyword">set</span> level <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> name <span class="operator">=</span> &quot;狂徒&quot;;</span><br><span class="line">UPDATE player <span class="keyword">set</span> exp <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WHERE</span> exp <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player;</span><br></pre></td></tr></table></figure>
<h3 id="数据库的导入导出">2.2 数据库的导入导出</h3>
<ul>
<li>导出数据库：<code>mysqldump -u root -p 数据库名 &gt; 导出文件名.sql</code>
<ul>
<li>eg：<code>mysqldump -u root -p game &gt; game.sql</code></li>
</ul></li>
<li>导入数据库：<code>mysql -u root -p 数据库名 &lt; 导入文件名.sql</code>
<ul>
<li>eg：<code>mysql -u root -p game &lt; game.sql</code></li>
<li>然后按照提示输入密码，完成后刷新<code>navicate</code>的mysql数据库即可看到导入的数据库</li>
</ul></li>
</ul>
<p>b站一个up主提供的数据库练习资源文件： 百度网盘：
https://pan.baidu.com/s/1shKNzVv0KViftFx51KATnw?pwd=qgpv 提取码:
qgpv</p>
<h3 id="数据库的常用语句">2.3 数据库的常用语句</h3>
<h4 id="范围查询">2.3.1 范围查询</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> level <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> exp <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> level <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">OR</span> exp <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> exp <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">NOT</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<h4 id="模糊查询">2.3.2 模糊查询</h4>
<p>模糊查询通过通配符<code>LIKE</code>关键字实现，<code>%</code>表示任意多个字符，<code>_</code>表示一个字符（<code>_</code>的个数和字符个数相同）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%王%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;王_&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;王__&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="通配符匹配正则表达式">2.3.3 通配符匹配正则表达式</h4>
<p>这里的通配符是<code>REGEXP</code>，<code>^</code>表示开头，<code>$</code>表示结尾，<code>.</code>表示任意一个字符，<code>*</code>表示0个或多个，<code>+</code>表示1个或多个，<code>?</code>表示0个或1个，<code>[]</code>表示匹配其中任意一个字符，<code>[^]</code>表示不匹配其中任意一个字符</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/matchTips.png" width="50%" height="50%"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^王.$&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;王&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;[王张]&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;王|张&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>练习题：</p>
<h4 id="排序查询">2.3.4 排序查询</h4>
<p>使用<code>ORDER BY</code>关键字，默认或者<code>ASC</code>表示升序，<code>DESC</code>表示降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">ORDER</span> <span class="keyword">BY</span> level;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">ORDER</span> <span class="keyword">BY</span> level <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>练习题：</p>
<ul>
<li>按照等级降序排列后，再根据经验升序排序：
<ul>
<li><code>SELECT * FROM player ORDER BY level DESC, exp;</code></li>
</ul></li>
<li>按照第五列降序排列：
<ul>
<li><code>SELECT * FROM player ORDER BY 5 DESC;</code></li>
</ul></li>
</ul>
<h4 id="聚合函数">2.3.5 聚合函数</h4>
<p>聚合函数是对一组<strong>数据进行计算</strong>的函数，常用的聚合函数有<code>COUNT</code>、<code>SUM</code>、<code>AVG</code>、<code>MAX</code>、<code>MIN</code></p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/aggregate.png" width="50%" height="50%"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> player;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(level) <span class="keyword">FROM</span> player;</span><br></pre></td></tr></table></figure>
<p>**count (*)、count(1)、count(字段名)的区别**：</p>
<p>在索引下count都不用回表</p>
<ul>
<li><code>count(*)</code>：
<ul>
<li>count的值：相当于<code>count(0)</code>，会统计所有行数，包括<code>null</code>值</li>
<li>性能：性能跟<code>count(1)</code>一样，都会优先len最短的二级索引，Ali要求尽量用<code>count(*)</code></li>
</ul></li>
<li><code>count(1)</code>：
<ul>
<li>count的值：会统计所有行数，包括<code>null</code>值</li>
<li>性能：性能跟<code>count(*)</code>一样，都会优先len最短的二级索引，Ali要求尽量用<code>count(*)</code></li>
</ul></li>
<li><code>count(字段名)</code>：count的是该字段下非NULL的行数
<ul>
<li><code>count (主键)</code>：由于主键都是非NULL的，所以<code>count(主键)</code>不用额外判断，性能比<code>count(其他字段)</code>好</li>
<li><code>count(字段名)</code>：需要进行非NULL判断，性能最差</li>
</ul></li>
</ul>
<p>性能比较：**count(*) = count(1) &gt; count(主键) &gt;
count(字段名)**</p>
<h4 id="分组查询">2.3.6 分组查询</h4>
<p>使用<code>GROUP BY</code>关键字对查询结果进行分组，<code>HAVING</code>关键字对分组后的结果进行过滤</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sex, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> player <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex;</span><br><span class="line"><span class="keyword">SELECT</span> level, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> player <span class="keyword">GROUP</span> <span class="keyword">BY</span> level;</span><br><span class="line"><span class="keyword">SELECT</span> level, <span class="built_in">COUNT</span>(level) <span class="keyword">FROM</span> player <span class="keyword">GROUP</span> <span class="keyword">BY</span> level <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(level)<span class="operator">&gt;</span><span class="number">4</span>;</span><br><span class="line"><span class="keyword">SELECT</span> level, <span class="built_in">COUNT</span>(level) <span class="keyword">FROM</span> player <span class="keyword">GROUP</span> <span class="keyword">BY</span> level <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(level) <span class="operator">&gt;</span> <span class="number">4</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> level;</span><br></pre></td></tr></table></figure>
<h4 id="去重查询">2.3.7 去重查询</h4>
<p>使用<code>DISTINCT</code>关键字对查询结果进行去重</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sex <span class="keyword">FROM</span> player;</span><br></pre></td></tr></table></figure>
<h4 id="并集">2.3.8 并集</h4>
<p>使用<code>UNION</code>关键字对两个查询结果进行合并（UNION会默认去重，如果不想去重可以使用<code>UNION ALL</code>）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> exp <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> exp <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="交集">2.3.9 交集</h4>
<p>使用<code>INTERSECT</code>关键字对两个查询结果进行交集运算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> exp <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="差集">2.3.10 差集</h4>
<p>使用<code>EXCEPT</code>关键字对两个查询结果进行差集运算</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> exp <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="子查询">2.4 子查询</h3>
<p>子查询是指在<strong>查询语句中嵌套查询语句</strong>，子查询可以嵌套多层，子查询的结果可以是单行单列，也可以是多行多列</p>
<p>比如，我们需要查找表格中等级大于平均等级的玩家，那么我们可以根据下面的步骤进行：</p>
<ul>
<li>先计算平均等级
<ul>
<li><code>SELECT AVG(level) FROM player;</code></li>
</ul></li>
<li>然后再查询大于平均等级的玩家
<ul>
<li><code>SELECT * FROM player WHERE level &gt; (SELECT AVG(level) FROM player);</code></li>
</ul></li>
</ul>
<p>接着，我们还想单独取出表格中<code>level</code>一列，并列出<code>每个玩家的等级-平均等级</code>的值作为单独一列，并给这一列取个别名为<code>diff</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> level, </span><br><span class="line">level<span class="operator">-</span>ROUND((<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(level) <span class="keyword">FROM</span> player)) <span class="keyword">AS</span> diff</span><br><span class="line"><span class="keyword">FROM</span> player;</span><br></pre></td></tr></table></figure>
<p>可以根据查询结果，将查询结果作为新表格（创建一个新表格或插入其它表格中）：</p>
<ul>
<li>创建新表格：
<ul>
<li><code>CREATE TABLE new_player (SELECT * FROM player WHERE level &lt; 5);</code></li>
</ul></li>
<li>插入其它表格：
<ul>
<li><code>INSERT INTO new_player (SELECT * FROM player WHERE level BETWEEN 7 AND 10);</code></li>
</ul></li>
</ul>
<p>用<code>exists</code>关键字来判断<strong>子查询结果</strong>是否存在：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&gt;</span> <span class="number">100</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&gt;</span> <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<h3 id="表关联">2.5 表关联</h3>
<p>表关联是指<strong>将多个表格的数据进行关联</strong>，主要的关键词是<code>JOIN</code>，常用的关联方式有<code>INNER JOIN</code>、<code>LEFT JOIN</code>、<code>RIGHT JOIN</code>、<code>FULL JOIN</code></p>
<h4 id="内连接">2.5.1 内连接</h4>
<p><strong>内连接</strong>（<code>INNER JOIN</code>）：只返回两个表格中满足条件的数据（只会显示匹配的数据）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> equip</span><br><span class="line"><span class="keyword">ON</span> player.id <span class="operator">=</span> equip.player_id;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/innerJoin.png"></p>
<p>内连接方式可以用<code>WHERE</code>关键字来等同实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player p, equip e</span><br><span class="line"><span class="keyword">WHERE</span> p.id <span class="operator">=</span> e.player_id;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/innerJoin2.png"></p>
<h4 id="左连接">2.5.2 左连接</h4>
<p><strong>左连接</strong>（<code>LEFT JOIN</code>）：返回<strong>左表格</strong>中<strong>所有数据</strong>+右表格中满足条件的数据（会返回左表所有的数据，右表中无匹配的数据则显示<code>NULL</code>）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> equip</span><br><span class="line"><span class="keyword">ON</span> player.id <span class="operator">=</span> equip.player_id;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/leftJoin.png"></p>
<h4 id="右连接">2.5.3 右连接</h4>
<p><strong>右连接</strong>（<code>RIGHT JOIN</code>）：返回<strong>右表格</strong>中<strong>所有数据</strong>，左表格中满足条件的数据（会返回右表所有的数据，左表中无匹配的数据则显示<code>NULL</code>）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> equip</span><br><span class="line"><span class="keyword">ON</span> player.id <span class="operator">=</span> equip.player_id;</span><br></pre></td></tr></table></figure>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/rightJoin.png"></p>
<h3 id="索引">2.6 索引</h3>
<p>索引是对数据库表格中<strong>某列或多列的值进行排序</strong>的一种结构，索引可以大大提高查询效率，如果没有索引，数据库会进行<strong>全表扫描</strong>，效率会很低（创建索引可以提高效率）</p>
<p>常用的索引有<code>UNIQUE</code>（唯一索引）、<code>FULLTEXT</code>（全文索引）、<code>SPATIAL</code>（空间索引）</p>
<p>创建索引的通用语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL] INDEX 索引名 <span class="keyword">ON</span> 表名(列名);</span><br></pre></td></tr></table></figure>
<p>一般会对<strong>主键字段</strong>或者<strong>常用于查询的字段</strong>创建索引</p>
<ul>
<li>查看表格当前含有的索引：<code>SHOW INDEX FROM 表名;</code>
<ul>
<li><code>SHOW INDEX FROM npc;</code></li>
<li>可以看到主键<code>id</code>已经有了一个索引</li>
</ul></li>
<li>创建索引：<code>CREATE INDEX 索引名 ON 表名(字段名);</code>
<ul>
<li><code>CREATE INDEX name_index ON npc(name);</code></li>
<li>此时再查看索引，可以多了一个<code>name</code>字段的索引</li>
</ul></li>
</ul>
<p>比较有查询和无查询的效率：</p>
<p>将<code>npc</code>表格copy一份到<code>npc_slow</code>表格中：</p>
<ul>
<li><code>CREATE TABLE npc_slow (SELECT * FROM npc);</code></li>
<li>查询<code>npc_slow</code>表格中是没有任何索引的</li>
</ul>
<p>此时对<code>npc</code>表格和<code>npc_slow</code>表格中的<code>id</code>字段进行查询观察区别</p>
<p>删除索引：<code>DROP INDEX 索引名 ON 表名;</code></p>
<h3 id="视图">2.7 视图</h3>
<p>视图是<strong>虚拟的表格</strong>，是一个<strong>查询结果</strong>的存储，包含了<strong>行和列</strong>。（视图不包含数据，只包含查询语句）。由于视图只包含查询语句，因此视图是<strong>动态的</strong>，会随着数据的改变而改变查询结果，每次查询视图时都会执行查询语句。</p>
<p>创建视图的通用语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名 <span class="keyword">AS</span> 查询语句;</span><br></pre></td></tr></table></figure>
<p>比如我们想存一个<code>level</code>为top10的玩家视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> top10</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">ORDER</span> <span class="keyword">BY</span> level <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>然后就可以使用正常的查询语句来查询视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> top10;</span><br></pre></td></tr></table></figure>
<p>修改视图：<code>ALTER VIEW 视图名 AS 查询语句;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> top10</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">ORDER</span> <span class="keyword">BY</span> level LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>查看已有的视图：<code>SHOW TABLES;</code></p>
<p>删除视图：<code>DROP VIEW 视图名;</code></p>
<h2 id="三mysql原理">三、MySQL原理</h2>
<h3 id="事务">3.1 事务</h3>
<h4 id="事务的基础概念">3.1.1 事务的基础概念</h4>
<p>事务是指<strong>一组SQL语句</strong>组成的<strong>操作序列</strong>，这组操作要么全部成功，要么全部失败，事务是数据库管理系统执行的<strong>最小工作单位</strong>。</p>
<ul>
<li>如在银行操作中，A转账给B，要经过两个步骤：1. A账户减少金额；2.
B账户增加金额。这两个步骤要么同时成功(commit)，要么同时失败(rollback全部回滚)。</li>
</ul>
<p>事务的四个特性是ACID：<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>、<strong>持久性</strong></p>
<p><strong>1）原子性（atomicity）-基础</strong>：事务是一个不可分割的工作单位（整体性），要么全部成功，要么全部失败，用<strong>commit</strong>来结束一个事务，由<strong>事务回滚undo日志</strong>来实现</p>
<p><strong>2）一致性（consistency）-约束条件</strong>：事务执行前后，数据会从一个<strong>语义合法状态</strong>转换到另一个<strong>语义合法状态</strong>，即事务执行前后数据的<strong>完整性约束</strong>没有被破坏（满足现实中的约束）</p>
<ul>
<li>如：A有200元（合法），转帐300元出去变成-100元（不合法），这就是不一致的状态，所以必须定义约束就是余额大于等于0</li>
<li>如：表中把name设置成唯一约束，但是由于事务提交或者回滚导致了重复的name，破坏了约束</li>
<li>如：A转账100w给B，A扣除100w成功后，服务器宕机了，B没有收到100w，也破坏了完整性约束</li>
</ul>
<p><strong>3）隔离性（isolation）-手段</strong>：多个事务之间是相互隔离的，一个事务的执行不会影响其它事务，能够处理并发情况</p>
<p>隔离性四个级别：<strong>读未提交</strong>、<strong>读已提交</strong>、<strong>可重复读（InnoDB默认的）</strong>、<strong>串行化</strong></p>
<ul>
<li><p><strong>脏读</strong>：一个事务读取到另一个事务未提交的数据</p>
<ul>
<li>解决：通过<strong>读已提交</strong>级别来解决，保证一个事务内读到的数据起码是已经提交的数据
<img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/dirty_read.png" width="50%"></li>
</ul></li>
<li><p><strong>不可重复读</strong>：一个事务多次读取同一数据，得到两次读取的数据不一致（其他事务更改了该数据）</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/non-repeating0.png" width="50%"></p>
<ul>
<li>解决：通过<strong>可重复读</strong>级别来解决，保证一个事务内多次读的数据都是初始读的数据的<strong>快照</strong>
<img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/non-repeating.png" width="50%"></li>
</ul></li>
<li><p><strong>幻读</strong>：幻读是一个事务内多次查询某个符合查询条件的<strong>记录数量</strong>时会出现前后不一样的情况</p>
<ul>
<li>解决：通过<strong>串行化</strong>级别来解决，保证事务执行时不会有其他事务的干扰，但是并行能力会降低
<img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/phantom-reads.png" width="50%"></li>
</ul></li>
<li><p><strong>串行化</strong>：最高级别，事务串行执行，通过<strong>锁</strong>来实现</p>
<ul>
<li>如：当事务A对某一行数据进行操作且未提交时，事务B想查询该行数据时会<strong>被阻塞</strong>，直到事务A提交或回滚</li>
</ul></li>
</ul>
<p><strong>4）持久性</strong>：事务一旦提交，对数据库的改变是永久性的，通过<strong>日志（redo重做日志-系统崩溃后重做提交的事务，undo回滚日志）</strong>来实现</p>
<p>四个特性的总结：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">特性</th>
<th style="text-align: center;">特性得以保证的技术</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">原子性</td>
<td style="text-align: center;">undo回滚日志</td>
</tr>
<tr>
<td style="text-align: center;">一致性</td>
<td style="text-align: center;">原子+隔离+持久</td>
</tr>
<tr>
<td style="text-align: center;">隔离性</td>
<td style="text-align: center;">MVCC多版本并发控制、加锁机制</td>
</tr>
<tr>
<td style="text-align: center;">持久性</td>
<td style="text-align: center;">redo重做日志</td>
</tr>
</tbody>
</table>
<p>四个事务隔离级别的总结：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">隔离级别</th>
<th style="text-align: center;">无脏读</th>
<th style="text-align: center;">无不可重复读</th>
<th style="text-align: center;">无幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">读未提交</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">读已提交</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">可重复读</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: left;">串行化</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
<td style="text-align: center;">√</td>
</tr>
</tbody>
</table>
<p><strong>可重复读真的完全可重复读吗？</strong></p>
<p>由于存在<strong>快照读</strong>和<strong>当前读</strong>，如果前后全部是<strong>快照读</strong>是可以保证<strong>可重复读</strong>的</p>
<p>但是如果有<strong>当前读</strong>的话，也就是事务中出现了<strong>update、for
update的写操作</strong>，那么就会出现<strong>不可重复读</strong>的情况</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/repeatable-read.png" width="50%"></p>
<h4 id="事务的隔离级别">3.1.2 事务的隔离级别</h4>
<p>上面提到，事务在并发时有<strong>脏读</strong>、<strong>不可重复读</strong>、<strong>幻读</strong>的问题：</p>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 22%">
<col style="width: 72%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">并发问题</th>
<th style="text-align: center;">说明</th>
<th style="text-align: center;">解决方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">脏读</td>
<td style="text-align: center;">读到其他事务<strong>未提交的数据</strong></td>
<td style="text-align: center;">读已提交：每条语句前创建一个<strong>快照</strong></td>
</tr>
<tr>
<td style="text-align: center;">不可重复读</td>
<td style="text-align: center;">一个事务内前后读的<strong>数据</strong>内容不一样</td>
<td style="text-align: center;">可重复读：每个事务读到的数据都是初始读的数据的<strong>快照</strong>（MVCC）</td>
</tr>
<tr>
<td style="text-align: center;">幻读</td>
<td style="text-align: center;">一个事务内前后读的<strong>记录数量</strong>不一样</td>
<td style="text-align: center;">串行化：事务串行执行，通过<strong>select
for update的next-key
lock（行级锁+间隙锁）</strong>来实现（读写冲突时锁住）</td>
</tr>
</tbody>
</table>
<p><strong>Read View在MVCC中的工作原理</strong></p>
<p>Read View快照中有四个字段：</p>
<ul>
<li><code>creator_trx_id</code>：创建该快照的事务ID</li>
<li><code>m_ids</code>：创建快照时，所有<strong>活跃且未提交的事务</strong>ID</li>
<li><code>min_trx_id</code>：创建快照时，<strong>活跃且未提交事务中的最小<code>m_ids</code></strong>，<code>trx_id&lt;=min_trx_id</code>的事务都是当前快照可见的</li>
<li><code>max_trx_id</code>：创建快照时，当前数据库应该<strong>给下一个事</strong>务的ID</li>
</ul>
<p>当对某种表进行操作时，会有两个隐藏列，字段为<code>trx_id</code>和<code>roll_pointer</code>
- <code>trx_id</code>是执行当前事务的事务ID -
<code>roll_pointer</code>是当前事务的回滚指针，指向一个<strong>undo日志中的旧版本</strong></p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/two-hidden-columns.png" width="50%"></p>
<p>结合上面快照的几个字段，可以将事务id区分为如下图所示：</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/trx-id.png" width="50%"></p>
<p>这种就是通过<code>trx_id</code>构成<strong>版本链</strong>控制并发事务对同一个记录的行为，这种叫做<strong>多版本并发控制（MVCC）</strong></p>
<h4 id="事务的sql举例">3.1.3 事务的sql举例</h4>
<ul>
<li>开始事务：<code>START TRANSACTION;</code> 或
<code>BEGIN;</code></li>
<li>提交事务：<code>COMMIT;</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE sqlTest;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user(</span><br><span class="line">name VARCHAR(15) PRIMARY KEY,</span><br><span class="line">age INT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*) FROM user;</span><br><span class="line"></span><br><span class="line">INSERT INTO user VALUES(&#x27;akira&#x27;, 19);</span><br><span class="line">INSERT INTO user VALUES(&#x27;yangnan&#x27;, 18);</span><br><span class="line"></span><br><span class="line">SELECT * FROM user WHERE name=&#x27;akira&#x27;;# 同一事务内可以查询到更改</span><br><span class="line"></span><br><span class="line">SELECT COUNT(*)FROM user;</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
<h3 id="锁">3.2 锁</h3>
<p><strong>全表扫描</strong>时会对表中<strong>每一条数据加锁</strong></p>
<h4 id="锁的基础概念">3.2.1 锁的基础概念</h4>
<p>并发情况下的加锁方案：</p>
<ul>
<li>方案一：<strong>读用MVCC，写用加锁</strong>，读的可能是旧版本，但是性能更高</li>
<li>方案二：<strong>读写都用加锁</strong>，读写都是最新版本</li>
</ul>
<h5 id="全局锁read-lock">1）全局锁<code>READ LOCK</code></h5>
<p>整个数据库处于<strong>只读</strong>状态，适用于做<strong>全库备份</strong></p>
<ul>
<li>失效的操作：<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>ALTER</code>、<code>DROP</code>等(数据增删改、表结构变更)</li>
<li>加锁：<code>FLUSH TABLES WITH READ LOCK;</code></li>
<li>解锁：<code>UNLOCK TABLES;</code></li>
</ul>
<h5 id="表级锁">2）表级锁</h5>
<p>读写锁：</p>
<ul>
<li><strong>表级读锁-读共享锁-S锁</strong>：<code>LOCK TABLES table_name READ;</code>
<ul>
<li>加读锁的作用是<strong>防止其他事务对表进行写操作</strong>，但是不阻止其他事务对表进行读操作</li>
</ul></li>
<li><strong>表级写锁-写独占锁-X锁</strong>：<code>LOCK TABLES table_name WRITE;</code>
<ul>
<li>加写锁的作用是防止其他事务对表进行<strong>读写操作</strong></li>
</ul></li>
</ul>
<p>意向锁：意向锁与<strong>行级锁</strong>不冲突，表示有意向对表中的某些行加锁。正因为如此，意向锁并<strong>不会影响到多个事务对不同数据行加排他锁时的并发性</strong></p>
<p>作用：意向锁的目的是为了快速判断表里是否有记录被加锁，从而避免了直接对表加锁，提高了并发性</p>
<ul>
<li><strong>意向共享锁-IS</strong>：<code>select ... lock in share mode;</code>
<ul>
<li>用于<strong>表级锁</strong>，表示<strong>准备对表进行读操作</strong>，但是不会立即加锁，只是表示<strong>准备加锁</strong>，如果有<strong>写锁</strong>则会等待</li>
</ul></li>
<li><strong>意向独占锁-IX</strong>：<code>select ... for update;</code>
<ul>
<li>用于<strong>表级锁</strong>，表示<strong>准备对表进行写操作</strong>，但是不会立即加锁，只是表示<strong>准备加锁</strong></li>
</ul></li>
</ul>
<h5 id="行级锁">3）行级锁</h5>
<p>普通的<code>select</code>语句属于快照读，不会加锁，因此需要在查询语句中手动进行加锁</p>
<p>行级锁的实现语句也是<code>select ... for update;</code>，表示<strong>对查询到的行加锁</strong>，加完锁后其他事务就无法对加锁的行进行<strong>更新/删除/插入</strong>操作了</p>
<p>行级锁一般有三种，行级锁的加锁对象一般是<strong>索引</strong>：</p>
<ul>
<li><code>Record Lock</code>：记录锁，锁住某一行（一条）数据
<ul>
<li><code>select * from user where id=1 for update;</code>，其中id为主键</li>
</ul></li>
<li><code>Gap Lock</code>：间隙锁，锁住某一行数据之间的间隙，区间是<strong>前开后开</strong>
<ul>
<li>假设有一个范围为(3,5)的间隙锁区间，其他事务无法插入id=4的记录，可以有效<strong>防止幻读</strong></li>
</ul></li>
<li><code>Next-Key Lock</code>：行锁+间隙锁，锁住某一行数据和其之间的间隙，区间是<strong>前开后闭</strong>，在一些情况下会退化成<strong>记录锁/间隙锁</strong>
<ul>
<li>假设有一个范围为(3,5]的间隙锁区间，其他事务无法插入id=4的记录，也无法修改id=5的记录</li>
<li>假设<code>select * from user where id &gt;= 15</code>则会锁住(15,+∞]的区间</li>
</ul></li>
</ul>
<h4 id="死锁的出现与解决">3.2.2 死锁的出现与解决</h4>
<p>出现死锁的四个条件：<strong>互斥、占有并等待、不可抢占、循环等待</strong></p>
<p>死锁的出现：事务1和事务2都在等对方释放锁</p>
<p>死锁的排查：<code>SHOW ENGINE INNODB STATUS;</code>，查看死锁日志</p>
<p>死锁的解决：</p>
<ul>
<li><strong>超时机制</strong>：设置一个超时时间，如果超过这个时间还没有解锁，则自动解锁</li>
<li><strong>死锁检测</strong>：检测到死锁后，自动回滚一方的事务</li>
<li><strong>尽量不要逆序加锁</strong></li>
</ul>
<p>下面举一个逆序加锁的例子：</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/deadlock.png" width="80%"></p>
<h3 id="约束">3.3 约束</h3>
<h4 id="主键约束primary-key">1）主键约束：<code>PRIMARY KEY</code></h4>
<ul>
<li>可以有一列或者多列组合但是必须是唯一组合，主键是表格中的<strong>唯一标识</strong></li>
<li>一个表格只能有<strong>一个主键</strong></li>
<li>主键<strong>不能为<code>NULL</code></strong></li>
</ul>
<p>单一主键可以在创建该列时添加，也可以在<code>CREATE TABLE</code>的末尾添加：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">   user_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   username <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">   password <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">   email <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">   user_id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">   username <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">   password <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">   email <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(user_id)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<p>而多列主键只能在<code>CREATE TABLE</code>的末尾添加：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_roles(</span><br><span class="line">   user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   role_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(user_id,role_id),</span><br><span class="line">   <span class="keyword">FOREIGN</span> KEY(user_id) <span class="keyword">REFERENCES</span> users(user_id),</span><br><span class="line">   <span class="keyword">FOREIGN</span> KEY(role_id) <span class="keyword">REFERENCES</span> roles(role_id)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h4 id="外键约束foreign-key">2）外键约束：<code>FOREIGN KEY</code></h4>
<p>MySQL的外键约束用来在两个表数据之间建立链接，其中一张表的一个字段被另一张表中对应的字段约束。也就是说，设置外键约束至少要有两种表，被约束的表叫做从表（子表），另一张叫做主表（父表），属于主从关系。</p>
<p>关于保证表的完整性可以用以下例子说明：</p>
<p>假如有两种表，一张用户账户表（用于存储用户账户），一张是账户信息表（用于存储账户中的信息）。</p>
<p>1）我不小心将用户账户表中的某个用户删除了，那么账户信息表中与这个用户有关的数据就变成无源数据了，找不到其属于哪个用户账户，导致用户信息不完整。</p>
<p>2）我在账户信息表中随便添加了一条数据，而其在用户账户表中没有对应的用户，这样用户信息也是不完整的。</p>
<p>为了解决这个问题，我们可以在账户信息表中添加一个外键约束，这个外键约束指向用户账户表中的用户ID，这样就可以保证账户信息表中的数据是完整的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">   user_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">   username <span class="type">VARCHAR</span>(<span class="number">40</span>),</span><br><span class="line">   password <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">   email <span class="type">VARCHAR</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_roles(</span><br><span class="line">   user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   role_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY(user_id,role_id),</span><br><span class="line">   <span class="keyword">FOREIGN</span> KEY(user_id) <span class="keyword">REFERENCES</span> users(user_id),</span><br><span class="line">   <span class="keyword">FOREIGN</span> KEY(role_id) <span class="keyword">REFERENCES</span> roles(role_id)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h4 id="唯一约束unique">3）唯一约束：<code>UNIQUE</code></h4>
<p>唯一约束保证了列中的所有数据是唯一的，但是可以有<code>NULL</code>值</p>
<p>唯一性约束同样可以对单列或者多列进行约束：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_1(</span><br><span class="line">   ...</span><br><span class="line">   column_name_1 data_type,</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">UNIQUE</span>(column_name_1)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_1(</span><br><span class="line">   ...</span><br><span class="line">   column_name_1 data_type,</span><br><span class="line">   column_name_2 data_type,</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">UNIQUE</span>(column_name_1,column_name_2)</span><br><span class="line">); </span><br></pre></td></tr></table></figure>
<h3 id="三大范式">3.4 三大范式</h3>
<p><strong>1）第一范式</strong>：每一列都是不可再分的最小单元，即每一列都是原子的，不可再分</p>
<p>比如，我们在课程表中有一个<code>tags</code>字段，但是tags是多个标签组成的，不符合第一范式</p>
<p>解决：我们可以将<code>tags</code>字段拆分成多个字段，比如<code>tag1</code>、<code>tag2</code>、<code>tag3</code>等存在一个<code>tags</code>表中</p>
<p>这里就涉及表之间的<strong>链接表</strong>来实现，链接表通常是一个<strong>多对多</strong>的关系，包含两个表的<code>id</code>字段，比如<code>course_id</code>和<code>tag_id</code></p>
<p><strong>2）第二范式</strong>：表中的每一列都与主键相关，即表中的每一列都是完全依赖于主键的，而不是依赖于主键的一部分</p>
<p>第二范式要求如果某一列数据表示的内容不属于这个表的实体，那么这个列就应该独立出来，成为一个新的表，然后通过关联来连接这两个表</p>
<p>以下面的例子为例，如果name不单独作为一张表记录，那么当用户名更改时，所有name的记录都需要更改；且重复存储char会浪费空间</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/2NF.png" width="80%"></p>
<p><strong>3）第三范式</strong>：表中的每一列都与主键直接相关，而不是间接相关</p>
<p>如一个表中有<code>invoice_total</code>、<code>payment_total</code>、<code>balance</code>三个字段</p>
<p>其中<code>balance</code>字段是通过<code>invoice_total</code>和<code>payment_total</code>计算得到的</p>
<p>那么<code>balance</code>字段就不符合第三范式，如果修改了<code>invoice_total</code>或者<code>payment_total</code>，那么<code>balance</code>字段忘记修改就会出现问题</p>
<p>解决：删掉<code>balance</code>字段</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/3NF.png" width="80%"></p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/3NF_2.png" width="80%"></p>
<h3 id="索引ologn">3.5 索引：O(logn)</h3>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span> INDEX index_name (`age`);# 单一索引</span><br><span class="line"><span class="keyword">ADD</span> INDEX index_name (`age`, `name`);# 联合索引</span><br></pre></td></tr></table></figure>
<p><strong>为什么要建立索引？</strong></p>
<p>如果没建立索引，那么查询数据时聚簇索引只有主键，因此其他字段的查询是<strong>全表扫描</strong>，时间复杂度是<code>O(n)</code></p>
<p>而建立索引后，可以通过索引进行<strong>二分查找</strong>，时间复杂度是<code>O(logn)</code></p>
<h4 id="b树索引">3.5.1 B+树索引</h4>
<p><strong>1）比较使用其他数据结构</strong></p>
<ul>
<li>二叉查找树：解决了<strong>插入和查找</strong>问题，但是当所有插入的值都是最大值时会退化成<strong>链表</strong>，查询效率又退化成<code>O(n)</code>而非<code>O(logn)</code>;树的高度高，磁盘I/O次数多</li>
<li>平衡二叉树（如红黑树）：控制<strong>左子树和右子树的高度差不能超过1</strong>，解决链表退化问题，但是依然是二叉树（二叉树每个节点只能有左右两个子节点），高度依然很高</li>
<li>B树：<strong>每个子节点可以有M个节点</strong>，降低了树的高度，但是每个节点<strong>都会存所有数据</strong>（不仅存索引值），浪费空间（B树查询时间比B+树短一些）</li>
<li>B+树：<strong>非叶子节点只存索引</strong>，<strong>叶子节点存所有数据，以有序链表的形式构成（InnoDB用双向链表）</strong>，<strong>叶子节点之间有指针相连</strong>，降低了树的高度，减少了磁盘I/O次数；且相比B树，B+树有很多冗余节点，<strong>插入、删除和范围查询（因为有有序的叶子节点链表）</strong>更简单</li>
</ul>
<p><strong>2）B+树的特点</strong></p>
<p>MySQL的数据（索引+记录）的存储是持久化在磁盘的，所以如果单纯靠磁盘读取查询的话速度很慢，通常需要将磁盘中的数据先读取到内存中，所以要求数据结构的树高度尽量低，这样可以减少磁盘I/O次数</p>
<p>索引通过<strong>B+树</strong>作为数据结构存储数据，能够快速定位到数据，<strong>提高查询效率</strong>。索引的原理是在<strong>插入和更新</strong>时会先对数据进行排序，因此会影响插入和更新的效率</p>
<p>B+树的特点：B+树比红黑树的排序效率高，他是<strong>基于磁盘（磁盘页16K）的平衡树</strong>，具有<strong>通过增加宽度减少高度</strong>的特点，减少磁盘I/O次数。且排序后的数据全部放在<strong>叶子节点</strong>上，非叶子节点只存储索引。</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/B+tree.png" width="80%"></p>
<p><strong>3）优化B+树的插入速度</strong></p>
<p>如果插入是<strong>顺序插入</strong>的话，B+树的插入速度会很高，因为顺序插入不会导致树的平衡性被破坏，只需要在叶子节点上插入即可（如果非顺序需要经历<strong>分裂</strong>、<strong>旋转</strong>等操作）</p>
<p>所以一般会用<strong>自增id</strong>等有顺序的值作为主键。</p>
<h4 id="索引的类型">3.5.2 索引的类型</h4>
<h5 id="聚簇索引只有一个">1）聚簇索引：只有一个</h5>
<p>聚簇索引是一种<strong>数据存储方式，是针对主键搭建的B+树</strong>，中间节点存<strong>主键值和页码</strong>，叶子节点存<strong>主键值+所有完整数据本身</strong>，在InnoDB中不需要显示用<code>INDEX</code>创建索引，天然在创建含主键的表时就会生成，要求尽量用<strong>自增id</strong>作为主键</p>
<p>由于聚餐索引也是数据物理存储的方式，因此<strong>一个表只有一个聚簇索引（这里也对应了一个表只能有一个主键）</strong>，如果没有主键也没有唯一索引，Innodb会自动隐式定义一个</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/clustered-index.png" width="80%"></p>
<h5 id="二级索引非聚簇索引可以有多个">2）二级索引（非聚簇索引）：可以有多个</h5>
<p>二级索引的叶子节点存数据时只存储<strong>索引值和主键值，而不是表中的所有数据，并按照索引值作为排序</strong>，因此在查询时需要先通过二级索引找到主键值，再通过主键值找到数据（也就是<strong>回表</strong>），所以二级索引的查询效率比聚簇索引低</p>
<p>聚簇索引与二级索引的比较：聚簇索引查询速度更快（不用回表），但是插入、更新、删除速度慢（因为任何字段的更改都会影响到聚簇索引）</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/secondary-index.png" width="80%"></p>
<h5 id="联合索引多个字段组合可以有多个">3）联合索引：多个字段组合，可以有多个</h5>
<p>联合索引根据从左到右的顺序建立，左边字段的排序优先于右边字段，联合索引的叶子节点存储的是<strong>联合索引字段的值+主键值</strong>，依然需要回表</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/union-index.png" width="80%"></p>
<p><strong>索引覆盖：</strong></p>
<p>如果<strong>查询的字段在全部在联合索引叶子结点</strong>中，那么可以直接通过索引找到数据，不需要回表，这种情况叫做<strong>索引覆盖</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 假设表中有字段：name、age、sex，联合索引为(age,sex)</span><br><span class="line"></span><br><span class="line"># <span class="number">1.</span> 回表索引：选择的列联合索引不能完全包含，需要回表</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span> 索引覆盖：选择的列联合索引完全包含，不需要回表</span><br><span class="line"><span class="keyword">SELECT</span> age <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="keyword">SELECT</span> age <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">12</span> <span class="keyword">AND</span> sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>最左匹配原则：</strong></p>
<p>如果查询条件中包含了<strong>联合索引的前缀</strong>，那么可以使用联合索引，否则无法使用</p>
<p>联合索引启用的时机：比如有字段<code>(name,age,sex)</code>组成的联合索引，最左的原则就是<code>name-&gt;age-&gt;sex</code>，当查询条件中包含<code>name</code>和<code>age</code>时（允许<code>name</code>和<code>age</code>的顺序可以颠倒），可以使用联合索引，但是如果只包含<code>age</code>和<code>sex</code>时，因为缺少最左的<code>name</code>字段，无法使用联合索引</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/left-match.png" width="80%"></p>
<h5 id="三种索引总结">4）三种索引总结</h5>
<table>
<thead>
<tr>
<th style="text-align: center;">索引类型</th>
<th style="text-align: center;">叶子节点存数据</th>
<th style="text-align: center;">查询效率</th>
<th style="text-align: center;">插删改效率</th>
<th style="text-align: center;">回表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">聚簇索引</td>
<td style="text-align: center;">主键值+所有数据</td>
<td style="text-align: center;">高</td>
<td style="text-align: center;">较低</td>
<td style="text-align: center;">无</td>
</tr>
<tr>
<td style="text-align: center;">二级索引</td>
<td style="text-align: center;">索引值+主键值</td>
<td style="text-align: center;">较低</td>
<td style="text-align: center;">高</td>
<td style="text-align: center;">覆盖查询无，否则有</td>
</tr>
<tr>
<td style="text-align: center;">联合索引</td>
<td style="text-align: center;">索引值+主键值</td>
<td style="text-align: center;">较低</td>
<td style="text-align: center;">高</td>
<td style="text-align: center;">覆盖查询无，否则有</td>
</tr>
</tbody>
</table>
<h4 id="索引失效">3.5.3 索引失效</h4>
<p>当索引失效时会采用全表扫描，效率会降低</p>
<p><strong>1）模糊查询</strong></p>
<p>当使用模糊查询模糊查找后面的字符，如<code>like %xx</code>或者<code>like %xx%</code>而不是从开头第一个字符开始查询时，索引会失效</p>
<p><strong>2）表达式计算</strong></p>
<p>当查询条件中有表达式计算时，如<code>where age+1=12</code>，索引会失效</p>
<p><strong>3）数据类型隐式转换</strong></p>
<p>如<code>phoneNum</code>在表中用<code>varchar</code>存储，但是查询时用<code>int</code>类型，会导致索引失效</p>
<p><strong>4）联合索引非最左匹配</strong></p>
<h4 id="索引设计原则用还是不用">3.5.4 索引设计原则：用还是不用？</h4>
<p><strong>1）什么情况下适合加索引</strong></p>
<ul>
<li><strong>主键</strong>：主键是表的唯一标识，必须加索引</li>
<li><strong>唯一性约束（区分度高的列）</strong>：如学号具有唯一性，必须加索引来加快查询</li>
<li><strong>频繁用于WHERE查询（特别是update、delete的WHERE查询）</strong>：如果某个字段经常用于查询，可以加索引</li>
<li><strong>经常用DISTINCT（去重）、GROUP
BY</strong>：相同的组成一组（相同的自然就排序会排一起）</li>
<li><strong>经常用ORDER BY</strong>：索引天生适合order排序</li>
<li><strong>经常用于多表JOIN连接查询</strong>：如外键<code>ON a.id=b.id</code>，可以对<code>id</code>加索引，这里跟<code>WHERE</code>的原因类似</li>
<li><strong>字符串前缀创建索引</strong>：如使用模糊查询<code>like 'xx%'</code>时，可以截取前面一段<code>xx</code>作为索引，加快查询
<ul>
<li><code>ALTER table shop ADD INDEX address_index (address(10));</code></li>
<li>区分度原则：<code>select count(distinct a)/count(*) from shop;</code>计算区分度，一般超过30%就算比较高效的索引</li>
</ul></li>
</ul>
<p><strong>2）什么情况下不适合加索引</strong></p>
<ul>
<li><strong>在WHERE中使用不到的不用创造索引</strong></li>
<li><strong>数据量小的表不需要加索引</strong>：少于1000行的表不需要加索引（回表、索引占用磁盘等问题都会影响性能）</li>
<li><strong>有大量数据重复的列，区分度不高的列不适合加索引</strong>：如性别、是否等等</li>
<li><strong>频繁更新的字段不适合加索引</strong>：因为每次更新都会更新索引，影响性能(如用户余额不适合加索引)</li>
<li><strong>经常更新的表不适合加索引</strong>：因为每次更新都会更新索引，影响更新速度</li>
<li><strong>不建议用无序的值作为索引</strong>：因为B+树更适合升序排列，插入无序的值会破坏平衡，需要经常进行<strong>分裂</strong>、<strong>旋转</strong>等操作</li>
</ul>
<h4 id="两千万数据需要多高的树">3.5.5 两千万数据需要多高的树</h4>
<p>记：MySQL中，<strong>1页=16KB；主键为bigint类型一般占8Bytes；页号一般为4Bytes</strong></p>
<p><strong>1）计算索引层两层存多少个索引</strong></p>
<ul>
<li>第一层：
<ul>
<li>每个索引包括：<strong>索引值+页号</strong>，即8+4=12Bytes</li>
<li>一页可以存储：16KB/12Bytes=1333个索引</li>
</ul></li>
<li>第二层：
<ul>
<li>第一层中每个索引可以对应第二层的一页数据，即1333个索引对应1333个页</li>
<li>1333个页可以存储：1333*1333=1776889个索引</li>
</ul></li>
</ul>
<p><strong>2）计算叶子节点层可以存储多少个实际数据</strong></p>
<p>叶子节点中，每个节点存储的数据为<strong>一行数据</strong>，假设一行数据为<strong>1KB</strong>，则一页可以存储<strong>16KB/1KB=16行数据</strong></p>
<p>在第二层中的1776889个索引对应1776889个页，而每个索引对应一页叶子结点，也就是每个索引对应16行数据</p>
<p>所以总共可以存储**1776889*16=28430224行数据**</p>
<p><strong>3）总结</strong></p>
<p>因此两千万级别的数据需要树的高度为<strong>3层</strong></p>
<h4 id="索引优化">3.5.6 索引优化</h4>
<p><strong>1）索引覆盖</strong></p>
<p>尽量通过<strong>联合索引</strong>覆盖所有要查询的字段，减少回表</p>
<p><strong>2）主键自增</strong></p>
<p>主键索引采用自增字段可以减少<strong>页分裂，提高插入效率</strong></p>
<p><strong>3）删除不常用的索引</strong></p>
<p>通过<code>show index from table_name;</code>查看索引，删除不常用的索引</p>
<p><strong>4）减少索引失效</strong></p>
<p>在MySQL中，如果遇到字符串跟数字比较，<strong>会把字符串自动转换成数字</strong>再比较</p>
<ul>
<li>情况一：索引的字段是字符串，查询条件误写成数字
<ul>
<li>分析：由于触发<strong>字符串自动转换成数字</strong>，在该案例上<strong>索引的值正好是字符串</strong>，所以相当于该字段进行函数操作了，导致<strong>索引失效</strong></li>
</ul></li>
<li>情况二：索引的字段是数字，查询条件误写成字符串
<ul>
<li>分析：由于触发<strong>字符串自动转换成数字</strong>，也就是将查询条件转换成数字，不影响索引字段，因此<strong>索引有效</strong></li>
</ul></li>
</ul>
<h3 id="日志">3.6 日志</h3>
<p>MySQL的操作是先写<strong>日志</strong>，再写<strong>磁盘</strong>，这样可以保证数据的<strong>持久性</strong>，即使数据库崩溃，也可以通过日志来恢复数据</p>
<ul>
<li><code>undo log</code>记录的是<strong>此次事务执行前</strong>的数据状态</li>
<li><code>redo log</code>记录的是<strong>此次事务执行后</strong>的数据状态，用于重启后的回滚</li>
</ul>
<h4 id="慢查询日志用于优化">3.6.1 慢查询日志：用于优化</h4>
<p>可以用于SQL语句优化的</p>
<p><strong>定位慢查询语句</strong></p>
<p>用于找到执行较慢的sql语句，在调优时手动打开慢查询日志（平时默认关闭，可以减少存慢查询日志的操作）</p>
<p>查看是否开启慢查询日志：<code>show variables like '%long_query_time%';</code></p>
<p>开启慢查询日志：<code>set global long_query_time=1;</code></p>
<p>查看慢查询日志的路径：<code>show variables like '%Slow_queries%';</code></p>
<p>慢查询分析工具：<code>mysqldumpslow -a -s t -t 10 /var/log/mysql/mysql-slow.log</code>定位具体的查询语句，然后用<code>explain</code>和<code>show profile</code>查看执行计划并优化</p>
<p><strong>1）SQL语句优化</strong></p>
<ul>
<li><strong>减少磁盘I/O</strong>：
<ul>
<li>尽量<strong>使用索引</strong>，减少全表扫描</li>
<li>通过二级索引查询时尽量使用<strong>索引覆盖，也就是只查询索引包含的字段</strong>，也可以给经常查询的字段添加<strong>联合索引</strong>增加字段，减少回表</li>
</ul></li>
<li><strong>减少内存消耗</strong>：
<ul>
<li><strong>减少排序、分组等操作</strong>，尽量<strong>使用索引排序</strong></li>
<li><strong>减少事务持有锁的时间</strong>（如先执行不加锁的查询语句，再执行加锁的更新语句）</li>
</ul></li>
<li><strong>分批处理、增加redis热词缓存、主从复制从库负责读（分担主库压力）</strong></li>
</ul>
<p><strong>2）多表关联查询的优化：小表驱动大表</strong></p>
<p>左连接：</p>
<ul>
<li>在<code>SELECT * FROM a LEFT JOIN b ON a.id=b.id</code>中的<strong>被驱动表</strong><code>b</code>上的字段<code>id</code>加索引，可以加快查询速度
<ul>
<li><code>CREATE INDEX idx_b_id ON b(id);</code></li>
</ul></li>
<li>设计多表连接时<strong>ON</strong>连接的两个<strong>字段类型需要设计成相同</strong>，否则会导致<strong>索引失效</strong></li>
</ul>
<p>内连接：只会返回两个表中<strong>交集</strong>的数据，随便哪个字段做索引都可以，有索引的表会自动成为<strong>被驱动表</strong></p>
<p><strong>3）子查询优化：避免子查询</strong></p>
<p>子查询会建立<strong>临时表</strong>，而临时表<strong>无法建立索引</strong>，且<strong>创建和销毁</strong>临时表会消耗资源(CPU、IO)，所以尽量<strong>避免子查询</strong></p>
<ul>
<li>用<strong>JOIN</strong>代替子查询</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 任务：查询所有班长</span><br><span class="line"># 子查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> FORM student stu1</span><br><span class="line"><span class="keyword">WHERE</span> stu1.stuID <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> monitorID <span class="keyword">FROM</span> class</span><br><span class="line">    <span class="keyword">WHERE</span> monitorID <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.<span class="operator">*</span> <span class="keyword">FROM</span> student stu <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> class c</span><br><span class="line"><span class="keyword">ON</span> stu.stuID <span class="operator">=</span> c.monitorID</span><br><span class="line"><span class="keyword">WHERE</span> c.monitorID <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p><strong>4）排序优化：加索引(分组也类似)</strong></p>
<ul>
<li>在<strong>ORDER
BY</strong>的字段上加<strong>索引</strong>，索引本身就是有序的</li>
<li>尽量增加<strong>limit</strong>限制，减少排序的数据量</li>
<li><code>ORDER BY</code>的顺序满足<strong>联合索引的最左匹配原则</strong>，否则联合索引会失效</li>
</ul>
<p>GROUP
BY的优化：where效率高于having，所以尽量在where中过滤数据不用分组语句</p>
<p><strong>5）分页优化</strong></p>
<p>在执行<code>SELECT * FROM student LIMIT 2000000,10</code>时，会先查询出2000010条数据，然后再取出10条，这样会消耗大量的资源</p>
<p>解决思路：尽量往主键索引靠，减少回表浪费前面查询的资源</p>
<ul>
<li><code>student</code>表中的<code>id</code>字段作为自增主键，然后<code>SELECT * FROM student WHERE id &gt; 2000000 LIMIT 10</code>就不用再回表</li>
</ul>
<p><strong>6）sql和索引都没问题：分批查询、分库分表、主从读写分离、缓存</strong></p>
<h4 id="undolog回滚日志">3.6.2 undolog回滚日志</h4>
<p>undolog存在<strong>Buffer
Pool</strong>中，也就是内存中，属于脏页数据，它的持久化是通过<strong>redo
log</strong>来保证的</p>
<p>回滚日志是用于当<strong>服务器崩溃或者事务回滚</strong>时，通过执行<strong>相反的操作</strong>来恢复数据的日志。</p>
<p>比如事务中<strong>删除一条数据</strong>，那么回滚日志就会记录一条<strong>插入</strong>操作</p>
<p>同时通过回滚版本链可以在MVCC中用于创建某个旧版本的<strong>快照</strong></p>
<p><code>undo-log</code>中记录的是旧版本的数据并形成<strong>数据版本链</strong>：</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/undo-log.png" width="50%"></p>
<h4 id="redolog重做日志">3.6.3 redolog重做日志</h4>
<p>不同于undolog，redo
log是<strong>磁盘</strong>上的<strong>物理日志</strong>，用于<strong>系统崩溃后重做提交的事务</strong>，但是也是先写进<strong>redo-log
buffer</strong>，再写进<strong>磁盘</strong>的</p>
<p><code>redo log</code> 也是为了防止 <code>Buffer Pool</code>
中的脏页丢失而设计的(只记录未被刷盘的数据的物理日志)</p>
<p>由于<code>redo log</code>是顺序写，所以写的速度比实际数据随机落盘快，同时由于其对数据恢复很重要，所以他的刷盘时机也有讲究：</p>
<p><strong>1）内存中的redo log buffer刷盘时机</strong></p>
<ul>
<li>redo log内存buffer满了，会刷盘</li>
<li>MySQL正常关闭</li>
<li>定时每<code>1s</code>刷盘一次</li>
<li>每次<strong>事务提交</strong>时刷盘</li>
</ul>
<p>其中<strong>事务提交</strong>时有三种刷屏方式可选择：</p>
<ul>
<li>commit时不刷盘</li>
<li>commit时将数据从用户态刷到内核态的page cache中但是不刷盘</li>
<li>commit时将数据刷盘到磁盘中持久化</li>
</ul>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/redo-log-buffer.png" width="50%"></p>
<p><strong>2）磁盘中的redo log循环写</strong></p>
<p><code>redo log</code>是<strong>循环写进本地磁盘</strong>的，写满会覆盖，所以<code>redo log</code>的大小是固定的，可以通过<code>innodb_log_file_size</code>来设置</p>
<p>循环写时<code>write pos</code>顺时针移动，当<code>write pos</code>追上<code>checkpoint</code>时就是满了，此时MySQL的所有操作都会被阻塞，通过<code>checkpoint</code>顺时针移动来实现擦除
- <img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/redo-log.png" width="50%"></p>
<p>其中<strong>蓝色区域</strong>代表数据还<strong>未写进本地表数据文件</strong>中，<strong>红色区域</strong>代表数据<strong>已经落盘</strong></p>
<h4 id="binlog二进制日志">3.6.4 binlog二进制日志</h4>
<p>binlog是在事务提交后记录<strong>表结构更新</strong>和<strong>数据更新</strong>的日志，不记录<strong>查询</strong>的日志</p>
<p>相比<code>redo log</code>，<code>binlog</code>是<strong>全量日志，写满会追加写</strong>，而<code>redo log</code>是<strong>循环写</strong>，写满会覆盖</p>
<p><strong>1）binlog实现主从复制：实现读写分离</strong></p>
<p><strong>mysql的主从设置可以通过中间件（如mycat）设置规则</strong></p>
<p>实际中考虑I/O限制，一般会有<strong>1主2~3从</strong>的架构，并采用<strong>异步复制</strong>，即主库提交事务后不等待从库的返回，直接返回给客户端</p>
<ul>
<li>step1：MySQL提交事务请求给主库后，主库会先写<code>binlog</code>后再更新本地存储数据</li>
<li>step2：然后<code>binlog</code>会发送复制给所有从库上写到<code>relay log</code>中继日志</li>
<li>step3：从库读取<code>relay log</code>，然后写入本地<code>binlog</code>，再更新本地存储数据</li>
</ul>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/binlog.png" width="70%"></p>
<p><strong>2）事务提交的两阶段提交</strong></p>
<p>原因：<code>redo log</code>和<code>binlog</code>的刷盘不能出现半成功，比如<code>redo log</code>刷盘更新了数据，<code>binlog</code>没刷盘，这样会导致数据不一致</p>
<p>解决：为了防止两份日志不一致，MySQL采用了两阶段提交<strong>准备pre阶段</strong>和<strong>提交commit阶段</strong>，由<strong>协调者</strong>和<strong>参与者</strong>共同完成</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/two-phase-commit.png" width="70%"></p>
<h4 id="三种日志的区别和关联">3.6.5 三种日志的区别和关联</h4>
<p>服务器宕机了怎么办？</p>
<ul>
<li>在 redo log 刷新到磁盘之前，都是回滚（通过 undo log）</li>
<li>如果 redo log 刷新到了磁盘，那么就是重做 redo log</li>
</ul>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 43%">
<col style="width: 6%">
<col style="width: 26%">
<col style="width: 3%">
<col style="width: 13%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">日志</th>
<th style="text-align: center;">作用</th>
<th style="text-align: center;">存储位置</th>
<th style="text-align: center;">是否持久化</th>
<th style="text-align: center;">是否可以恢复数据</th>
<th style="text-align: center;">层级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">undo日志</td>
<td style="text-align: center;">实现<strong>原子性</strong>，用于MVCC和回滚</td>
<td style="text-align: center;">内存</td>
<td style="text-align: center;">否（持久化也是通过redo log保证的）</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">Innodb存储引擎</td>
</tr>
<tr>
<td style="text-align: center;">redo日志</td>
<td style="text-align: center;">实现<strong>持久性</strong>，用于系统崩溃后重做提交的事务（循环写）</td>
<td style="text-align: center;">磁盘</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">Innodb存储引擎</td>
</tr>
<tr>
<td style="text-align: center;">binlog日志</td>
<td style="text-align: center;">用于<strong>主从复制和数据备份</strong>，记录所有的DDL和DML操作（全量日志）</td>
<td style="text-align: center;">磁盘</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">是</td>
<td style="text-align: center;">server层</td>
</tr>
</tbody>
</table>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/log.png" width="70%"></p>
<h3 id="分库分表路由和切片">3.7 分库分表：路由和切片</h3>
<p>MySQL的高可用性体现在：</p>
<ul>
<li>主从复制下的读写分离</li>
<li>分库分表下的路由和切片</li>
<li>分布式事务下的分布式ID保证全局唯一</li>
</ul>
<h4 id="使用mysql分库分表中间件适用于小业务">3.7.1
使用MySQL分库分表中间件：适用于小业务</h4>
<p><strong>TDSQL</strong>：腾讯开源的分库分表中间件，支持<strong>读写分离</strong>、<strong>分库分表</strong>、<strong>分布式事务</strong>等功能，路由过程由中间件完成</p>
<h4 id="自定义分库分表的路由策略切片">3.7.2
自定义分库分表的路由策略：切片</h4>
<p>一般分库分表的路由策略有<strong>取模</strong>、<strong>范围</strong>、<strong>一致性哈希</strong>等方式实现切片</p>
<p><img src="/2024/04/12/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/sharding.png" width="70%"></p>
<h4 id="分布式id">3.7.3 分布式ID</h4>
<p><strong>1）分布式ID具有的特点</strong></p>
<ul>
<li><strong>全局唯一</strong>：必须保证生成的 ID
是全局性唯一的，这是分布式 ID 的基本要求；</li>
<li><strong>有序性</strong>：生成的 ID
需要按照某种规则有序，便于数据库的写入和排序操作；</li>
<li><strong>可用性</strong>：需要保证高并发下的可用性。除了对 ID
号码自身的要求，业务还对 ID
生成系统的可用性要求极高；如在asyncflow中拼接了表明，增加了task_id的可用性</li>
<li><strong>自主性</strong>：分布式环境下不依赖中心认证即可自行生成
ID；</li>
<li><strong>安全性</strong>：不暴露系统和业务的信息。在一些业务场景下，会需要
ID 无规则或者不规则。</li>
</ul>
<p><strong>2）分布式ID生成方案</strong></p>
<p>分布式ID的生成一般都由<strong>时间、机器ID、序列号</strong>等组成，其中高位的时间戳保证和放在低位的自增序列号保证有序性，机器ID保证唯一性</p>
<ul>
<li><strong>UUID</strong>
<ul>
<li>优点：全局唯一、本地生成没有网络消耗</li>
<li>缺点：无序、且占用空间大、有可能会暴露mac地址</li>
</ul></li>
<li><strong>雪花算法</strong>：Twitter开源的分布式ID生成算法
<ul>
<li>优点：可以保证高并发下的<strong>唯一性</strong>和<strong>单机的有序递增性</strong></li>
<li>缺点：强依赖于<strong>机器时钟</strong>，如果机器时钟回拨会导致ID重复</li>
</ul></li>
</ul>
<blockquote>
<p>参考：</p>
<ol type="1">
<li><p><a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离级别是怎么实现的？</a></p></li>
<li><p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/MySQL%E5%AE%9E%E6%88%98%E5%AE%9D%E5%85%B8/08%20%20%E7%B4%A2%E5%BC%95%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%9A%84%E8%89%BA%E6%9C%AF.md">08
索引：排序的艺术</a></p></li>
<li><p><a href="https://xiaolincoding.com/mysql/index/why_index_chose_bpuls_tree.html#%E6%80%8E%E6%A0%B7%E7%9A%84%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E5%A5%BD%E7%9A%84">为什么
MySQL 采用 B+ 树作为索引？</a></p></li>
<li><p><a href="https://xiaolincoding.com/mysql/log/how_update.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-undo-log">MySQL
日志：undo log、redo log、binlog 有什么用？</a></p></li>
<li><p><a href="https://zhuanlan.zhihu.com/p/534893180">分布式唯一 ID
生成方案浅谈</a></p></li>
</ol>
</blockquote>
<h2 id="四sql安全问题">四、SQL安全问题</h2>
<p>SQL会存在<strong>SQL注入</strong>问题，攻击者在<strong>HTTP包中注入一些SQL操作</strong>从而破坏数据库</p>
<p>预防办法：</p>
<ul>
<li>使用<strong>orm</strong>框架：摒弃手动拼接SQL语句，而是通过<strong>orm框架传参</strong>实现SQL操作</li>
<li>增强<strong>用户验证</strong></li>
<li>完善<strong>数据库操作最小权限</strong></li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习1：部署运行</title>
    <url>/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>本项目是以Github上的开源项目<a href="https://github.com/qinguoyi/TinyWebServer">TinyWebServer</a>作为学习基础</p>
</blockquote>
<h2 id="一环境配置">一、环境配置</h2>
<h3 id="环境">1. 环境</h3>
<ul>
<li>服务器测试环境
<ul>
<li>Ubuntu版本22.04.1</li>
<li>MySQL版本8.0.36</li>
</ul></li>
<li>浏览器测试环境
<ul>
<li>Windows、Linux均可</li>
<li>Chrome</li>
<li>FireFox（本文调试环境为Linux下自带的FireFox）</li>
<li>其他浏览器暂无测试</li>
</ul></li>
</ul>
<h3 id="软件安装">2. 软件安装</h3>
<ul>
<li><p>安装VMware和Ubuntu</p>
<ul>
<li><a href="https://blog.csdn.net/weixin_46653651/article/details/133420059">（一）TinyWebServer的环境配置与运行</a></li>
<li>这里Ubuntu可以在清华镜像中下载，否则很慢<a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></li>
</ul>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/config_qinghua1.png"></p>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/config_qinghua2.png"></p>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/config_qinghua3.png"></p></li>
<li><p>安装MySQL（中间可能会缺少一些东西，按照提示安装即可）</p>
<ul>
<li>打开终端输入：</li>
</ul>
<p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装mysql</span></span><br><span class="line">sudo apt upgrade &amp;&amp; sudo apt install mysql-server mysql-client libmysqlclient-dev</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入mysql</span></span><br><span class="line">sudo mysql -u root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出mysql</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置mysql远程连接</span></span><br><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 改成</span></span><br><span class="line">bind-address = 0.0.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启mysql服务</span></span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>在终端创建TinyWebServer需要的数据库 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入mysql</span></span><br><span class="line">sudo mysql -u root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建数据库akiradb，可以改成自己想改的名字</span></span><br><span class="line">create database akiradb;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用数据库akiradb</span></span><br><span class="line">use akiradb;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建user表</span></span><br><span class="line">CREATE TABLE user(</span><br><span class="line">    username char(50) NULL,</span><br><span class="line">    passwd char(50) NULL</span><br><span class="line">)ENGINE=InnoDB;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加数据</span></span><br><span class="line">INSERT INTO user(username, passwd) VALUES(&#x27;akira&#x27;, &#x27;akira&#x27;);</span><br></pre></td></tr></table></figure></p></li>
<li><p>补充：一些常用的mysql命令（mysql语句一般都需要分号;作为结尾）
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看所有数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除数据库akiradb</span></span><br><span class="line">drop database akiradb;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有表</span></span><br><span class="line">show tables;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择user表中的所有数据</span></span><br><span class="line">select * from user;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除表user</span></span><br><span class="line">drop table user;</span><br></pre></td></tr></table></figure></p></li>
<li><p>退出mysql后在终端查询数据库状态 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看mysql状态</span></span><br><span class="line">sudo service mysql status</span><br></pre></td></tr></table></figure>
<img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/mysql_status.png"></p></li>
</ul></li>
</ul>
<blockquote>
<p>在centos安装mysql的时候可以参考https://blog.csdn.net/weixin_45031801/article/details/139429231，但是要注意出现<code>See "systemctl status mysqld.service" and "journalctl -xe" for details</code>报错时，要将连接里的增加<code>skip-grant-tables</code>代码先加完再启动</p>
</blockquote>
<h2 id="二tinywebserver代码">二、TinyWebServer代码</h2>
<h3 id="代码下载">1. 代码下载</h3>
<ul>
<li>下载TinyWebServer代码
<ul>
<li><a href="https://github.com/qinguoyi/TinyWebServer">TinyWebServer</a></li>
</ul></li>
<li>使用git 克隆到本地 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 没有git的使用下面命令(有git忽略此步骤)</span></span><br><span class="line">sudo apt install git -y</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行下面的命令吧项目克隆到本地</span></span><br><span class="line">git clone https://github.com/qinguoyi/TinyWebServer.git</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="代码编译">2. 代码编译</h3>
<ul>
<li><p>git后项目就会出现在桌面上，进入项目文件夹，修改main.cpp文件配置</p></li>
<li><p>打开main.cpp修改对应配置（直接在TinyWebServer文件夹点击main.cpp修改即可）</p>
<ul>
<li>获得需要的mysql的用户名和密码（需要先按照vim） <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">   cd /etc/mysql</span><br><span class="line">sudo vim debian.cnf</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/mysql_user.png"></p>
<ul>
<li>修改main.cpp文件</li>
</ul>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/main_cpp.png"></p></li>
<li><p>编译运行 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入项目文件夹</span></span><br><span class="line">cd TinyWebServer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">./server</span><br></pre></td></tr></table></figure>
注意：这里的<code>make</code>指令也可以换成<code>sh ./build.sh</code></p></li>
<li><p>编译时出现错误：</p>
<ul>
<li><code>fatal error: mysql.h: No such file or directory</code>:安装链接库
<code>apt-get install libmysqlclient-dev</code></li>
<li>g++编译时：<code>No such file or directory</code>:<code>sudo apt-get install g++</code></li>
</ul></li>
<li><p>运行并用浏览器访问</p>
<ul>
<li>终端中执行<code>./server</code></li>
<li>浏览器输入<code>http://localhost:9006</code>即可访问(也可输入回环IP地址，如<code>http://127.0.0.1:9006</code>)</li>
</ul></li>
</ul>
<h2 id="三windows下使用sshvscode远程连接ubuntu">三、Windows下使用ssh+VSCode远程连接Ubuntu</h2>
<h3 id="部署linux和windows下的vscode环境">1.
部署Linux和Windows下的VScode环境</h3>
<ul>
<li><p>在Linux下安装VSCode</p>
<ul>
<li>打开应用商店搜索<code>VSCode</code>安装即可</li>
</ul>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/vscode_linux.png"></p></li>
<li><p>按照<a href="https://www.bilibili.com/video/BV1MN411T71b/?spm_id_from=333.999.0.0">VSCode远程连接Ubuntu</a>的步骤即可</p></li>
</ul>
<h3 id="在linux下运行本文代码-在windows下运行本文代码">2.
在Linux下运行本文代码 &amp;&amp; 在Windows下运行本文代码</h3>
<ul>
<li><p>在Linux下运行本文代码</p>
<ul>
<li>在VSCode中打开<code>TinyWebServer</code>文件夹</li>
<li>在VSCdoe中打开终端，输入<code>./server</code>运行(如果还没make要先执行<code>make</code>)</li>
<li>浏览器输入<code>http://localhost:9006</code>即可访问</li>
</ul>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/vscode_linux_run.png"></p></li>
<li><p>在Linux中将TinyWebServer文件夹另存为一个工作区</p></li>
</ul>
<p><img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/vscode_linux_save.png"></p>
<ul>
<li>在Windows下运行本文代码
<ul>
<li>根据上面部署视频中打开我们刚才生成的工作区就行</li>
<li>然后同样在Windows下的VSCode中打开终端，输入<code>./server</code>运行(如果还没make要先执行<code>make</code>)</li>
</ul>
<img src="/2024/02/28/WebServer%E5%AD%A6%E4%B9%A01%EF%BC%9A%E9%83%A8%E7%BD%B2%E8%BF%90%E8%A1%8C/vscode_windows_run.png"></li>
</ul>
<h3 id="vmware中ubuntu出现内存不足需要扩容">3.
VMWare中Ubuntu出现内存不足需要扩容</h3>
<p>首先关闭虚拟机，在VMWare中选择<code>编辑虚拟机设置</code>，然后选择<code>处理器和内存</code>，然后打开虚拟机，通过<code>gparted</code>扩容</p>
<p>具体扩容操作参考<a href="https://blog.csdn.net/qq_34160841/article/details/113058756">vmware：ubuntu虚拟机如何扩容？</a></p>
<p>如果遇到权限不足问题，可以参考<a href="https://blog.csdn.net/ningmengzhihe/article/details/127295333">GParted给ubuntu系统磁盘resize大小时候出现cannot
resize read-only file system解决办法</a></p>
<h2 id="四总结">四、总结</h2>
<p>全部部署完就可以开启源代码的学习啦~</p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习2：从Config文件了解Makefile编译</title>
    <url>/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="一c终端编译的命令行解析">一、C++终端编译的命令行解析</h2>
<h3 id="int-mainint-argc-char-argv">1. int main(int argc, char
*argv[])</h3>
<ul>
<li>argc：命令行参数的个数</li>
<li>argv：命令行参数的数组
<ul>
<li>argv[0]：程序名</li>
<li>argv[1]：第一个参数</li>
</ul></li>
</ul>
<h3 id="getopt函数">2. getopt()函数</h3>
<ul>
<li>作用：自动从命令行参数中获取选项</li>
<li>头文件：#include &lt;unistd.h&gt;</li>
<li>函数原型：int getopt(int argc, char * const argv[], const char
*optstring);
<ul>
<li>argc：命令行参数的个数</li>
<li>argv：命令行参数的数组</li>
<li>optstring：选项字符串
<ul>
<li>选项字符串说明: "p:l:m:o:s:t:ca::"
<ul>
<li>p: 表示选项p后面必须跟一个参数</li>
<li>c 表示选项c后面不可以跟参数</li>
<li>a::表示选项a后面可以跟一个参数，也可以不跟参数</li>
</ul></li>
</ul></li>
<li>optarg：是一个全局变量，指向<code>当前选项的参数值</code>
<ul>
<li>例如：-p
8080，optarg指向<code>当前选项p</code>的参数值，即<code>8080</code></li>
</ul></li>
</ul></li>
</ul>
<h3 id="代码示例">3. 代码示例</h3>
<ul>
<li><p>config.h文件 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span> <span class="comment">//getopt</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Config</span>();</span><br><span class="line">    ~<span class="built_in">Config</span>()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">parse_arg</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;<span class="comment">//实现命令行参数解析</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号</span></span><br><span class="line">    <span class="keyword">int</span> PORT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式:0同步 1异步</span></span><br><span class="line">    <span class="keyword">int</span> LOGWrite;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//触发组合模式listenfd LT：0 ET：1</span></span><br><span class="line">    <span class="keyword">int</span> TRIGMode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式</span></span><br><span class="line">    <span class="keyword">int</span> LISTENTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式</span></span><br><span class="line">    <span class="keyword">int</span> CONNTrigmode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭连接</span></span><br><span class="line">    <span class="keyword">int</span> OPT_LINGER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量</span></span><br><span class="line">    <span class="keyword">int</span> sql_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量</span></span><br><span class="line">    <span class="keyword">int</span> thread_num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否关闭日志</span></span><br><span class="line">    <span class="keyword">int</span> close_log;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型选择:Reactor/Proactor</span></span><br><span class="line">    <span class="keyword">int</span> actor_model;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p>config.cpp文件 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Config::<span class="built_in">Config</span>()&#123;</span><br><span class="line">    <span class="comment">//构造函数,初始化默认参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//端口号,默认6666</span></span><br><span class="line">    PORT = <span class="number">6666</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志写入方式,默认同步</span></span><br><span class="line">    LOGWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//server listen和conn的I/O复用组合触发模式</span></span><br><span class="line">    <span class="comment">//默认listenfd LT + connfd LT(LT是水平触发)</span></span><br><span class="line">    TRIGMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listenfd触发模式,默认LT</span></span><br><span class="line">    LISTENTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//connfd触发模式,默认LT</span></span><br><span class="line">    CONNTrigmode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅关闭连接,默认不使用</span></span><br><span class="line">    OPT_LINGER = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库连接池数量(数据库线程池),默认8</span></span><br><span class="line">    sql_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池内的线程数量,默认8,这个参数可以根据服务器的负载情况进行调整</span></span><br><span class="line">    thread_num = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否关闭日志,默认不关闭</span></span><br><span class="line">    close_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//并发模型选择,默认proactor</span></span><br><span class="line">    actor_model = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Config::parse_arg</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//argc是参数个数(至少为1);argv是参数数组,argv[0]是程序名</span></span><br><span class="line">    <span class="keyword">int</span> opt;<span class="comment">//用于保存getopt的返回值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>*str = <span class="string">&quot;p:l:m:o:s:t:c:a:&quot;</span>;<span class="comment">//选项字符串,每个选项后面的冒号表示该选项后面需要接一个参数</span></span><br><span class="line">    <span class="keyword">while</span> ((opt=<span class="built_in">getopt</span>(argc, argv, str)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">//getopt是个迭代器,每次取出一个选项,并将选项对应的参数赋值给全局变量optarg</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (opt)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:&#123;</span><br><span class="line">            PORT = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;PORT = &quot; &lt;&lt; PORT &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;l&#x27;</span>:&#123;</span><br><span class="line">            LOGWrite = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:&#123;</span><br><span class="line">            TRIGMode = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:&#123;</span><br><span class="line">            OPT_LINGER = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:&#123;</span><br><span class="line">            sql_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:&#123;</span><br><span class="line">            thread_num = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:&#123;</span><br><span class="line">            close_log = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:&#123;</span><br><span class="line">            actor_model = <span class="built_in">atoi</span>(optarg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>main.cpp文件 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">//mySql配置</span></span><br><span class="line">    string user = <span class="string">&quot;debian-sys-maint&quot;</span>;</span><br><span class="line">    string password = <span class="string">&quot;AwGW2dQW8v5oJQk0&quot;</span>;</span><br><span class="line">    string database = <span class="string">&quot;akiradb&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //命令行解析</span></span><br><span class="line">    Config config;<span class="comment">//配置参数只在程序启动时使用一次</span></span><br><span class="line">    config.<span class="built_in">parse_arg</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>task.json文件 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppbuild&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;label&quot;</span>: <span class="string">&quot;C/C++: g++ 生成活动文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;command&quot;</span>: <span class="string">&quot;/usr/bin/g++&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-fdiagnostics-color=always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-g&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/config.cpp&quot;</span>,<span class="comment">//需要某个文件的路径，可以直接写路径，也可以用$&#123;fileDirname&#125;来获取当前文件的路径</span></span><br><span class="line">                <span class="comment">// &quot;$&#123;fileDirname&#125;/*.cpp&quot;,//写c++把 *.c 换成 *.cpp；linux中使用 / 来分割，windows中使用 \ 来分割。试过了没用</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$gcc&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;detail&quot;</span>: <span class="string">&quot;调试器生成的任务。&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>launch.json文件 <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;(gdb) 启动&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>],</span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;environment&quot;</span>: [],</span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;为 gdb 启用整齐打印&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-enable-pretty-printing&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;将反汇编风格设置为 Intel&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;-gdb-set disassembly-flavor intel&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="二在linuxvscode环境下编译c程序">二、在Linux+VSCode环境下编译C++程序</h2>
<h3 id="通过配置.json文件实现编译多文件编译">1.
通过配置.json文件实现编译(多文件编译)</h3>
<p>由于当前是多文件编译,所以如果使用系统默认的<code>tasks.json</code>文件,直接编译运行会报错</p>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/run_error.png"></p>
<p>从报错中我们可以看到,显示的是没有定义构造函数<code>Config::Config()</code>,也没有定义<code>Config::parse_arg</code>函数,但是我们明明已经在.cpp中实现了</p>
<p>所以可以初步判断是编译的时候没有链接到.cpp文件.所以肯定是<code>tasks.json</code>文件的问题,需要实现多文件编译的配置</p>
<ul>
<li>修改tasks.json文件</li>
</ul>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/change_task_json.png"></p>
<p>此时修改完就发现可以正常编译了,我们先运行生成可执行文件,然后在终端输入解析参数来测试</p>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/json_test.png"></p>
<p>但是我们会发现每写一个.cpp文件都需要在<code>tasks.json</code>文件中添加一次,这样非常麻烦,所以我们可以使用<code>Makefile</code>文件来实现多文件编译</p>
<h3 id="通过makefile文件实现编译多文件编译">2.
通过Makefile文件实现编译(多文件编译)</h3>
<h3 id="从终端g编译.o文件开始">2.1
从终端g++编译<code>.o</code>文件开始</h3>
<ul>
<li>一次性编译所有的.cpp文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成可执行文件</span></span><br><span class="line">g++ main.cpp config.cpp -o main</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">./main -p 100</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下的文件</span></span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/makefile_shell1.png"></p>
<p>这种编译方式有个缺点,就是每次修改了一个.cpp文件,就需要重新编译所有的.cpp文件,而且随着项目体量增大,需要在终端写的.cpp文件也越来越多</p>
<ul>
<li>优化一下,通过单独编译每个.cpp文件,然后再链接成可执行文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成单个.o文件</span></span><br><span class="line">g++ config.cpp -c</span><br><span class="line">g++ main.cpp -c</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接所有.o文件成可执行文件</span></span><br><span class="line">g++ *.o -o main</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前目录下的文件</span></span><br><span class="line">ll</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有.o文件</span></span><br><span class="line">rm *.o</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/makefile_shell2.png"></p>
<p>然后修改了某个文件后,单独编译修改的那个文件后直接链接就行,不需要重新编译所有的.cpp文件,但是这样还是不够优雅,每次编译都要自己手动写重复的命令,所以我们可以使用<code>Makefile</code>文件来实现多文件编译</p>
<h3 id="通过makefile文件实现多文件编译">2.2
通过Makefile文件实现多文件编译</h3>
<p>参考<a href="https://www.bilibili.com/video/BV188411L7d2/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=fa61c94b4d0a0af186e3cb794e46eea9">Makefile教程</a></p>
<ul>
<li>第一个版本:简单将刚刚终端的命令写入Makefile文件</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Version 1</span></span><br><span class="line"><span class="section">test: main.cpp config.cpp</span></span><br><span class="line">	g++ -o test main.cpp config.cpp</span><br></pre></td></tr></table></figure>
<p>在终端输入<code>make</code>命令,就会自动编译了</p>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/makefile_shell3.png"></p>
<ul>
<li>第二个版本:优化一下,通过变量来定义文件名和编译器</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Version 2</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = test</span><br><span class="line">OBJS = main.o config.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">config.o: config.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -c config.cpp</span><br></pre></td></tr></table></figure>
<p>在终端输入<code>make</code>命令,就会自动编译了</p>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/makefile_shell4.png"></p>
<ul>
<li>第三个版本:简化生成规则</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Version 3</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = test</span><br><span class="line">OBJS = main.o config.o</span><br><span class="line"></span><br><span class="line"><span class="comment">## 编译选项 -c 表示编译链接分开进行 -Wall 表示显示所有警告信息</span></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化所有的.o文件的生成规则</span></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p>在终端输入<code>make</code>命令,就会自动编译了,执行<code>make clean</code>命令,就会自动删除所有的.o文件和可执行文件</p>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/makefile_shell5.png"></p>
<p>第三个版本在有新的文件需要编译时,直接在<code>OBJS</code>处添加新的文件名就行,不需要再添加新的生成规则,非常方便</p>
<ul>
<li>第四个版本:</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment">## Version 4</span></span><br><span class="line">CXX = g++</span><br><span class="line">TARGET = test</span><br><span class="line"><span class="comment"># 自动实现把当前目录下的所有.cpp文件转换成.o文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line"><span class="comment"># 当目录下还有timer文件夹,取消注释下面的代码,可以将timer文件夹下的所有.cpp文件加入到SRC中</span></span><br><span class="line"><span class="comment">#SRC += $(wildcard timer/*.cpp)</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译选项 -c 表示编译链接分开进行 -Wall 表示显示所有警告信息</span></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化所有的.o文件的生成规则</span></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/makefile_shell6.png"></p>
<p>第四个版本就可以实现自动编译当前目录下的所有.cpp文件,当有新的文件时都不用重新修改Makefile文件</p>
<h2 id="三在linux下使用gdb调试c程序">三、在Linux下使用gdb调试C++程序</h2>
<p>未完待续......</p>
<h2 id="四总结">四、总结</h2>
<p>本文主要是讲解了C++终端编译的命令行解析</p>
<p>然后通过配置.json文件实现编译(多文件编译)</p>
<p>最后通过Makefile文件实现编译(多文件编译)</p>
<p>并且通过四个版本的Makefile文件来由浅入深实现编译(多文件编译)</p>
<p>所有编译问题都解决了,接下来我们就开始从socket和epool实现I/O复用通信开始学习WebServer项目的代码：<a href="https://akirazheng.github.io/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/">WebServer学习3：socket编程与epoll实现I/O复用</a></p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习3：socket编程与epoll实现I/O复用</title>
    <url>/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一socket编程">一、socket编程</h2>
<p>socket是一种文件描述符，也是一种通信机制的实现，可选地实现TCP或者UDP通信</p>
<p>以TCP实现socket通信为例，C/S模型中，服务器端和客户端分别创建一个socket，然后通过socket的
<strong>(bind、listen、accept)(服务端）</strong>、<strong>connect（客户端）</strong>等函数来实现通信</p>
<p>客户端通过bind绑定本地端口和IP，然后启动listen监听端口，当有客户端connect发起连接请求时，accept函数接受连接请求，server获得一个新的client
socket，然后通过这个新的socket来进行通信</p>
<p>如果我们要判定服务器中一个网络程序有没有启动，可以通过
<code>netstat</code> 命令查看对应的端口号是否有被监听。</p>
<p>C/S模式下的TCP服务器与TCP客户端的工作流程如下(B/S模式也类似)：</p>
<p><img src="/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/connect_TCP.png" width="60%"></p>
<h2 id="二io复用">二、I/O复用</h2>
<p>I/O复用是在单个进程中<strong>同时跟踪监控（记录）多个文件描述符（Socket
I/O流）的状态</strong>，来达到不必为每个fd都创建一个监控线程的目的。（通过I/O多路复用，可以将监听的fd设置成非阻塞的，这样就不会阻塞整个进程）</p>
<p>当多个文件描述符中的任意一个准备好进行I/O操作时，询问线程再通知处理数据的线程发起recvfrom请求去读取数据</p>
<p>通过<strong>请求队列来处理多客户端连接问题</strong>，提高服务器的并发性能</p>
<p>Linux下，实现socket
I/O复用的技术有<strong>select、poll、epoll</strong>等，进程可以通过这些技术发起I/O多路复用的系统调用，其中epoll在处理高并发场景下是性能最高的，Nginx、Redis等都是基于epoll实现的</p>
<p>而且常见的<strong>select、poll、epoll</strong>都是同步阻塞的（socket可以是非阻塞的），因此本项目最后会通过<strong>线程池</strong>来实现并发处理，<strong>为每个就绪的文件描述符分配一个逻辑单元（线程）</strong>来处理</p>
<h3 id="select">1. select</h3>
<p>select是最古老的I/O复用技术，使用<strong>线性结构</strong>来表示fd集合，它的缺点是<strong>最大文件描述符数量受限</strong>，32位系统的fd限制为1024，64位系统的fd限制为2048，文件描述符的限制是由操作系统决定的(可以通过修改配置来改变)</p>
<p>且<strong>每次调用select都需要将fd集合从用户态拷贝到内核态</strong>，效率较低</p>
<p>select是采用<strong>轮询</strong>方式来监测就绪事件的，每次调用select都会遍历所有的fd，时间复杂夫为O(n)</p>
<p><img src="/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/select.png" width="60%"></p>
<h3 id="poll">2. poll</h3>
<p>poll是对select的改进，原理相似，都需要来回拷贝全部监听的文件描述符，它采用<strong>链表</strong>代替select的fd_set结构，<strong>理论上可以支持无限个fd</strong></p>
<p>poll的效率比select高，但是<strong>当文件描述符数量较大时，效率依然不高</strong>，因为poll也是采用轮询的方式来监测就绪事件，但是事实上同一时间内，大量的<strong>客户端只有少量处于活跃的就绪状态</strong>，因此随着fd的增长，不断轮询所有fd的方法会导致效率线性下降</p>
<h3 id="epoll">3. epoll</h3>
<p>epoll是Linux内核2.6版本引入的，是<strong>Linux系统特有的</strong>（select和poll不是）</p>
<p>epoll底层是通过<strong>红黑树</strong>实现的，并且维护一个<strong>就绪链表
Ready List</strong>。<strong>所有 FD 集合采用红黑树存储，就绪 FD
集合使用链表存储</strong>,<strong>理论上可以支持无限个fd</strong>。使用高效的数据结构使插入和删除查询等性能较好（时间复杂度为<code>O(logN)</code>)</p>
<p>epoll一开始就<strong>在内核态分配了一段空间，来存放管理的
fd</strong>，所以在每次连接建立后，交给 epoll
管理时，需要将其添加到原先分配的空间中，后面再管理时就<strong>不需要频繁的从用户态拷贝管理的
fd
集合</strong>，提高了性能（也就是<code>select</code>和<code>poll</code>在内核中都没有一个数据结构来维护fd句柄，有数据到达时需要不断从用户态拷贝到内核态，而<code>epoll</code>在<code>fd</code>创建时内核态就有红黑树，可以减少拷贝。</p>
<p><img src="/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/epoll.gif" width="60%"></p>
<ul>
<li><code>epoll</code>：
<ul>
<li><code>epoll_create</code>：在内核态创建socket</li>
<li><code>epoll_ctl</code>：将内核的socket加入到红黑树中</li>
</ul></li>
</ul>
<p>epoll属于<strong>事件驱动型</strong>，当有活动的fd时，会<strong>自动触发回调函数</strong>，将活动的fd放入就绪链表中等待epoll_wait调用处理</p>
<p>而select和poll在内核判断是否有就绪的fd时开销最大</p>
<ul>
<li><p>epoll的两种工作模式，一般来说<strong>边缘触发调用系统次数比较少，所以更高效</strong>：</p>
<ul>
<li><strong>LT（水平触发）</strong>：只要fd状态是就绪的，就会触发事件(默认方式)</li>
<li><strong>ET（边缘触发）</strong>：只有当fd状态发生变化时才会触发事件
<ul>
<li>ET 是一种高速工作方式，很大程度上减少了 epoll
事件被重复触发的次数</li>
<li>ET
模式下，<strong>必须使用非阻塞的套接字(socket)</strong>，以避免由于一个文件句柄的<strong>阻塞读/阻塞写</strong>操作<strong>把处理多个文件描述符的任务饿死</strong></li>
</ul></li>
</ul></li>
</ul>
<h2 id="三epoll实现io复用">三、epoll实现I/O复用</h2>
<p>Linux下，epoll其实很简单，只要三个函数就可以了：</p>
<ul>
<li><p><strong>epoll_create</strong>：</p>
<p>创建一个epoll句柄,一个epoll会占用一个fd,所以epollfd在程序结束时也有close</p>
<p>epoll_create的参数size已经不起作用了，只要大于0就行（因为红黑树的大小是动态的）</p></li>
<li><p><strong>epoll_ctl</strong>：</p>
<p>注册要监听的事件类型（首先是server的listenfd，然后是连接server的client的connfd）</p>
<p>通过<code>epoll_ctl</code>函数将socket加入到内核中的<code>红黑树</code></p>
<p>epoll_ctl由三个宏定义来控制对fd的操作：</p>
<ul>
<li><strong>EPOLL_CTL_ADD</strong>：<strong>注册</strong>新的fd到epoll中，一旦该fd就绪，就会自动触发回调函数</li>
<li><strong>EPOLL_CTL_MOD</strong>：<strong>修改</strong>已经注册的fd的监听事件</li>
<li><strong>EPOLL_CTL_DEL</strong>：从epoll中<strong>删除</strong>一个fd(删除后一般还要手动close该fd)</li>
</ul>
<p>注册的fd会有以下的event<strong>事件类型</strong>：</p>
<ul>
<li><strong>EPOLLIN</strong>：表示对应的文件描述符<strong>可以读</strong>（包括对端SOCKET正常关闭）</li>
<li><strong>EPOLLOUT</strong>：表示对应的文件描述符<strong>可以写</strong></li>
<li><strong>EPOLLPRI</strong>：表示对应的文件描述符<strong>有紧急的数据可读</strong></li>
<li><strong>EPOLLERR</strong>：表示对应的文件描述符发生<strong>错误</strong></li>
<li><strong>EPOLLHUP</strong>：表示对应的文件描述符被<strong>挂断</strong></li>
<li><strong>EPOLLET</strong>：表示将epoll中的fd设为<strong>ET边缘触发模式</strong></li>
<li><strong>EPOLLONESHOT</strong>：表示将epoll中的fd设为<strong>ONESHOT模式</strong>只监听一次事件，epoll处理完该fd后，<strong>fd就会被从epoll中删除</strong>，如果需要再监听这个socket的话，除非再次调用epoll_ctl注册该fd</li>
</ul>
<p>通过epoll_ctl添加进来的<strong>fd都会被放在红黑树某个节点</strong>内，所以重复添加是无效的</p>
<p>当有相应的事件（如EPOLLIN、EPOLLOUT等）发生时，就会<strong>调用回调函数将该fd放入就绪链表（双向链表rdllist）中</strong>，当调用epoll_wait时，只需要检查双向链表中是否有存在注册的事件（在红黑树中）即可</p>
<p><img src="/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/red-black-tree.png"></p></li>
<li><p><strong>epoll_wait</strong>：等待事件的产生</p>
<p>epoll_wait在EventLoop中属于一个阻塞过程，当rdlist为空（无就绪fd）时挂起当前进程，直到rdlist不空时进程才被唤醒</p>
<p>文件fd状态改变（buffer由不可读变为<strong>可读EPOLLIN</strong>或由不可写变为<strong>可写EPOLLOUT</strong>），导致相应fd上的回调函数ep_poll_callback()被调用</p>
<p>epoll_wait的参数解析（C++）：</p>
<ul>
<li><strong>epollfd</strong>：当前线程的epoll句柄</li>
<li><strong>events</strong>：用来从内核得到事件的集合，<strong>events</strong>中保存了就绪的fd的<strong>事件类型</strong>，如<code>EPOLLIN</code>、<code>EPOLLOUT</code>等，用于epoll进行事件处理时可以判断对应的类型并执行相应的操作</li>
<li><strong>maxevents</strong>：每次epoll_wait最多返回的就绪事件数目</li>
<li><strong>timeout</strong>：epoll_wait的超时时间，单位为毫秒，<code>-1</code>表示<code>一直阻塞</code>，<code>0</code>表示<code>立即返回</code>，<code>&gt;0</code>表示<code>等待指定时间后返回</code></li>
</ul></li>
</ul>
<p>epoll接口的作用为:</p>
<p><img src="/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/epoll_concept.png"></p>
<h2 id="四代码示例">四、代码示例</h2>
<p>实现简单的eopll客户端和服务端（C++）</p>
<p>代码仓库为<a href="https://github.com/AkiraZheng/MyWebServer/tree/Demos_of_Webserver">WebServer相关的一些轮子和Demo</a></p>
<ul>
<li><p>服务端</p>
<p>服务端设置server
socket时,通过<code>setsockopt</code>设置SO_REUSEADDR，允许端口复用。端口复用最常用的用途应该是<strong>防止</strong>服务器重启时之前绑定的端口还未释放或者程序突然退出而<strong>系统没有释放端口</strong>。这种情况下如果设定了端口复用，则新启动的服务器进程可以直接绑定端口。如果没有设定端口复用，绑定会失败，提示ADDR已经在使用中</p>
<p>服务端通过epoll就绪队列中的<code>events[i].data.fd</code>是否等于server
fd来区分是<strong>新的连接</strong>还是<strong>已有连接的fd有数据</strong>到达</p>
<p>同时epoll设置为-1表示阻塞等待就绪事件到来(I/O复用epoll本身是阻塞的)，而epoll中的client
socket fd是非阻塞的，因为采用ET方式，需要防止饿死</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span><span class="comment">// close</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span><span class="comment">// set non-blocking</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span><span class="comment">//create socket</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span><span class="comment">//sockaddr_in</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//buffer for read socket message</span></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create a tcp socket</span></span><br><span class="line">    <span class="comment">//socket参数解析</span></span><br><span class="line">    <span class="comment">//AF_INET: ipv4,也可以是AF_INET6</span></span><br><span class="line">    <span class="comment">//SOCK_STREAM: 代表流式套接字</span></span><br><span class="line">    <span class="comment">//IPPROTO_TCP: tcp协议，也可以是IPPROTO_UDP，表示选择的传输层协议</span></span><br><span class="line">    <span class="keyword">int</span> socketFd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置socket监听的地址和端口</span></span><br><span class="line">    <span class="comment">//sockaddr_in是netinet/in.h中的结构体，用于表示socket地址</span></span><br><span class="line">    sockaddr_in sockAddr&#123;&#125;;</span><br><span class="line">    sockAddr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">    sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);<span class="comment">//端口号</span></span><br><span class="line">    sockAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);<span class="comment">//监听主机所有地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定服务端监听的socket套接字</span></span><br><span class="line">    <span class="comment">//通过bind函数将socketFd和sockAddr绑定，绑定不成功将返回-1</span></span><br><span class="line">    <span class="comment">//bind参数解析:</span></span><br><span class="line">    <span class="comment">//socketFd: socket文件描述符,也就是</span></span><br><span class="line">    <span class="comment">//sockAddr: socket需要绑定的地址和端口</span></span><br><span class="line">    <span class="keyword">int</span> flags = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>(socketFd, SOL_SOCKET, SO_REUSEADDR, &amp;flags, <span class="built_in"><span class="keyword">sizeof</span></span>(flags));<span class="comment">//bind前使用setsockopt设置允许端口复用</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(socketFd, (sockaddr*)&amp;sockAddr, <span class="built_in"><span class="keyword">sizeof</span></span>(sockAddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//结束主程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定后，开始监听socket，客户端连接时通过accept函数接收连接，内部实现三次握手</span></span><br><span class="line">    <span class="comment">//第二个参数是backlog：指定在连接队列中允许等待的最大连接数</span></span><br><span class="line">    <span class="comment">//                    但是并不意味着只能连10个，只是同时在等待连接的队列中只能有10个</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(socketFd, <span class="number">10</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;listen error&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;server start, listen on 8080...&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建epoll实例</span></span><br><span class="line">    <span class="comment">//epoll_create的size限定没啥用了，epoll实例的大小是动态调整的，基本上允许不断接入socket客户端</span></span><br><span class="line">    <span class="keyword">int</span> epollFd = <span class="built_in">epoll_create</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将socketFd包装成一个epoll_event对象，加入到epoll监听中</span></span><br><span class="line">    <span class="comment">//epoll_event是&lt;sys/epoll.h&gt;中定义的一个结构体，用于注册事件</span></span><br><span class="line">    <span class="comment">//描述在使用 epoll 监听文件描述符时发生的事件</span></span><br><span class="line">    epoll_event epev&#123;&#125;;</span><br><span class="line">    epev.events = EPOLLIN;<span class="comment">//监听server的读事件</span></span><br><span class="line">    epev.data.fd = socketFd;<span class="comment">//监听的文件描述符:相当于监听的小区楼（server socket)，里面每一个房间都是连接的客户端文件描述符</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_ADD, socketFd, &amp;epev);<span class="comment">//将监听的socket对象加入到epoll监听中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//回调事件数组：用于存放epoll_wait返回的事件，也就是最多有MAX_EVENTS个socket事件同时发生进入epoll（蜂巢的大小）</span></span><br><span class="line">    epoll_event events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在event loop中，不断的通过死循环监听和响应事件发生（执行epoll_wait等待事件发生）</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//epoll_wait函数用于等待事件发生，函数会阻塞，直到超时或有响应的事件发生，返回发生的事件数量</span></span><br><span class="line">        <span class="comment">//epollFd: epoll实例(相当于小区的蜂巢快递点，当有事件进来时，会通知蜂巢快递点epoll，然后蜂巢快递点再通知小区楼socketFd)</span></span><br><span class="line">        <span class="comment">//events: 用于存放发生的事件</span></span><br><span class="line">        <span class="comment">//MAX_EVENTS: 最多发生的事件数量</span></span><br><span class="line">        <span class="comment">//timeout: 超时时间，-1表示一直等待，0表示立即返回，&gt;0表示等待指定时间</span></span><br><span class="line">        <span class="keyword">int</span> eventCount = <span class="built_in">epoll_wait</span>(epollFd, events, MAX_EVENTS, <span class="number">-1</span>);<span class="comment">//timeout为-1就是阻塞等待</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(eventCount == <span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;epoll_wait error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//wait到事件后，遍历所有收到的events并进行处理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;eventCount; i++)&#123;</span><br><span class="line">            <span class="comment">//判断是不是新的socket客户端连接</span></span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd == socketFd)&#123;</span><br><span class="line">                <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;</span><br><span class="line">                    <span class="comment">//接收新的socket客户端连接，clientAddr存放连接进来的客户端的地址信息</span></span><br><span class="line">                    sockaddr_in clientAddr&#123;&#125;;</span><br><span class="line">                    <span class="keyword">socklen_t</span> clientAddrLen = <span class="built_in"><span class="keyword">sizeof</span></span>(clientAddr);</span><br><span class="line">                    <span class="keyword">int</span> clientFd = <span class="built_in">accept</span>(socketFd, (sockaddr*)&amp;clientAddr, &amp;clientAddrLen);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//将新的socket客户端连接加入到epoll监听中</span></span><br><span class="line">                    epev.events = EPOLLIN | EPOLLET;<span class="comment">//监听读事件并设置边缘触发模式</span></span><br><span class="line">                    epev.data.fd = clientFd;<span class="comment">//监听的文件描述符</span></span><br><span class="line">                    <span class="comment">//设置连接的客户端为非阻塞模式，fcntl函数F_GETFL获取客户端fd的状态标志</span></span><br><span class="line">                    <span class="keyword">int</span> flags = <span class="built_in">fcntl</span>(clientFd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span>(flags == <span class="number">-1</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;fcntl error&quot;</span> &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//F_SETFL设置客户端fd为非阻塞模式O_NONBLOCK</span></span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">fcntl</span>(clientFd, F_SETFL, flags | O_NONBLOCK) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;set no block error, fd:&quot;</span> &lt;&lt; clientFd &lt;&lt; endl;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将新客户端连接加入到epoll监听中</span></span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_ADD, clientFd, &amp;epev);</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;new client connected, fd:&quot;</span> &lt;&lt; clientFd &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//不是server socket的事件响应，而是客户端socket的事件响应</span></span><br><span class="line">                <span class="comment">//判断是不是断开连接和出错EPOLLERR EPOLLHUP</span></span><br><span class="line">                <span class="keyword">if</span>(events[i].events &amp; EPOLLERR  || events[i].events &amp; EPOLLHUP)&#123;</span><br><span class="line">                    <span class="comment">//出现客户端连接错误或断开连接时需要从epoll中移除</span></span><br><span class="line">                    <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_DEL, events[i].data.fd, <span class="literal">nullptr</span>);</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;client disconnected, fd:&quot;</span> &lt;&lt; events[i].data.fd &lt;&lt; endl;</span><br><span class="line">                    <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(events[i].events &amp; EPOLLIN)&#123;<span class="comment">//客户端可读事件</span></span><br><span class="line">                    <span class="keyword">int</span> len = <span class="built_in">read</span>(events[i].data.fd, buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff));<span class="comment">//用buff接收客户端发送的消息</span></span><br><span class="line">                    <span class="comment">//如果数据读取错误，关闭对应的客户端连接并从epoll监听中移除</span></span><br><span class="line">                    <span class="keyword">if</span>(len == <span class="number">-1</span>)&#123;</span><br><span class="line">                        <span class="built_in">epoll_ctl</span>(epollFd, EPOLL_CTL_DEL, events[i].data.fd, <span class="literal">nullptr</span>);</span><br><span class="line">                        <span class="built_in">close</span>(events[i].data.fd);</span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;read error, close fd:&quot;</span> &lt;&lt; events[i].data.fd &lt;&lt; endl;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//打印客户端发送的消息</span></span><br><span class="line">                        cout &lt;&lt; <span class="string">&quot;recv msg from client, fd:&quot;</span> &lt;&lt; events[i].data.fd &lt;&lt; <span class="string">&quot;, msg:&quot;</span> &lt;&lt; buff &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//将接收到的消息再发送给客户端</span></span><br><span class="line">                        <span class="keyword">char</span> sendMess[] = <span class="string">&quot;hello, client&quot;</span>;</span><br><span class="line">                        <span class="built_in">write</span>(events[i].data.fd, sendMess, <span class="built_in"><span class="keyword">sizeof</span></span>(sendMess));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>终端中编译运行效果：</p>
<p><img src="/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/epollDemo_server_run.png"></p></li>
<li><p>客户端</p>
<p>客户端通过socket连接到服务端，然后通过write发送消息，通过read接收消息，Demo设计中for循环模拟10个客户端</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现一个客户端程序，连接到服务器，发送数据，接收数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> clientsFd[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//创建socket</span></span><br><span class="line">        <span class="keyword">int</span> clientSocketFd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置连接的服务器地址和端口</span></span><br><span class="line">        sockaddr_in sockAddr&#123;&#125;;</span><br><span class="line">        sockAddr.sin_family = AF_INET;</span><br><span class="line">        sockAddr.sin_port = <span class="built_in">htons</span>(<span class="number">8080</span>);</span><br><span class="line">        sockAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">connect</span>(clientSocketFd, (sockaddr*)&amp;sockAddr, <span class="built_in"><span class="keyword">sizeof</span></span>(sockAddr)) == <span class="number">-1</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        clientsFd[i] = clientSocketFd;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;client fd:&quot;</span> &lt;&lt; clientsFd[i] &lt;&lt;<span class="string">&quot;connect to server success&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延迟</span></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        <span class="keyword">char</span> buff[] = <span class="string">&quot;hello, epoll&quot;</span>;</span><br><span class="line">        <span class="built_in">send</span>(clientsFd[i], buff, <span class="built_in"><span class="keyword">sizeof</span></span>(buff), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        <span class="keyword">char</span> recvBuff[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">recv</span>(clientsFd[i], recvBuff, <span class="built_in"><span class="keyword">sizeof</span></span>(recvBuff), <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;recv: &quot;</span> &lt;&lt; recvBuff &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭socket</span></span><br><span class="line">        <span class="built_in">close</span>(clientsFd[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>终端中编译运行效果：</p>
<p><img src="/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/epollDemo_client_run.png"></p></li>
<li><p>比较</p>
<p>通过比较客户端和服务端的fd，我们可以很清晰的看到，当服务端接收到新的客户端fd后，会在服务端中将其记成服务端对应可识别的fd，而不是客户端进程中出现的fd，这样保证了服务端和客户端的通信不会出现混乱</p></li>
</ul>
<h2 id="五总结">五、总结</h2>
<ul>
<li>本文学习了socket普通编程</li>
<li>扩展了I/O复用的概念，以及select、poll、epoll的区别，并具体实现和讲解了epoll的I/O复用</li>
<li>通过简单的epoll服务端和客户端的代码示例，加深了对epoll的理解</li>
</ul>
<p>有了I/O复用和epoll编程基础后，将可以开始着手实现WebServer的event_loop和epoll模块，通过学习两种事件驱动模型（Reactor和Proactor）来实现WebServer的高并发处理。<a href="https://akirazheng.github.io/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/">WebServer学习4：并发事件驱动模式Reactor和Proactor</a></p>
<p><a href="https://blog.csdn.net/adminpd/article/details/124553590">详解IO多路复用机制——select、poll、epoll的原理和区别</a></p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习5：线程池与数据库连接池设计</title>
    <url>/2024/03/09/WebServer%E5%AD%A6%E4%B9%A05%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="一线程池设计基础">一、线程池设计基础</h2>
<h3 id="线程池基础">1.1 线程池基础</h3>
<p>关于通用线程池的设计轮子，可以参考本人的博客：<a href="https://akirazheng.github.io/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/">从0开始实现线程池(C++)</a></p>
<p>相比上面造的轮子，本文进一步将Task类型设置成<strong>模板类</strong>，以适应不同类型的任务。同时将worker的阻塞环节中<strong>条件变量替换为信号量</strong>，以实现对线程池的互斥访问。</p>
<h3 id="半同步半反应堆线程池">1.2 半同步/半反应堆线程池</h3>
<p>并发模式中的同步和异步</p>
<ul>
<li><strong>同步</strong>：指的是<strong>发起一个调用</strong>后，<strong>调用者需要等待结果</strong>，才能继续后续的操作；这种程序完全按照代码的顺序执行</li>
<li><strong>异步</strong>：指的是<strong>发起一个调用</strong>后，<strong>调用者不需要等待结果</strong>，就可以继续后续的操作；异步指的是程序的执行需要由系统事件驱动</li>
</ul>
<p>半同步/半反应堆线程池是一种<strong>同步I/O模拟Proactor事件处理模式</strong>，主线程负责处理读写数据、接受新连接等I/O操作，等<strong>处理完事件后</strong>再直接发送读取后的结果给工作线程进行业务处理。以proactor模式为例，半同步/半反应堆线程池的工作流程如下：</p>
<ul>
<li>主线程中<strong>epoll</strong>充当<strong>异步线程</strong>，负责<strong>处理socket</strong>上读写数据、接受新连接等I/O操作</li>
<li>若有新连接发生，主线程获取该新连接，然后往<strong>epoll</strong>内核事件表注册该socket上的读就绪事件</li>
<li>如果连接socket上<strong>有数据可读</strong>，<strong>主线程从socket循环读取数据</strong>，直到没有更多数据可读，然后<strong>将读取到的数据封装</strong>成一个<strong>请求对象</strong>并插入请求队列</li>
<li>睡眠的工作线程接收到请求对象后，通过竞争获取任务接管权</li>
</ul>
<p>本项目除了采取半同步/半反应堆线程池，还对worker中处理任务允许使用<strong>Reator模式</strong>或<strong>Proactor模式</strong>，Reactor模式需要输入一个state参数，用于判断任务的类型，而Proactor模式则不需要，因此这里Reactor和Proactor模式封装的<strong>添加任务</strong>的函数不同，一个需要输入state参数，一个不需要。(但是任务都是模板类型，也就是<code>http_conn</code>具体类)</p>
<p>本项目的线程池设计和实现流程如下：</p>
<p><img src="/2024/03/09/WebServer%E5%AD%A6%E4%B9%A05%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%AE%BE%E8%AE%A1/worker_of_threadpool.png"></p>
<h3 id="主要函数代码实现">1.3 主要函数代码实现</h3>
<p>主要函数包括生产者向任务队列中添加任务<code>append</code>函数、消费者从任务队列中取出任务并执行任务<code>worker</code>工作线程回调函数。</p>
<ul>
<li><code>append</code>函数：生产者向任务队列中添加任务</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向请求队列中添加任务(Reactor模式)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::<span class="built_in">append</span>(T *request, <span class="keyword">int</span> state)&#123;</span><br><span class="line">    <span class="comment">//操作工作队列时一定要加锁，因为它被所有线程共享</span></span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)&#123;</span><br><span class="line">        <span class="comment">//请求队列满了</span></span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    request-&gt;m_state = state;<span class="comment">//state 0代表读事件，state 1代表写事件</span></span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line"></span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//信号量+1，唤醒一个线程，对应PV操作中的P操作</span></span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向请求队列中添加任务(Proactor模式)</span></span><br><span class="line"><span class="comment">//由于Proactor模式下，socketfd上的读写事件都是由主线程来处理的，所以这里只需要将任务添加到请求队列中即可，不需要state参数来判断是什么事件</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::<span class="built_in">append_p</span>(T *request)</span><br><span class="line">&#123;</span><br><span class="line">    m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (m_workqueue.<span class="built_in">size</span>() &gt;= m_max_requests)</span><br><span class="line">    &#123;</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_workqueue.<span class="built_in">push_back</span>(request);</span><br><span class="line">    m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    m_queuestat.<span class="built_in">post</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>worker</code>函数：消费者从任务队列中取出任务并执行任务</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工作线程运行函数:worker</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> *threadpool&lt;T&gt;::<span class="built_in">worker</span>(<span class="keyword">void</span> *arg)&#123;</span><br><span class="line">    threadpool *pool = <span class="keyword">static_cast</span>&lt;threadpool *&gt;(arg);</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程池的主线程运行函数:保证线程池中的线程一直处于等待任务的状态 &amp;&amp; 从请求队列中取出任务并执行之</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt;T&gt;::<span class="built_in">run</span>()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//等待线程池的信号量，即是否有任务需要处理（阻塞等待）</span></span><br><span class="line">        m_queuestat.<span class="built_in">wait</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再查看确认是否有任务需要处理，如果没有的话就continue继续while循环</span></span><br><span class="line">        m_queuelocker.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_workqueue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有任务则取出任务并处理</span></span><br><span class="line">        T *request = m_workqueue.<span class="built_in">front</span>();</span><br><span class="line">        m_workqueue.<span class="built_in">pop_front</span>();</span><br><span class="line">        m_queuelocker.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!request)&#123;<span class="comment">//任务为空任务</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据事件处理模型切换：Reactor/Proactor（m_actor_model）</span></span><br><span class="line">        <span class="keyword">if</span>(m_actor_model == <span class="number">1</span>)&#123;<span class="comment">//Reactor模式</span></span><br><span class="line">            <span class="keyword">if</span>(request-&gt;m_state == <span class="number">0</span>)&#123;<span class="comment">//读事件</span></span><br><span class="line">                <span class="keyword">if</span>(request-&gt;<span class="built_in">read_once</span>())&#123;<span class="comment">//读取数据成功</span></span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;<span class="comment">//通知主线程中的dealwithread，表示该任务已交由工作线程处理</span></span><br><span class="line">                    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;request-&gt;mysql, m_connPool)</span></span>;<span class="comment">//自动获取数据库连接</span></span><br><span class="line">                    request-&gt;<span class="built_in">process</span>();<span class="comment">//处理请求:解析请求报文，处理业务逻辑，生成响应报文</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//读取数据失败</span></span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//写事件</span></span><br><span class="line">                <span class="keyword">if</span> (request-&gt;<span class="built_in">write</span>())&#123;<span class="comment">//写数据成功</span></span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//写数据失败</span></span><br><span class="line">                    request-&gt;improv = <span class="number">1</span>;</span><br><span class="line">                    request-&gt;timer_flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//Proactor模式，直接处理请求，不需要判断事件类型</span></span><br><span class="line">            connectionRAII <span class="built_in">mysqlcon</span>(&amp;request-&gt;mysql, m_connPool);<span class="comment">//自动获取数据库连接</span></span><br><span class="line">            request-&gt;<span class="built_in">process</span>();<span class="comment">//处理请求:解析请求报文，处理业务逻辑，生成响应报文</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二封装线程同步需要的信号量和各种锁">二、封装线程同步需要的信号量和各种锁</h2>
<h3 id="信号量">2.1 信号量</h3>
<p>信号量的封装主要是对<code>sem_init</code>、<code>sem_wait</code>、<code>sem_post</code>和<code>sem_destroy</code>函数的封装，以实现对信号量的操作。同时维护一个<code>sem_t</code>信号量变量，用于实现对信号量的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*封装信号量的类</span></span><br><span class="line"><span class="comment">* 信号量是一个计数器，用于多线程之间的同步</span></span><br><span class="line"><span class="comment">* 每次从连接池获取连接时，需要获取一个信号量许可证(sem_wait)，如果没有可用的许可证，线程将被阻塞，直到有可用的连接。</span></span><br><span class="line"><span class="comment">* 当线程释放连接时，将增加一个信号量许可证(sem_post)，使得其他线程可以获取连接。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sem</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化信号量m_sem为进程内线程共享-信号量初始值为0</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();<span class="comment">//信号量初始化失败，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem</span>(<span class="keyword">int</span> num)&#123;</span><br><span class="line">        <span class="comment">//初始化信号量m_sem为进程内线程共享-信号量初始值为num</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sem_init</span>(&amp;m_sem, <span class="number">0</span>, num) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();<span class="comment">//信号量初始化失败，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">sem</span>()&#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;m_sem);<span class="comment">//销毁信号量</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//等待获取信号量许可证</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;m_sem) == <span class="number">0</span>;<span class="comment">//释放信号量许可证</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">sem_t</span> m_sem;<span class="comment">//信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="互斥锁">2.2 互斥锁</h3>
<p>互斥锁的封装主要是对<code>pthread_mutex_init</code>、<code>pthread_mutex_lock</code>、<code>pthread_mutex_unlock</code>和<code>pthread_mutex_destroy</code>函数的封装，以实现对互斥锁的操作。同时维护一个<code>pthread_mutex_t</code>互斥锁变量，用于实现对互斥锁的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*封装互斥锁的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">locker</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();<span class="comment">//互斥锁初始化失败，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">locker</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);<span class="comment">//销毁互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex)==<span class="number">0</span>;<span class="comment">//加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex)==<span class="number">0</span>;<span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">pthread_mutex_t</span> *<span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_mutex;<span class="comment">//获得当前类对象中的互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="条件变量">2.3 条件变量</h3>
<p>条件变量的封装主要是对<code>pthread_cond_init</code>、<code>pthread_cond_wait</code>、<code>pthread_cond_timedwait</code>、<code>pthread_cond_signal</code>和<code>pthread_cond_broadcast</code>函数的封装，以实现对条件变量的操作。同时维护一个<code>pthread_cond_t</code>条件变量变量，用于实现对条件变量的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*封装条件变量的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">cond</span>()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();<span class="comment">//条件变量初始化失败，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">cond</span>()&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);<span class="comment">//销毁条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;m_cond, m_mutex);<span class="comment">//等待条件变量:阻塞线程</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">timewait</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *m_mutex, struct timespec t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        ret = <span class="built_in">pthread_cond_timedwait</span>(&amp;m_cond, m_mutex, &amp;t);<span class="comment">//等待条件变量:阻塞线程一定时间t</span></span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;m_cond)==<span class="number">0</span>;<span class="comment">//唤醒一个等待条件变量的线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">broadcast</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pthread_cond_broadcast</span>(&amp;m_cond)==<span class="number">0</span>;<span class="comment">//唤醒所有阻塞等待条件变量的线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_cond_t</span> m_cond;<span class="comment">//条件变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三数据库连接池设计">三、数据库连接池设计</h2>
<p>数据库连接池实际上也是线程池中维护的一个共享资源，每接收一个http请求时<strong>除了分配线程资源外</strong>，当获得线程资源后，线程池的worker中还<strong>需要分配数据库连接资源</strong>。</p>
<p>连接池的功能主要有：<strong>初始化</strong>，<strong>获取连接</strong>、<strong>释放连接</strong>，<strong>销毁连接池</strong>。</p>
<h3 id="连接池中信号量的使用">3.1 连接池中信号量的使用</h3>
<p>为了维护数据库连接池，这里将条件变量替换为<strong>信号量</strong>，以实现对连接池的互斥访问。（条件变量是用于线程间的同步，而信号量可以用于进程间或线程间的同步）</p>
<p>在数据库连接池中，<strong>信号量（Semaphore）通常用于控制对连接资源的并发访问</strong>。连接池是一种重复使用数据库连接的技术，通过维护一组预先创建的连接对象，在需要访问数据库时从池中获取连接，使用完毕后将连接放回池中，以提高数据库访问的性能和效率。</p>
<p>在C++中，信号量可以使用<code>sem_init</code>、<code>sem_wait</code>、<code>sem_post</code>和<code>sem_destroy</code>等函数进行操作：</p>
<ul>
<li><code>int sem_init(sem_t *sem, int pshared, unsigned int value)</code>：初始化信号量
<ul>
<li>sem：指向要初始化的信号量的指针。</li>
<li>pshared：指定信号量的<strong>共享类型</strong>。如果为<code>0</code>，信号量将被<strong>进程内的线程共享</strong>；如果为非零，信号量可以在不同进程间共享。</li>
<li>value：指定信号量的初始值。</li>
</ul></li>
<li><code>int sem_wait(sem_t *sem)</code>：等待信号量，用于<strong>获取一个信号量的许可证</strong>，没有可用许可证时，线程将阻塞。
<ul>
<li>sem：指向要等待的信号量的指针。</li>
</ul></li>
<li><code>int sem_post(sem_t *sem)</code>：释放信号量，用于<strong>释放一个信号量的许可证</strong>。
<ul>
<li>sem：指向要释放的信号量的指针。</li>
<li>如果有其他线程在等待这个信号量，那么其中的一个线程将被唤醒。</li>
<li>释放信号量的许可证后，信号量的值将增加1。</li>
</ul></li>
<li><code>int sem_destroy(sem_t *sem)</code>：销毁信号量。
<ul>
<li>sem：指向要销毁的信号量的指针。</li>
</ul></li>
</ul>
<p>使用信号量<strong>实现多线程争夺连接的同步机制</strong>，这里将信号量初始化为数据库的连接总数。当线程需要获取连接时，<strong>取出连接</strong>它会调用<code>sem_wait</code>函数，如果有可用的连接，线程将获得一个连接并将<strong>信号量的值减1</strong>；如果<strong>没有可用的连接，线程将阻塞等待</strong>，直到有连接被释放。当线程使用完连接后，<strong>释放连接</strong>会调用<code>sem_post</code>函数将信<strong>号量的值加1</strong>。</p>
<p>另外，由于多线程操作连接池，会造成竞争，这里使用<strong>互斥锁</strong>完成同步，具体的同步机制均使用<code>lock.h</code>中封装好的类。这里互斥锁的使用在<strong>一、</strong>中已有说明，不再赘述。</p>
<h3 id="数据库连接池的单例模式">3.2 数据库连接池的单例模式</h3>
<p>数据库连接池是一个全局的资源，因此需要使用<strong>单例模式</strong>来保证程序中只有一个数据库连接池的实例。这里采用<strong>懒汉模式</strong>实现单例模式，由于项目中在程序启动（<code>main.cpp</code>）时就会初始化数据库连接池，因此不需要考虑多线程安全问题，采用最简单的懒汉模式实现单例模式。（24.4.11更正：这里其实是线程安全的，C++11后局部静态变量的初始化是线程安全的）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connection_pool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//局部静态变量单例模式</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> connection_pool *<span class="title">GetInstance</span><span class="params">()</span></span>;<span class="comment">//数据库连接需要采用单例模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">connection_pool</span>();</span><br><span class="line">    ~<span class="built_in">connection_pool</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connection_pool *<span class="title">connection_pool::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//懒汉模式创建，由于只在程序开始时创建一次，所以不需要加锁</span></span><br><span class="line">    <span class="keyword">static</span> connection_pool connPool;</span><br><span class="line">    <span class="keyword">return</span> &amp;connPool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="raii机制封装数据库的连接与释放">3.3
RAII机制封装数据库的连接与释放</h3>
<p>RAII（Resource Acquisition Is
Initialization）是C++的一种资源管理方式，即<strong>资源获取就是初始化</strong>。RAII的核心思想是<strong>将资源的生命周期与对象的生命周期绑定</strong>，通过对象的生命周期来管理资源的生命周期。</p>
<p>在获取连接时，通过<strong>实例化</strong>一个<code>connectionRAII</code>对象会自动调用<code>mysql_real_connect</code>中的<code>GetConnection</code>函数从而获取一个mysql连接；</p>
<p>在释放连接时，通过销毁上面的<code>connectionRAII</code>实例化对象，自动调用<strong>析构函数</strong>执行<code>RealeaseConnection</code>函数对连接进行释放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*RAII机制，用于自动释放和获取数据库连接（从连接池中获取和释放连接）</span></span><br><span class="line"><span class="comment">* 将数据库连接的获取与释放通过RAII机制封装，避免手动释放。</span></span><br><span class="line"><span class="comment">* RAII机制在HTTP连接处理中使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">connectionRAII</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//双指针接收一个指针的地址，*con指向接收的指针指向的地址</span></span><br><span class="line">	<span class="built_in">connectionRAII</span>(MYSQL **con, connection_pool *connPool);</span><br><span class="line">	~<span class="built_in">connectionRAII</span>();</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	MYSQL *conRAII;</span><br><span class="line">	connection_pool *poolRAII;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*RAII机制，用于自动释放和获取数据库连接*/</span></span><br><span class="line">connectionRAII::<span class="built_in">connectionRAII</span>(MYSQL **SQL, connection_pool *connPool)&#123;</span><br><span class="line">    *SQL = connPool-&gt;<span class="built_in">GetConnection</span>();<span class="comment">//获取数据库连接</span></span><br><span class="line"></span><br><span class="line">    conRAII = *SQL;</span><br><span class="line">    poolRAII = connPool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connectionRAII::~<span class="built_in">connectionRAII</span>()&#123;</span><br><span class="line">    poolRAII-&gt;<span class="built_in">RealeaseConnection</span>(conRAII);<span class="comment">//释放数据库连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从本项目中举例说明<strong>RAII机制</strong>的使用</li>
</ul>
<p>在<code>http_conn.cpp</code>中，我们通过一个<code>initmysql_result</code>函数在整个程序初始化时就先取出当前所有注册过的用户名和密码到一个map中存起来</p>
<p>我们可以看到在这个函数中我们<strong>并没有显示地连接和释放数据库连接</strong>，那么它是怎么实现数据库资源的获取和释放的呢？就是用的我们封装好的<strong>RAII机制函数</strong>。</p>
<p>此时函数中就是通过实例化一个<code>connectionRAII</code>对象，这个对象是函数内的局部变量，所以当这个函数结束时，这个对象就会被销毁，从而调用析构函数，自动释放本次的数据库连接（归还给数据库连接池）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main中初始化WebServer类中的m_connPool时会同时在HTTP类中取出一个数据库连接用于提前将所有注册过的用户信息取出存在map中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::initmysql_result</span><span class="params">(connection_pool *connPool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先从连接池中取一个连接（RAII机制）</span></span><br><span class="line">    MYSQL *mysql = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function">connectionRAII <span class="title">mysqlcon</span><span class="params">(&amp;mysql, connPool)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在user表中检索username，passwd数据，浏览器端输入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mysql_query</span>(mysql, <span class="string">&quot;SELECT username,passwd FROM user&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// LOG_ERROR(&quot;SELECT error:%s\n&quot;, mysql_error(mysql));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从表中检索完整的结果集</span></span><br><span class="line">    MYSQL_RES *result = <span class="built_in">mysql_store_result</span>(mysql);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果集中的列数</span></span><br><span class="line">    <span class="keyword">int</span> num_fields = <span class="built_in">mysql_num_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回所有字段结构的数组</span></span><br><span class="line">    MYSQL_FIELD *fields = <span class="built_in">mysql_fetch_fields</span>(result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从结果集中获取下一行，将对应的用户名和密码，存入map中</span></span><br><span class="line">    <span class="keyword">while</span> (MYSQL_ROW row = <span class="built_in">mysql_fetch_row</span>(result))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">string <span class="title">temp1</span><span class="params">(row[<span class="number">0</span>])</span></span>;<span class="comment">//key：用户名</span></span><br><span class="line">        <span class="function">string <span class="title">temp2</span><span class="params">(row[<span class="number">1</span>])</span></span>;<span class="comment">//value：密码</span></span><br><span class="line">        users[temp1] = temp2;<span class="comment">//存入map中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四总结">四、总结</h2>
<p>本文主要介绍了线程池的设计和数据库连接池的设计，其中线程池的设计主要是对通用线程池的进一步封装，将Task类型设置成模板类，以适应不同类型的任务。同时将worker的阻塞环节中条件变量替换为信号量，以实现对线程池的互斥访问。</p>
<p>数据库连接池的设计主要是对连接池中信号量的使用和数据库连接池的单例模式的设计。同时，使用RAII机制封装数据库的连接与释放，避免手动释放。</p>
<p>通过本文的学习，对线程池和数据库连接池的设计有了更深入的了解，同时也对C++的RAII机制有了更深入的认识。有了本文的基础，我们可以开始学习<strong>HTTP类</strong>。关于<strong>HTTP类</strong>的实现，可以参考本人的下一篇博客：<a href="https://akirazheng.github.io/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/">WebServer学习6：HTTP连接处理及报文机制</a></p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习4：并发事件驱动模式Reactor和Proactor</title>
    <url>/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/</url>
    <content><![CDATA[<h2 id="一并发模式">一、并发模式</h2>
<p>当处理并发客户端的请求时，最直接的想法就是使用多线程来解决，但是线程完成业务逻辑后就销毁，不断地创建销毁会造成很大的性能开销，因此选择优化为采用<strong>线程池来处理业务</strong>，那么线程池该如何高效地处理业务呢?我们需要选择适合地并发模式来实现</p>
<p>我们知道，epoll中监听的是多个fd，epoll_wait等待到的事件可能是读/写/accept客户端/信号/定时等，这些事件都是并发的，我们需要对这些事件进行并发处理</p>
<p>而事件并发处理模式有两种:Reactor和Proactor，下面对这两种并发模式进行介绍</p>
<h2 id="二reactor模式">二、Reactor模式</h2>
<p>Reactor又称为<strong>反应堆</strong>，是一种<strong>事件驱动机制</strong>。Reactor通常使用<strong>同步I/O</strong>(如<code>epoll_wait</code>)实现。</p>
<ul>
<li>同步(阻塞)I/O：当一个I/O操作发生时，程序会阻塞在这个I/O操作上，直到这个I/O操作完成，程序才会继续执行</li>
<li>Reactor将所有要处理的<strong>I/O事件注册到I/O多路复用器上(如epoll)</strong></li>
<li>而主线程/进程阻塞在多路复用器上，也就是同步阻塞在epoll_wait上</li>
<li>I/O多路复用器监听到I/O事件发生后，<strong>根据事件类型将事件分发给工作线程(逻辑单元)处理</strong></li>
</ul>
<p>Reator模式要求<strong>主线程只负责监听是否有事件发生</strong>，当有事件发生时，主线程将事件分发给工作线程(逻辑单元)处理(包括读和写)，也就是将socket可读可写事件放入工作线程的请求队列中等待处理</p>
<h3 id="模式一单reactor单线程">模式一：单Reactor单线程</h3>
<p>这种模型下，通常只有<strong>1个epoll对象</strong>，所有的<strong>客户端连接、读写事件</strong>都在<strong>主线程</strong>中实现（redis这种中间件就是采用这种模式）</p>
<p><img src="/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/singleReactor.png" width="80%" heigh="80"></p>
<p>而实际上非I/O的业务型操作不应该也放在主线程中，（如图中的decode、compute、encode）应该从Reactor中卸载，放入工作线程中（这种就是模式二采用的方法）</p>
<h3 id="模式二-单reactor-线程池thread-pool多线程">模式二: 单Reactor +
线程池(Thread Pool)（多线程）</h3>
<p>这种模式的特定是，client的accept和read/send都在主线程<code>MainReactor</code>中完成，然后读取客户端数据后，将计算和请求处理等工作交给线程池执行，可以充分利用多核CPU的优势</p>
<p>采用此模式时有可能存在多个线程同时计算同一个连接上的多个请求，算出的结果的次序是不确定的，
所以需要网络框架在设计协议时<strong>带一个id标示</strong>，以便让客户端区分response对应的是哪个request。</p>
<p><img src="/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/reactor_thread_pool.png" width="80%" heigh="80"></p>
<h3 id="模式三-muduo-络库中所提出的-multi-reactor-并发框架-线程池实现">模式三:
muduo ⽹络库中所提出的 Multi-Reactor 并发框架 + 线程池实现</h3>
<p>Multi-Reactor模式的特点是one loop per thread， 有一个<strong>main
Reactor</strong>负责<code>accept</code>连接，
然后把该连接挂在某个<strong>sub
Reactor</strong>中(可以采用<strong>round-robin</strong>、<strong>随机方法</strong>、<strong>一致性哈希</strong>等实现<strong>负载均衡</strong>)，这样该连接的所有操作都在哪个sub
Reactor所处的线程中完成，每个sub Reactor都处于线程池中的某个线程中</p>
<p>通过<strong>Multi-Reactor +
Pools</strong>的模式结合epoll实现多路复用也要<strong>遵循每个fd的操作只有一个线程完成（一致性哈希可以实现）</strong>，防止出现数据收发顺序问题以及多个线程同时操作一个fd的问题</p>
<p><img src="/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/multipleReactors+Pools.png"></p>
<h2 id="三proactor模式">三、Proactor模式</h2>
<p>proactor模式中</p>
<ul>
<li><p><strong>主线程</strong>和内核<strong>负责处理读写数据、接受新连接等I/O操作</strong>，主线程读写完后，主线程向工作线程通知并直接发送读取后的结果给工作线程进行处理</p></li>
<li><p><strong>工作线程</strong>仅负责<strong>业务逻辑</strong>，如处理<strong>客户请求</strong>。通常由异步I/O实现</p></li>
</ul>
<p><strong>同步I/O模拟Proactor模式</strong></p>
<p>异步I/O一般采用如<code>aio_read</code>和<code>aio_write</code>等函数来处理读写数据，但本项目中使用同步I/O模拟Proactor事件处理模式</p>
<p>以epoll_wait实现同步I/O模型为例:</p>
<ul>
<li><p>主线程往<strong>epoll内核事件表注册</strong>socket上的读就绪事件。</p></li>
<li><p>主线程调用<strong>epoll_wait等待</strong>socket上有数据可读</p></li>
<li><p>当socket上有数据可读，epoll_wait通知主线程，<strong>主线程从socket循环读取数据，直到没有更多数据可读</strong>，然后将读取到的数据封装成一个请求对象并插入请求队列。</p></li>
<li><p>睡眠在请求队列上<strong>某个工作线程被唤醒</strong>，它获得请求对象并<strong>处理客户请求</strong>，然后往epoll内核事件表中<strong>注册</strong>该socket上的<strong>写就绪事件</strong></p></li>
<li><p>主线程调用<strong>epoll_wait等待socket可写</strong>。</p></li>
<li><p>当socket上有数据可写，epoll_wait通知主线程。<strong>主线程</strong>往socket上<strong>写入服务器处理客户请求的结果</strong>。</p></li>
</ul>
<p><img src="/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/proactor.png" width="80%" heigh="80"></p>
<p><strong>Reactor与Proactor的区别</strong></p>
<ul>
<li>Reactor模式中，主线程负责监听是否有事件发生，并将事件分发给工作线程处理
<ul>
<li>操作是同步的，严格按照时序执行（因为要严格按照时序，所以数据读写都是在工作线程内跟解析和打包同步执行）</li>
</ul></li>
<li>Proactor模式中，主线程负责处理读写数据、接受新连接等I/O操作，等<strong>处理完事件后</strong>再直接发送读取后的结果给工作线程进行业务处理
<ul>
<li>在I/O操作时是异步的，当I/O操作执行时，线程可以处理其他事情</li>
</ul></li>
</ul>
<blockquote>
<p>参考：<a href="https://mbd.baidu.com/ma/s/xTShUzFr">Reactor和Proactor的区别</a></p>
</blockquote>
<blockquote>
<p>举个实际生活中的例子，Reactor
模式就是快递员在楼下，给你打电话告诉你快递到你家小区了，你需要自己下楼来拿快递。而在
Proactor 模式下，快递员直接将快递送到你家门口，然后通知你。</p>
</blockquote>
<h2 id="四总结">四、总结</h2>
<ul>
<li><strong>reactor</strong>是一种基于<strong>待完成事件</strong>的<strong>同步I/O</strong>模型</li>
<li><strong>proactor</strong>是一种基于<strong>已完成事件</strong>的<strong>异步I/O</strong>模型</li>
</ul>
<p>学完并发模式，我们就可以了解了WebServer项目中，主线程创建epoll监听后，分别对I/O事件如信号、定时、socket接受客户端连接、客户端socket读写事件等的多线程处理模式</p>
<p>接下来就可以完成<strong>半同步半反应堆线程池</strong>的代码和理论学习，因为线程池是实现并发模式的基础，也是项目中进行事件处理的基础：<a href="https://akirazheng.github.io/2024/03/09/WebServer%E5%AD%A6%E4%B9%A05%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E8%AE%BE%E8%AE%A1/">WebServer学习5：线程池与数据库连接池设计</a></p>
<blockquote>
<p>参考：<a href="https://mp.weixin.qq.com/s/EDzFOo3gcivOe_RgipkTkQ">​网络 IO
演变发展过程和模型介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习7：定时器控制客户端存活时间</title>
    <url>/2024/03/26/WebServer%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<h2 id="一概述本项目中定时器的使用">一、概述本项目中定时器的使用</h2>
<h3 id="定时器的作用">1.1 定时器的作用</h3>
<p>本项目定时器主要用于控制客户端的存活时间，定时删除不活跃的文件描述符。（不活跃的文件描述符指的是，客户端在一定时间内<strong>没有发送请求报文给服务器</strong>，<strong>服务器也没有发送响应报文</strong>，则服务器认为客户端已经断开连接，需要将其从epoll内核事件表中删除和关闭文件描述符，并删除对应的定时器）</p>
<h3 id="定时器处理非活跃连接">1.2 定时器处理非活跃连接</h3>
<p>本项目中定时器处理非活跃连接的实现原理是：</p>
<p><strong>每次有客户端连接到服务器，服务器就为其创建一个定时器，并将其加入到定时器容器中。</strong>
但是实际上，本项目只在主线程中<strong>开启一个真实的定时器</strong>，其他的定时器都是通过<strong>定时器容器</strong>来模拟的。</p>
<p>具体来说，定时器容器是一个<strong>升序链表</strong>，链表中的每个节点对应一个客户端的定时器，每个定时器都有一个超时时间变量（绝对时间），主线程中真实的定时器每隔一段时间（倒计时结束）就会<strong>遍历定时器容器</strong>，检查每个定时器的<strong>超时时间是否小于当前时间</strong>，如果小于当前时间，说明该客户端节点过期了，就会执行定时器节点的回调函数，回调函数中会关闭对应的文件描述符，并将其从epoll内核事件表中删除。</p>
<p>遍历容器的过程如下所示：</p>
<p><img src="/2024/03/26/WebServer%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4/timerContainer.png"></p>
<h2 id="二定时器容器的实现">二、定时器容器的实现</h2>
<p>定时器容器其实是一种<strong>数据结构</strong>，不是真实的定时器，它的作用是用于管理所有的定时器节点（处理非活跃连接）。常用的数据结构有<strong>双向升序链表</strong>、<strong>时间轮</strong>、<strong>时间堆（二叉树）</strong>等，本项目中使用的是<strong>双向升序链表</strong>。</p>
<p><strong>函数指针</strong></p>
<p>在定时器的实现中会大量用到函数指针，所以需要先复习一下函数指针的用法。</p>
<p>函数指针：C++中每个函数的<strong>函数名</strong>就是一个<strong>指针</strong>，可以通过函数名获取函数的地址，然后将函数地址赋值给函数指针，通过函数指针调用函数。</p>
<p>函数指针的定义如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">返回数据类型 (<span class="emphasis">* 函数指针名)(函数参数列表);</span></span><br></pre></td></tr></table></figure>
<p>举个例子，定义一个<code>int test(int a)</code>函数，然后定义一个函数指针<code>int (*p)(int)</code>，将<code>test</code>函数的地址赋值给<code>p</code>，然后通过<code>p</code>调用<code>test</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">int</span></span> (*p)(<span class="keyword">int</span>);<span class="comment">//定义函数指针</span></span><br><span class="line">    p = test;<span class="comment">//将test函数的地址赋值给p</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="built_in">p</span>(<span class="number">10</span>);<span class="comment">//通过p调用test函数</span></span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户节点的定义client_data">2.1 用户节点的定义client_data</h3>
<p>项目中将<strong>客户端连接资源信息</strong>封装在一个<strong>结构体（client_data）</strong>中，包括<strong>客户端socket地址</strong>、<strong>文件描述符</strong>、<strong>定时器类</strong>等信息。然后将所有的<strong>定时器节点</strong>放入一个<strong>双向升序链表</strong>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前向声明util_timer定时器类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span></span><br><span class="line"><span class="comment">//定时器节点中的用户数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span>&#123;</span></span><br><span class="line">    sockaddr_in address;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    util_timer *timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用户结构与定时器容器之间的关系：</p>
<p><img src="/2024/03/26/WebServer%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4/timerContainerStruct.png"></p>
<h3 id="节点中的定时器节点类util_timer">2.2
节点中的定时器节点类util_timer</h3>
<p>在用户结构体中，有一个<strong>util_timer</strong>类的指针，这个类是<strong>定时器类</strong>，作为定时器容器中的一个节点，用于<strong>管理定时器</strong>。由于定时器容器是双向升序链表，所以定时器类中还有<strong>前向和后向指针</strong>。</p>
<p>定时器类的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器节点：双向升序链表的节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">util_timer</span>():<span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">time_t</span> expire;<span class="comment">//任务的超时时间，这里使用绝对时间（定时器超时时间）</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*cb_func)(client_data *);<span class="comment">//任务回调函数：timeout后实现socket和定时器的移除</span></span><br><span class="line">    client_data *user_data;<span class="comment">//回调函数处理的客户数据，由定时器的执行者传递给回调函数</span></span><br><span class="line">    util_timer *prev, *next;<span class="comment">//前向和后向指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于节点到期后处理的操作是<strong>fd移出epoll</strong>并关闭<strong>socket连接</strong>，所以定时器类中的回调函数<code>cb_func</code>是一个<strong>函数指针</strong>，指向一个<strong>处理函数</strong>，用于处理到期后的操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除epoll中非活动连接的客户端socket、关闭连接</span></span><br><span class="line"><span class="keyword">int</span> *Utils::u_pipefd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> Utils::u_epollfd = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Utils</span>;</span><span class="comment">//前向声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//删除主程序epoll中对应客户端的fdSchufa</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(Utils::u_epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(user_data);<span class="comment">//断言，确保user_data不为空，否则直接返回</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭客户端socket连接</span></span><br><span class="line">    <span class="built_in">close</span>(user_data-&gt;sockfd);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器容器双向升序链表">2.3 定时器容器（双向升序链表）</h3>
<p>项目中为每个用户连接创建一个<code>util_timer</code>类的定时器节点，并在主程序的<code>Utils</code>实例中维护一个<strong>双向升序链表</strong>（<code>sort_timer_lst</code>），用于管理所有的定时器节点。</p>
<p>跟普通的数据结构一样，双向升序链表也有<strong>插入节点</strong>、<strong>删除节点</strong>、<strong>调整节点</strong>等操作。</p>
<ul>
<li><strong>插入节点</strong>：<code>add_timer</code>函数将新节点插入到链表中，保持链表的升序性
<ul>
<li>如果链表为空，直接作为头-尾节点插入</li>
<li>如果链表不为空，遍历链表，找到合适的位置插入</li>
</ul></li>
<li><strong>删除节点</strong>：<code>del_timer</code>函数将指定节点从链表中删除</li>
<li><strong>调整节点</strong>：<code>adjust_timer</code>函数将指定节点调整到合适的位置
<ul>
<li>当客户端与服务器有数据交互时，需要重启定时器，这时候对应节点的定时器时间会<strong>往后延迟过期时间</strong>，所以节点在链表中的位置也需要往后调整</li>
<li>当被调整的目标节点在<strong>链表尾部</strong>，或者定时时间仍然<strong>小于下一个节点</strong>的定时时间时，<strong>不用调整</strong></li>
<li>否则，将目标节点从链表中删除，<strong>重新插入</strong>到链表中(<code>add_timer</code>函数)</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器容器：双向升序链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sort_timer_lst</span>();</span><br><span class="line">    ~<span class="built_in">sort_timer_lst</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer)</span></span>;<span class="comment">//添加定时器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span></span>;<span class="comment">//通过递归调整定时器节点位置</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer *timer)</span></span>;<span class="comment">//删除定时器节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span></span>;<span class="comment">//SIGALRM信号每次被触发就在信号处理函数中执行一次tick函数，以处理链表上到期的任务</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span>;<span class="comment">//添加新用户的定时器节点timer（while找到合适的位置插入）</span></span><br><span class="line"></span><br><span class="line">    util_timer *head;</span><br><span class="line">    util_timer *tail;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空定时器不加入容器中</span></span><br><span class="line">    <span class="keyword">if</span>(!timer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//head为空，当前定时器设为头节点(当前定时器为唯一节点)</span></span><br><span class="line">    <span class="keyword">if</span>(!head)&#123;</span><br><span class="line">        head = tail = timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前定时器的超时时间 &lt; 头节点的超时时间，插入头节点（实现升序）</span></span><br><span class="line">    <span class="keyword">if</span>(timer-&gt;expire &lt; head-&gt;expire)&#123;</span><br><span class="line">        timer-&gt;next = head;</span><br><span class="line">        head-&gt;prev = timer;</span><br><span class="line">        head = timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其它情况需要遍历链表（add_timer函数实现while搜索，找到合适的位置插入）</span></span><br><span class="line">    <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span></span>&#123;</span><br><span class="line">    util_timer *prev = lst_head;</span><br><span class="line">    util_timer *tmp = prev-&gt;next;<span class="comment">//头节点已经被判断过了，所以从头节点的下一个节点开始判断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到链表中第一个比timer大的节点位置，插入到该节点之前</span></span><br><span class="line">    <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">        <span class="comment">//1. 找到了</span></span><br><span class="line">        <span class="keyword">if</span>(timer-&gt;expire &lt; tmp-&gt;expire)&#123;</span><br><span class="line">            <span class="comment">// 插入节点</span></span><br><span class="line">            prev-&gt;next = timer;</span><br><span class="line">            timer-&gt;next = tmp;</span><br><span class="line">            tmp-&gt;prev = timer;</span><br><span class="line">            timer-&gt;prev = prev;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//插入完成，退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 没找到，更新当前节点和prev节点</span></span><br><span class="line">        prev = tmp;</span><br><span class="line">        tmp = tmp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历后没找到，说明timer的超时时间最大，插入到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span>(!tmp)&#123;<span class="comment">//tmp为nullptr</span></span><br><span class="line">        prev-&gt;next = timer;</span><br><span class="line">        timer-&gt;prev = prev;</span><br><span class="line">        timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        tail = timer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::del_timer</span><span class="params">(util_timer *timer)</span></span>&#123;</span><br><span class="line">    <span class="comment">//空节点直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(!timer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链表中只有一个定时器节点</span></span><br><span class="line">    <span class="keyword">if</span>((timer == head) &amp;&amp; (timer == tail))&#123;</span><br><span class="line">        head = <span class="literal">nullptr</span>;</span><br><span class="line">        tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被删除的定时器是头节点</span></span><br><span class="line">    <span class="keyword">if</span>(timer == head)&#123;</span><br><span class="line">        head = head-&gt;next;<span class="comment">//头节点后移</span></span><br><span class="line">        head-&gt;prev = <span class="literal">nullptr</span>;<span class="comment">//新头节点的前向指针置空</span></span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//被删除的定时器是尾节点</span></span><br><span class="line">    <span class="keyword">if</span>(timer == tail)&#123;</span><br><span class="line">        tail = tail-&gt;prev;<span class="comment">//尾节点前移</span></span><br><span class="line">        tail-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//新尾节点的后向指针置空</span></span><br><span class="line">        <span class="keyword">delete</span> timer;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其它情况正常移除节点即可</span></span><br><span class="line">    timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">    timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">    <span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整定时器：当定时器的超时时间延长时(socket有新的收发消息行为)，调整定时器在链表中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::adjust_timer</span><span class="params">(util_timer *timer)</span></span>&#123;</span><br><span class="line">    <span class="comment">//ps: 调整时间只会延长，所以只需要向后调整（向前调整不会发生）;且timer已经在链表中</span></span><br><span class="line"></span><br><span class="line">    util_timer *tmp = timer-&gt;next;<span class="comment">//当前节点只会往后调or原地不动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 空节点直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(!timer) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 已经是尾节点 or 超时时间仍然小于下一个节点的超时时间，不需要调整</span></span><br><span class="line">    <span class="keyword">if</span>(!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 被调整的节点是头节点：将timer从链表中取出，重新插入</span></span><br><span class="line">    <span class="keyword">if</span>(timer == head)&#123;</span><br><span class="line">        <span class="comment">//将timer从链表中取出并更新头节点</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">        timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新插入：只能往后调整，所以从新头节点开始找</span></span><br><span class="line">        <span class="built_in">add_timer</span>(timer, head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 其它情况：将timer从链表中取出，从timer的下一个节点开始找合适的位置插入</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//将timer从链表中取出</span></span><br><span class="line">        timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">        timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新插入：只能往后调整，所以从timer的下一个节点开始找</span></span><br><span class="line">        <span class="built_in">add_timer</span>(timer, timer-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三定时实现与信号通信流程">三、定时实现与信号通信流程</h2>
<p>项目中实现定时器到时中断后跟主程序的通信是通过<strong>信号</strong>和<strong>管道</strong>实现的。</p>
<h3 id="管道的创建">3.1 管道的创建</h3>
<p>管道（pipe）是一种<strong>半双工通信方式</strong>，传输方式固定只能从<strong>写端</strong>传到<strong>读端</strong>，可以实现<strong>父子进程之间</strong>的通信。在本项目中，<strong>主线程</strong>（<code>epoll</code>监听）和<strong>信号处理函数</strong>（<code>sig_handler</code>）之间的通信是通过管道实现的。</p>
<p>管道也是一种文件描述符，所以本项目创建一个长度为2的<code>int</code>型数组，用于存放管道的读写文件描述符。在C++中通过<code>socketpair</code>函数创建管道。</p>
<p>其中，<code>pipefd[0]</code>是<strong>读端</strong>，<code>pipefd[1]</code>是<strong>写端</strong>。<strong>读端</strong>加入到主线程的<code>epoll</code>监听中，<strong>写端</strong>在信号处理函数中写入数据。当程序中唯一的定时器到时后，会触发<code>SIGALRM</code>信号并自动触发信号处理函数<code>sig_handler</code>，信号处理函数中向管道的<strong>写端</strong>写入数据，主线程中的<code>epoll</code>监听到<strong>读端</strong>有数据，就会对定时器容器进行遍历，处理到期的定时器。</p>
<p><img src="/2024/03/26/WebServer%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4/timerSignalProcess.png"></p>
<h4 id="socketpair函数创建管道">3.1.1 socketpair函数创建管道</h4>
<p>在Linux中，使用<code>socketpair</code>函数创建一对<strong>无名套接字</strong>，并将套接字的文件描述符存放在<code>int</code>型数组中。函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> sv[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">//ret = socketpair(PF_UNIX, SOCK_STREAM, 0, m_pipefd);</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>domain</code>：协议族，可以是<code>PF_UNIX</code>（UNIX域协议族）或<code>PF_INET</code>（IPv4协议族）</li>
<li><code>type</code>：套接字类型，可以是<code>SOCK_STREAM</code>（字节流TCP套接字）或<code>SOCK_DGRAM</code>（数据报UDP套接字）</li>
<li><code>protocol</code>：协议类型，只能为0</li>
<li><code>sv[2]</code>：存放套接字文件描述符的数组（<code>sv[0]</code>是读端，<code>sv[1]</code>是写端；对应本项目中的<code>pipefd[2]</code>）</li>
<li>返回值<code>ret</code>：成功返回0，失败返回-1</li>
</ul>
<p>本项目中前面学过的<code>epoll</code>实现中，已经在<code>Utils</code>工具类中封装了关于<code>epoll</code>添加文件描述符的函数<code>addfd</code>以及设置文件描述符阻塞方式的函数<code>setnonblocking</code>，所以通过<code>socketpair</code>创建管道后，将<strong>读端</strong>加入到<code>epoll</code>监听中直接调用该函数即可。</p>
<p>将管道文件描述符设置为<strong>非阻塞</strong>，是为了避免管道套接字缓冲区写满了，阻塞导致<strong>异步</strong>执行的信号处理函数<code>sig_handler</code>执行时间过长影响主线程的正常工作。</p>
<p>在<code>webserver.cpp</code>中创建管道的代码如下(<code>eventListen</code>函数)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过socketpair创建全双工管道,管道也是一种文件描述符</span></span><br><span class="line"><span class="comment">//管道作用:可以通过管道在程序中实现进程间通信</span></span><br><span class="line">ret = <span class="built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_pipefd);<span class="comment">//创建全双工管道读端m_pipefd[0]和写端m_pipefd[1]：写端是定时器向epoll通知事件的，epoll监听读端</span></span><br><span class="line"><span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">utils.<span class="built_in">setnonblocking</span>(m_pipefd[<span class="number">1</span>]);<span class="comment">//设置写端非阻塞</span></span><br><span class="line">utils.<span class="built_in">addfd</span>(m_epollfd, m_pipefd[<span class="number">0</span>], <span class="literal">false</span>, <span class="number">0</span>);<span class="comment">//将读端加入主线程epoll监听</span></span><br></pre></td></tr></table></figure>
<h4 id="管道中传递的信号值">3.1.2 管道中传递的信号值</h4>
<p>项目中管道中传递的数据是<strong>信号值</strong>，即<code>SIGALRM</code>和<code>SIGTERM</code>信号的值。其中，<code>SIGALRM</code>信号代表定时器到时，<code>SIGTERM</code>信号代表服务器关闭（用户在终端执行了<code>Ctrl+C</code>）。</p>
<p>这两个信号在库函数中有定义，可以直接使用。<code>SIGALRM</code>的值是14，<code>SIGTERM</code>的值是15。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGALRM 14  <span class="comment">//由alarm系统调用产生timer时钟信号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIGTERM 15  <span class="comment">//终端发送的终止信号</span></span></span><br></pre></td></tr></table></figure>
<h3 id="信号通信流程">3.2 信号通信流程</h3>
<p>在Linux中，信号是一种<strong>异步通知机制</strong>，用于通知进程发生了某种事件。信号是由<strong>内核</strong>或其他进程发送给目标进程的，目标进程在接收到信号后会<strong>中断当前的正常流程</strong>，执行信号处理函数。</p>
<p>需要先将本项目中关注的两种信号<code>SIGALRM</code>和<code>SIGTERM</code>的<strong>信号处理函数</strong><code>sig_handler</code>注册到系统中，然后在信号处理函数中实现对应的功能。</p>
<p>注册函数：项目中在<code>lst_timer.cpp</code>中定义了信号处理函数<code>sig_handler</code>的实现，其中信号处理函数<code>sig_handler</code>只简单地向管道的<strong>写端</strong>写入信号值。后续的操作交由主线程去处理，这样能保证异步处理不耗时的工作，防止影响主线程。</p>
<h4 id="addsig函数注册绑定信号-信号处理函数">3.2.1
addsig函数：注册绑定信号-信号处理函数</h4>
<p>C++中信号注册主要通过<code>sigaction</code>结构体对信号属性进行封装设置，然后通过<code>sigaction()</code>函数注册信号处理函数。</p>
<p><code>sigaction</code>结构体定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*sa_handler)(<span class="keyword">int</span>); <span class="comment">//信号处理函数，当收到信号时，执行sa_handler函数</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *); <span class="comment">//信号处理函数，与 sa_handler 互斥</span></span><br><span class="line">    <span class="keyword">sigset_t</span> sa_mask; <span class="comment">//在信号处理函数执行期间需要阻塞的信号集合</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags; <span class="comment">//指定信号处理的行为，触发sa_handler信号处理函数时会被自动传入sa_handler函数中</span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*sa_restorer)(<span class="keyword">void</span>); <span class="comment">//已经废弃</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，结构体中的信号处理函数<code>sa_handler</code>就是后面还会讲到的<code>sig_handler</code>函数。</p>
<p><code>sa_mask</code>是一个信号集合，用于在信号处理函数执行期间<strong>阻塞</strong>的信号，防止信号处理函数执行过程中被其他信号打断。</p>
<p><code>sigaction</code>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *act, struct sigaction *oldact)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>signum</code>：注册的信号值，即<code>SIGALRM</code>和<code>SIGTERM</code></li>
<li><code>act</code>：新的信号处理方式（属性），即<code>sigaction</code>结构体</li>
<li><code>oldact</code>：旧的信号处理方式（属性），用于保存之前的信号处理方式，如果不关心可以传入<code>nullptr</code></li>
</ul>
<p>因此本项目实现的<code>addsig</code>信号注册函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加绑定信号函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handle)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart)</span></span>&#123;</span><br><span class="line">    <span class="comment">//sigaction结构体：用于设置和处理信号处理程序的结构体</span></span><br><span class="line">    <span class="comment">/*struct sigaction &#123;</span></span><br><span class="line"><span class="comment">        void (*sa_handler)(int); //信号处理函数，当收到信号时，执行sa_handler函数</span></span><br><span class="line"><span class="comment">        void (*sa_sigaction)(int, siginfo_t *, void *); //信号处理函数，与 sa_handler 互斥</span></span><br><span class="line"><span class="comment">        sigset_t sa_mask; //在信号处理函数执行期间需要阻塞的信号集合</span></span><br><span class="line"><span class="comment">        int sa_flags; //指定信号处理的行为，触发sa_handler信号处理函数时会被自动传入sa_handler函数中</span></span><br><span class="line"><span class="comment">        void (*sa_restorer)(void); //已经废弃</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建sigaction结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sa));</span><br><span class="line">    sa.sa_handler = handle;<span class="comment">//设置信号处理函数</span></span><br><span class="line">    <span class="keyword">if</span>(restart)&#123;</span><br><span class="line">        <span class="comment">//SA_RESTART：如果信号中断了进程的某个系统调用，系统调用就会自动重启</span></span><br><span class="line">        sa.sa_flags |= SA_RESTART;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sigfillset</span>(&amp;sa.sa_mask);<span class="comment">//添加到默认信号集sa_mask中，处理当前默认信号集sa_mask时阻塞其它信号集，以确保信号处理程序的执行不会被其他信号中断</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">sigaction</span>(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);<span class="comment">//注册信号处理函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="sig_handler函数信号处理函数">3.2.2
sig_handler函数：信号处理函数</h4>
<p>当<strong>内核</strong>检测到<strong>信号发生</strong>时，检测<strong>signal位图信息</strong>（也就是前面注册过的），然后通知<strong>用户态</strong>调用对应的<strong>信号处理函数</strong>。</p>
<p>具体流程如下：</p>
<p><img src="/2024/03/26/WebServer%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4/signalProcess.png"></p>
<p>由上图可知，Linux下信号采用异步机制，信号处理函数和当前进程是两条不同的执行路线。</p>
<p>在注册时我们选择了屏蔽方式，所以为了确保信号不会被屏蔽太久，本项目中信号处理函数仅仅通过管道发送信号值，不处理信号对应的逻辑（由主程序处理），缩短异步执行时间，减少对主程序的影响。</p>
<ul>
<li>内核的工作
<ul>
<li>内核<strong>检测和接收</strong>信号，同时向<strong>用户进程</strong>发送一个中断，使其进入内核态</li>
<li>当信号处理函数执行完毕后，还会<strong>返回内核态</strong>，检查是否还有其它信号未处理</li>
</ul></li>
<li>用户态的工作
<ul>
<li>用户进程<strong>接收</strong>内核的中断</li>
<li>进入<strong>信号处理函数</strong>，执行信号处理函数的逻辑</li>
<li>所有的信号处理完毕后，<strong>返回用户态</strong>，继续执行用户进程的正常流程（恢复到中断前运行的位置）</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//信号处理函数：处理信号SIGALRM-SIGTERM</span></span><br><span class="line"><span class="comment">//通过管道通知主循环有SIGALRM or SIGTERM信号需要处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line">    <span class="comment">//保留原来的errno，在函数最后恢复，以保证函数的可重入性</span></span><br><span class="line">    <span class="keyword">int</span> save_errno = errno;</span><br><span class="line">    <span class="keyword">int</span> msg = sig;</span><br><span class="line">    <span class="built_in">send</span>(u_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *)&amp;msg, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//通过管道的写端来通知主循环，有信号需要处理（传给主循环epoll监听的管道读端）</span></span><br><span class="line">    errno = save_errno;<span class="comment">//恢复原来的errno</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="主程序中注册信号">3.2.3 主程序中注册信号</h4>
<p>在<code>webserver.cpp</code>中的<code>eventListen</code>函数中，注册了两个信号<code>SIGALRM</code>和<code>SIGTERM</code>，并绑定了信号处理函数<code>sig_handler</code>。</p>
<p>另外，我们除了<code>SIGALRM</code>和<code>SIGTERM</code>信号外，还注册了<code>SIGPIPE</code>信号，将其处理方式设置为<code>SIG_IGN</code>，即忽略<code>SIGPIPE</code>信号。<code>SIGPIPE</code>信号是在<strong>读取已关闭的管道</strong>时产生的，如果不处理<code>SIGPIPE</code>信号，当读取已关闭的管道时会导致程序退出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绑定不同信号（SIGPIPE-SIGALRM-SIGTERM）的信号处理函数（忽略 or sig_handler发送sig标识）</span></span><br><span class="line">utils.<span class="built_in">addsig</span>(SIGPIPE, SIG_IGN);</span><br><span class="line">utils.<span class="built_in">addsig</span>(SIGALRM, utils.sig_handler, <span class="literal">false</span>);</span><br><span class="line">utils.<span class="built_in">addsig</span>(SIGTERM, utils.sig_handler, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>同时在<code>eventListen</code>函数中开启唯一的定时器，通过<code>alarm</code>函数设置定时器的超时时间，当定时器到时后会发送注册过的<code>SIGALRM</code>信号后，触发信号处理函数<code>sig_handler</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启动定时器，每TIMESLOT秒发送SIGALRM信号（整个程序中只有一个真实的定时器，定时器容器中的是存储超时的绝对时间来与这个唯一的timeout处理进行比较）</span></span><br><span class="line"><span class="built_in">alarm</span>(TIMESLOT);</span><br></pre></td></tr></table></figure>
<h2 id="四完整的定时器使用流程主循环中">四、完整的定时器使用流程（主循环中）</h2>
<p>首先，服务端开启时，创建一个定时器容器，并创建一个全双工管道，将管道的读端加入到<code>epoll</code>监听中。注册两个信号<code>SIGALRM</code>和<code>SIGTERM</code>，并绑定信号处理函数<code>sig_handler</code>。</p>
<p>然后，开启唯一的定时器，通过<code>alarm</code>函数设置唯一真实定时器的超时时间，当定时器到时后会发送注册过的<code>SIGALRM</code>信号后，触发信号处理函数<code>sig_handler</code>将信号值写入管道发送给主线程，由主线程决定执行什么操作。</p>
<p>之后，主线程epoll管道读端监听到有管道数据，会调用<code>dealwithsignal</code>函数解析信号值，根据信号值的不同重置<code>timeout</code>or<code>stop_server</code>标识符（处理定时器操作or关闭服务器）。</p>
<p>最后，根据用户的连接请求具体地实现定时器使用：</p>
<ul>
<li>当客户端与服务器连接时（连接事件），为其创建一个用户结构（结构体中包含定时器节点，并将定时器节点加入到定时器容器中）</li>
<li>当客户端与服务器有数据交互时(读/写事件)，需要重置该定时器节点，调整定时器在链表中的位置</li>
<li>当定时器到时后，处理定时信号，将<code>timeout</code>标志设置为<code>true</code>，在主线程中遍历定时器容器，处理删除到期的定时器节点</li>
</ul>
<p>除了<code>SIGALRM</code>信号外，我们还注册了<code>SIGTERM</code>信号，这里顺便讲一下，当管道读端接收到<code>SIGTERM</code>信号时，主线程会将<code>stop_server</code>标志设置为<code>true</code>，退出<code>eventLoop</code>的<code>while</code>循环，关闭服务器。</p>
<p><img src="/2024/03/26/WebServer%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4/dealwithsignal.png"></p>
<p><strong>主线程循环中epoll监听到管道读端有数据</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主循环:epoll_wait阻塞监听事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebServer::eventLoop</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop_server)&#123;</span><br><span class="line">        <span class="comment">//epoll_wait设置为-1,也就是阻塞监听事件</span></span><br><span class="line">        <span class="comment">//当有事件发生时,epoll_wait返回事件个数number,且事件存在events数组中</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="built_in">epoll_wait</span>(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历events数组,处理就绪事件</span></span><br><span class="line">        <span class="keyword">if</span>(number &lt; <span class="number">0</span> &amp;&amp; errno != EINTR)&#123;</span><br><span class="line">            <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;epoll failure&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//管道读端有事件发生:信号处理，通过dealwithsignal从epoll管道读端读取信号，并解析对应的信号（SIGALRM-SIGTERM）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((sockfd == m_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN))&#123;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="built_in">dealwithsignal</span>(timeout, stop_server);</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">false</span> == flag)</span><br><span class="line">                    <span class="built_in">LOG_ERROR</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;dealclientdata failure&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理定时器事件:timer tick定时中断,执行timer_handler处理链表上到期的节点</span></span><br><span class="line">        <span class="keyword">if</span> (timeout)</span><br><span class="line">        &#123;</span><br><span class="line">            utils.<span class="built_in">timer_handler</span>();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">LOG_INFO</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;timer tick&quot;</span>);</span><br><span class="line"></span><br><span class="line">            timeout = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>针对timeout标志的处理</strong></p>
<p>定时器到时后，调用<code>timer_handler</code>函数处理链表上到期的节点，处理完后重开定时器。</p>
<p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数发现定时器超时，调用该函数查找超时定时器并处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Utils::timer_handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_timer_lst.<span class="built_in">tick</span>();<span class="comment">//定时器容器中查找并处理超时定时器</span></span><br><span class="line">    <span class="built_in">alarm</span>(m_TIMESLOT);<span class="comment">//重新定时，以不断触发SIGALRM信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>tick</code>函数是定时器容器中的一个函数，用于处理链表上到期的节点。由于容器是升序的，所以当找到第一个未到期的节点时，就可以结束遍历。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SIGALRM信号每次被触发，主循环管道读端监测出对应的超时信号后就会调用timer_handler进而调用定时器容器中通过tick函数查找并处理超时定时器</span></span><br><span class="line"><span class="comment">// 处理链表上到期的任务(定时器timeout回调函数删除socket和定时器)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_timer_lst::tick</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">time_t</span> cur = <span class="built_in">time</span>(<span class="literal">NULL</span>);<span class="comment">//当前定时器到时的绝对时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环定时器容器，比较定时器的超时时间和当前时间（都是绝对时间）</span></span><br><span class="line">    util_timer *tmp = head;</span><br><span class="line">    <span class="keyword">while</span> (tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt; tmp-&gt;expire)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于定时器是升序链表，所以未找到cur &lt; tmp-&gt;expire前，前面的节点都是超时的，得删除节点并关闭连接</span></span><br><span class="line">        <span class="comment">// （通过回调函数cb_func处理，cb_func不删除定时器节点）</span></span><br><span class="line">        tmp-&gt;<span class="built_in">cb_func</span>(tmp-&gt;user_data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除超时节点并更新tmp和head</span></span><br><span class="line">        head = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (head)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于需要删除的非活跃连接，执行定时器节点中的回调函数<code>cb_func</code>，在回调函数中关闭对应的文件描述符，并将其从epoll内核事件表中删除。执行完回调函数后就可以
在容器中<code>delete</code>删除该定时器节点了。</p>
<h2 id="五总结">五、总结</h2>
<p>本文完成了Webserver项目中通过定时器实现了对<strong>非活跃连接的客户端</strong>的处理，主要知识点有<strong>管道</strong>、<strong>信号机制</strong>、<strong>定时器容器</strong>等。</p>
<p>完成了定时器，项目基本已经完善了，但是为了<strong>对服务器运行状态进行监控维护</strong>，最后还需要添加<strong>日志系统</strong>，下一篇文章将会讲解日志系统的实现。具体内容请看下一篇博客<a href="https://akirazheng.github.io/2024/03/27/WebServer%E5%AD%A6%E4%B9%A08%EF%BC%9A%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/">WebServer学习8：通用日志系统的设计</a></p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习6：HTTP连接处理及报文机制</title>
    <url>/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="一从http用户类在主线程epoll监听中的初始化说起">一、从HTTP用户类在主线程epoll监听中的初始化说起</h2>
<h3 id="webserver.cpp文件中的http用户初始化">1.1
<code>WebServer.cpp</code>文件中的HTTP用户初始化</h3>
<p>回到<code>WebServer.cpp</code>类中的<code>eventLoop</code>函数，我们可以看到在<code>epoll</code>监听的主线程中，当处理<strong>新的客户端连接事件</strong>时，会在处理新连接的<code>dealclientdata</code>函数中，通过<code>timer</code>函数同时<strong>初始化一个http
user</strong>和一个定时器。</p>
<h3 id="http_conn.cpp文件中的http用户初始化函数的实现">1.2
<code>http_conn.cpp</code>文件中的HTTP用户初始化函数的实现</h3>
<p>在<code>http_conn.cpp</code>文件中对新用户连接的初始化</p>
<ul>
<li>包括类中一些如数据库信息、数据读取模式等变量、以及一些HTTP处理中间变量的初始化</li>
<li>同时还包括对主函数中的<code>epoll</code>监听该客户端<code>socketfd的初始化</code></li>
</ul>
<h4 id="对http_conn类中的变量初始化">对http_conn类中的变量初始化</h4>
<p>这里的初始化包括传参的<code>init</code>函数和无参重载的<code>init</code>函数，其中传参的<code>init</code>函数主要是对客户端连接信息的初始化，而无参重载的<code>init</code>函数主要是对类中功能实现的一些中间变量的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化客户端连接中http_conn的一些用户状态参数，这个函数是在主线程（epoll）中收到用户的连接处理accept时调用的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;addr, <span class="keyword">char</span> *root, <span class="keyword">int</span> TRIGMode,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">int</span> close_log, string user, string passwd, string sqlname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>, m_TRIGMode);<span class="comment">//将sockfd注册到epoll中</span></span><br><span class="line">    m_user_count++;<span class="comment">//客户端连接数+1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当浏览器出现连接重置时，可能是网站根目录出错或http响应格式出错或者访问的文件中内容完全为空</span></span><br><span class="line">    doc_root = root;</span><br><span class="line">    m_TRIGMode = TRTGMide;</span><br><span class="line">    m_close_log = close_log;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据库的用户名、密码、数据库名</span></span><br><span class="line">    <span class="built_in">strcpy</span>(sql_user, user.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_passwd, passwd.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">strcpy</span>(sql_name, sqlname.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化http_conn类中剩下的一些参数为默认值</span></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化http_conn类中剩下的一些参数为默认值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mysql = <span class="literal">NULL</span>;</span><br><span class="line">    bytes_to_send = <span class="number">0</span>;</span><br><span class="line">    bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    m_check_state = CHECK_STATE_REQUESTLINE;<span class="comment">//根据报文的结构，主状态机初始状态应该是解析请求行，也就是CHECK_STATE_REQUESTLINE</span></span><br><span class="line">    m_linger = <span class="literal">false</span>;</span><br><span class="line">    m_method = GET;</span><br><span class="line">    m_url = <span class="number">0</span>;</span><br><span class="line">    m_version = <span class="number">0</span>;</span><br><span class="line">    m_content_length = <span class="number">0</span>;</span><br><span class="line">    m_host = <span class="number">0</span>;</span><br><span class="line">    m_start_line = <span class="number">0</span>;</span><br><span class="line">    m_checked_idx = <span class="number">0</span>;</span><br><span class="line">    m_read_idx = <span class="number">0</span>;</span><br><span class="line">    m_write_idx = <span class="number">0</span>;</span><br><span class="line">    cgi = <span class="number">0</span>;</span><br><span class="line">    m_state = <span class="number">0</span>;</span><br><span class="line">    timer_flag = <span class="number">0</span>;</span><br><span class="line">    improv = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化清空缓冲区</span></span><br><span class="line">    <span class="built_in">memset</span>(m_read_buf, <span class="string">&#x27;\0&#x27;</span>, READ_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_write_buf, <span class="string">&#x27;\0&#x27;</span>, WRITE_BUFFER_SIZE);</span><br><span class="line">    <span class="built_in">memset</span>(m_real_file, <span class="string">&#x27;\0&#x27;</span>, FILENAME_LEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对主函数中的epoll监听该客户端socketfd的初始化">对主函数中的<code>epoll</code>监听该客户端<code>socketfd的初始化</code></h4>
<p>我们看到传参的<code>init</code>函数还执行了<code>addfd</code>函数，这个函数就是处理主线程中<code>epoll</code>监听的<code>socketfd</code>的初始化</p>
<p>这里涉及的几个epoll相关函数其实跟之前在<code>timer</code>类中的几个相关函数是<strong>一样的代码</strong>，只是为了区分epoll中对serverfd的初始化监听和对clientfd的初始化监听，所以这里将这几个函数又单独封装在了<code>http_conn</code>类中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册事件到epool中进行监听，这里其实跟util.cpp中的addfd实现是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot, <span class="keyword">int</span> TRIGMode)</span></span>&#123;</span><br><span class="line">    <span class="comment">//注册fd及其相关的events事件到epoll中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建事件:注册fd文件描述符</span></span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给fd注册对应的epoll监听事件</span></span><br><span class="line">    <span class="keyword">if</span>(TRIGMode == <span class="number">1</span>)</span><br><span class="line">        <span class="comment">//注册ET模式</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//注册LT模式</span></span><br><span class="line">        event.events = EPOLLIN | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册EPOLLONESHOT事件:设置fd是否只加内特一次</span></span><br><span class="line">    <span class="keyword">if</span>(one_shot)</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册fd到epoll中:epoll_ctl函数增fd</span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置fd为非阻塞(ET模式下必须设置非阻塞,包括listenfd和connfd)</span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置客户端socketfd为非阻塞，这里也跟util.cpp中的setnonblocking实现是一样的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用 fcntl 函数来设置文件描述符的属性</span></span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二通过reactor和proactor两种事件处理模式理解http的读事件处理">二、通过Reactor和Proactor两种事件处理模式理解HTTP的读事件处理</h2>
<h3 id="read_once函数处理socketfd的读事件">1.
read_once()函数处理socketfd的读事件</h3>
<p>根据上一节的学习，我们已经知道，Reactor模式会在<strong>工作线程</strong><code>worker</code>中取出任务并执行<code>read_once()</code></p>
<p>而Proactor模式会在<strong>主线程</strong><code>epoll</code>监听到客户端socketfd读事件后，直接在主线程执行<code>read_once()</code></p>
<p>那么这个<code>read_once()</code>函数到底为何方神圣？</p>
<p><code>read_once()</code>函数封装在<code>http_conn</code>类中，实现了epoll两种触发模式的读事件。</p>
<p><strong>LT模式</strong></p>
<p>LT模式下不需要一次性读取完，会分多次读取，所以每次读的时候用<code>if</code>执行就行，不需要循环执行recv函数</p>
<p><strong>ET模式</strong></p>
<p>ET模式下需要一次性读取完，所以需要<code>while</code>执行recv函数，直到读完为止</p>
<p>最终读取的数据都会存放在当前用户实例化http_conn类的<code>m_read_buf</code>中，然后用<code>m_read_idx</code>变量标记读取的数据的长度（m_read_idx个bytes）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// epoll监测到客户端sockfd有读事件时，调用read_once循环读取数据到buffer中，直到无数据可读或者对方关闭连接</span></span><br><span class="line"><span class="comment">// 在reactor模式下，该函数是在工作线程中调用的，在proactor模式下，该函数是在主线程中调用的</span></span><br><span class="line"><span class="comment">// 非阻塞ET工作模式下，需要一次性将数据读完</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::read_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= READ_BUFFER_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数据读到m_read_buf + m_read_idx位置开始的内存中（存在读缓冲区m_read_buf中）</span></span><br><span class="line">    <span class="comment">//LT方式读取数据：epoll_wait会多次通知读数据，直到读完，所以这里不用while循环</span></span><br><span class="line">    <span class="keyword">if</span>(m_TRIGMode == <span class="number">0</span>)&#123;</span><br><span class="line">        bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);<span class="comment">//bytes_read代表收到的字节数,char型的buff一位也代表一个字节</span></span><br><span class="line">        m_read_idx += bytes_read;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(bytes_read &lt;= <span class="number">0</span>)&#123;<span class="comment">//读取失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ET方式读取数据：epoll_wait只通知一次读数据，所以这里要用while循环读完</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            bytes_read = <span class="built_in">recv</span>(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(bytes_read == <span class="number">-1</span>)&#123;<span class="comment">//接收失败</span></span><br><span class="line">                <span class="keyword">if</span>(errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//接收结束</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bytes_read == <span class="number">0</span>)&#123;<span class="comment">//对方关闭连接</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            m_read_idx += bytes_read;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//ET读完所有数据返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="process函数进行报文解析和处理">2.
process()函数进行报文解析和处理</h3>
<p><code>process()</code>函数同样封装在<code>http_conn</code>类中</p>
<p>无论是Reactor模式还是Proactor模式，<code>process()</code>函数都是在工作线程中执行的，它的作用是对<code>read_once()</code>函数读取到的报文进行解析和处理。</p>
<p>Reactor模式下是<strong>工作线程</strong>中取出任务并执行socket读操作（<code>read_once()</code>）后再执行<code>process()</code>函数进行报文解析和处理。</p>
<p>而Proactor模式下<strong>工作线程</strong>直接执行<code>process()</code>函数进行报文解析和处理。（因为主线程已经完成了<code>read_once()</code>的操作）</p>
<ul>
<li><code>process()</code>函数主要先处理客户端的<strong>请求报文</strong>，如果请求报文还没有读完，那么就继续将clientfd注册为<strong>可读事件</strong>，等待下一次读取。</li>
<li>成功解析处理完请求报文后，根据请求报文打包<strong>响应报文</strong>，然后将clientfd注册为<strong>可写事件</strong>，等待下一次写入。</li>
</ul>
<p>所以<code>process()</code>函数除了涉及报文的处理外，还需要涉及到<strong>epoll</strong>的<strong>重置事件监听模式</strong>和<strong>删除描述符</strong>操作。</p>
<ul>
<li><code>process()</code>函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进行报文解析处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//解析请求报文</span></span><br><span class="line">    HTTP_CODE read_ret = <span class="built_in">process_read</span>();<span class="comment">//http客户端刚进来肯定是先读取解析请求报文</span></span><br><span class="line">    <span class="keyword">if</span> (read_ret == NO_REQUEST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);<span class="comment">//NO_REQUEST是数据没读完，还需要继续读取，重新注册读事件（EPOLLIN）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成响应报文</span></span><br><span class="line">    <span class="keyword">bool</span> write_ret = <span class="built_in">process_write</span>(read_ret);</span><br><span class="line">    <span class="keyword">if</span> (!write_ret)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close_conn</span>();<span class="comment">//报文生成失败，关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);<span class="comment">//报文生成成功，注册写事件（EPOLLOUT），发送响应报文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>epoll</code>重置事件监听模式和删除描述符与关闭客户端连接操作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将事件重置为EPOLLONESHOT（ONESHOT模式只监听一次事件就会从epoll中删除）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> ev, <span class="keyword">int</span> TRIGMode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == TRIGMode)</span><br><span class="line">        event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;<span class="comment">//ET模式下，EPOLLONESHOT是必须的</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        event.events = ev | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从epoll中删除fd（一般是close_conn中把对应的socketfd从epoll中删除）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);<span class="comment">//关闭socket前先从epoll中移除</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="keyword">bool</span> real_close)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(real_close &amp;&amp; (m_sockfd != <span class="number">-1</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;close %d\n&quot;</span>, m_sockfd);</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;<span class="comment">//关闭一个连接，将客户总量减一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三http报文的主从状态机解析模式">三、HTTP报文的主从状态机解析模式</h2>
<h3 id="主从状态机模式">3.1 主从状态机模式</h3>
<p><strong>从状态机</strong>主要是将<code>read_once</code>读取到的数据通过识别到的<code>\r\n</code>结束符进行分割，取出一行数据交给<strong>主状态机</strong>进行处理。</p>
<p>状态机的实现过程如下图所示：</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/State_machine.png"></p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/State_machine2.png"></p>
<ul>
<li><strong>从状态机</strong>有三种状态表示读取一行的状态
<ul>
<li><code>LINE_OK</code>：读取到一个完整的行</li>
<li><code>LINE_BAD</code>：行读取出错（缺少<code>\r</code>或<code>\n</code>）</li>
<li><code>LINE_OPEN</code>：行数据尚且不完整，如LT模式下还需要继续不断读取</li>
</ul></li>
<li><strong>主状态机</strong>有三种状态表示解析报文的状态
<ul>
<li><code>CHECK_STATE_REQUESTLINE</code>：解析请求行（<code>init</code>初始化一个客户user时就会默认初始化为这个状态）</li>
<li><code>CHECK_STATE_HEADER</code>：解析头部字段</li>
<li><code>CHECK_STATE_CONTENT</code>：解析请求内容（POST有消息体，GET无）</li>
</ul></li>
</ul>
<h3 id="http报文格式">3.2 HTTP报文格式</h3>
<p>HTTP报文格式中的<strong>请求行、请求头、请求数据（消息主体）</strong>分别对应了<strong>主状态机</strong>中的<strong>三种解析状态</strong>。</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/HTTP_Frame.png"></p>
<h3 id="从状态机的实现逻辑">3.3 从状态机的实现逻辑</h3>
<p>从状态机的实现逻辑主要是通过<code>http_conn</code>类中的<code>parse_line</code>函数实现的，这个函数的作用是通过识别到的<code>\r\n</code>作为一行数据的结束符进行分割，取出一行数据交给<strong>主状态机</strong>进行处理。</p>
<p>多一个<code>LINE_OPEN</code>状态是因为在LT模式下，需要不断读取数据，直到读取到一个完整的行。（也就是当前处理的buffer有可能不是完整的，需要持续解析）</p>
<p>具体实现逻辑细节可以看代码注释</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从状态机，用于一行一行解析出客户端发送请求的报文，并将解读行的状态作为返回值</span></span><br><span class="line"><span class="comment">//主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。</span></span><br><span class="line"><span class="comment">//注意，由于报文中的content没有固定的行结束标志，所以content的解析不在从状态机中进行，而是在主状态机中进行</span></span><br><span class="line"><span class="comment">//状态1：LINE_OK表示读完了完整的一行（读到了行结束符\r\n）</span></span><br><span class="line"><span class="comment">//状态2：LINE_BAD表示读取的行格式有误（结束符只读到了\r或\n，而不是\r + \n）</span></span><br><span class="line"><span class="comment">//状态3：LINE_OPEN表示LT模式下还没接收完完整的buffer，还需等待继续recv到buffer后再次触发解析数据包</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    <span class="comment">//循环当前buffer中已读取到的数据</span></span><br><span class="line">    <span class="comment">//如果是ET模式，则客户端发送的数据包是已经全部读完了的，buffer是完整的</span></span><br><span class="line">    <span class="comment">//如果是LT模式，则客户端发送的数据包是分批次读取的，buffer是不完整的，所以需要LINE_OPEN状态来等待下一次读取</span></span><br><span class="line">    <span class="keyword">for</span>(;m_checked_idx &lt; m_read_idx; ++m_checked_idx)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*m_checked_idx:    当前已确认（取出）的字符位置</span></span><br><span class="line"><span class="comment">          temp:             当前读取到的m_checked_idx处的字符</span></span><br><span class="line"><span class="comment">          m_read_idx:       读缓冲区中的数据长度（已经接收的socket的数据总长度）</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        temp = m_read_buf[m_checked_idx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 读到一个完整行的倒数第二个字符\r</span></span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">//如果已经把buffer中已经接收的数据读完了，但是此时buffer中的数据还不完整，那么就返回LINE_OPEN状态，等待下一次读取</span></span><br><span class="line">            <span class="keyword">if</span>((m_checked_idx + <span class="number">1</span>) == m_read_idx)&#123;<span class="comment">//m_read_idx是个数，所以这里index得+1</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果读到了完整的行，也几乎是判断出了下一个字符为&#x27;\n&#x27;就返回LINE_OK</span></span><br><span class="line">            <span class="comment">//LINE_OK状态在主状态机中是可以进行行解析的状态</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//&#x27;\r&#x27;换成&#x27;\0&#x27;</span></span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//&#x27;\n&#x27;换成&#x27;\0&#x27;，m_checked_idx更新为下一行的起始位置</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果读到的行格式有误，即buffer明明还没结束，但是读不到&#x27;\n&#x27;了，则返回LINE_BAD状态</span></span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 读到一个完整行的最后一个字符\n</span></span><br><span class="line">        <span class="comment">//情况1：正常来说对于完整的数据而言，&#x27;\n&#x27;应该已经被上面的if语句处理了，但是还存在第一种情况是LT下数据是还没读完整的</span></span><br><span class="line">        <span class="comment">//      也就是对于上面的if中，已经读到了m_read_idx了，返回LINE_OPEN，等接着继续读到socket数据再触发当前函数时，就会从&#x27;\n&#x27;开始判断</span></span><br><span class="line">        <span class="comment">//情况2：当前数据是坏数据，没有配套的&#x27;\r&#x27;+ &#x27;\n&#x27;，所以返回LINE_BAD</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp == <span class="string">&#x27;\n&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m_checked_idx &gt; <span class="number">1</span> &amp;&amp; m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)&#123;</span><br><span class="line">                m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//&#x27;\r&#x27;换成&#x27;\0&#x27;</span></span><br><span class="line">                m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//&#x27;\n&#x27;换成&#x27;\0&#x27;，m_checked_idx更新为下一行的起始位置</span></span><br><span class="line">                <span class="keyword">return</span> LINE_OK;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果上一个字符不是&#x27;\r&#x27;，则说明数据包格式有误，返回LINE_BAD</span></span><br><span class="line">            <span class="keyword">return</span> LINE_BAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LINE_OPEN;<span class="comment">//读完了buffer中的数据，但是数据包可能还没读完，需要等待下一次读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主状态机的实现逻辑">3.4 主状态机的实现逻辑</h3>
<p>主状态机的实现逻辑主要是通过<code>http_conn</code>类中的<code>process_read</code>函数实现的，这个函数的作用是对<code>parse_line</code>函数读取到的一行数据进行下一步处理，处理是根据<strong>从状态机的读取状态</strong>配合<strong>主状态机的解析状态</strong>进行的。</p>
<p>其中如果是单纯的GET请求，那么只需要解析请求行和请求头，而不需要解析请求内容，我们使用从状态机的<code>((line_status = parse_line()) == LINE_OK)</code>进行判断就行，每读完完整一行就主状态机进行一次解析（请求行or请求头）。</p>
<p>但是为了保证客户用户名和密码的安全，我们还需要对POST请求的请求内容进行解析，这时候我们就需要使用主状态机的<code>m_check_state == CHECK_STATE_CONTENT</code>进行判断，这个状态是在解析请求头的时候就已经确定了的。当主状态机状态转为<code>CHECK_STATE_CONTENT</code>时，此时就不需要再进入从状态机的<code>parse_line</code>函数进行读取了，因为消息体没有固定的行结束标志(<code>\r\n</code>)，所以我们直接在主状态机中进行解析，根据<code>m_read_idx</code>读完剩下的数据就行。</p>
<p>同时为了主状态机处理完完整的HTTP报文后能退出<code>while</code>循环，我们在解析完content后将<code>line_status</code>重置为<code>LINE_OPEN</code>代表结束。（这里由于进入content解析状态前，<code>line_status</code>还会保持上一个状态的<code>LINE_OK</code>，所以不会影响主状态机进入content的解析）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主状态机，用于处理解析读取到的报文</span></span><br><span class="line"><span class="comment">//状态1：CHECK_STATE_REQUESTLINE（进行请求行的解析--从状态机中获取数据位置）</span></span><br><span class="line"><span class="comment">//状态2：CHECK_STATE_HEADER（进行请求头的解析--从状态机中获取数据位置）</span></span><br><span class="line"><span class="comment">//状态3：CHECK_STATE_CONTENT（进行请求内容的解析--主状态机中读取buffer剩下的所有数据）</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LINE_STATUS line_status = LINE_OK;  <span class="comment">//初始化当前从状态机的行处理状态</span></span><br><span class="line">    HTTP_CODE ret = NO_REQUEST;         <span class="comment">//初始化当前HTTP请求的处理结果</span></span><br><span class="line">    <span class="keyword">char</span> *text = <span class="number">0</span>;                     <span class="comment">//存储主状态机当前正在解析的行数据（字符串）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主状态机解析状态通过从状态机来驱动：LINE_OK说明主状态机可以开始解析了</span></span><br><span class="line">    <span class="comment">//1. 如果是GET请求，那么其实只需要parse_line()函数就能保证解析完整个请求报文</span></span><br><span class="line">    <span class="comment">//2. 但是由于POST请求的content没有固定的行结束标志，所以content的解析不在从状态机中进行，而是在主状态机中进行</span></span><br><span class="line">    <span class="comment">//   当主状态机由CHECK_STATE_HEADER转移到CHECK_STATE_CONTENT时，我们将主状态机继续循环的判断改为m_check_state == CHECK_STATE_CONTENT，表示content部分不进入从状态机解析</span></span><br><span class="line">    <span class="comment">//   同时为了保证解析完content后能退出循环，我们在解析完content后将line_status = LINE_OPEN</span></span><br><span class="line">    <span class="comment">//   这里由于进入content解析状态前，line_status还会保持上一个状态的LINE_OK，所以不会影响主状态机进入content的解析</span></span><br><span class="line">    <span class="keyword">while</span>((m_check_state == CHECK_STATE_CONTENT &amp;&amp; line_status == LINE_OK) || ((line_status = <span class="built_in">parse_line</span>()) == LINE_OK))&#123;</span><br><span class="line">        text = <span class="built_in">get_line</span>();</span><br><span class="line">        m_start_line = m_checked_idx;<span class="comment">//更新为下一行的起始位置，方便下次调用get_line获取当前行的字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// LOG_INFO(&quot;%s&quot;, text);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//主状态机根据当前状态机状态进行报文解析</span></span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(m_check_state)&#123;</span><br><span class="line">        <span class="comment">//1. 解析请求行</span></span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_REQUESTLINE:</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">parse_request_line</span>(text);</span><br><span class="line">            <span class="keyword">if</span>(ret == BAD_REQUEST)&#123;</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 解析请求头</span></span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_HEADER:</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">parse_headers</span>(text);</span><br><span class="line">            <span class="keyword">if</span>(ret == BAD_REQUEST)&#123;</span><br><span class="line">                <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//------------------------------</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == GET_REQUEST)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3. 解析请求内容</span></span><br><span class="line">        <span class="keyword">case</span> CHECK_STATE_CONTENT:</span><br><span class="line">        &#123;</span><br><span class="line">            ret = <span class="built_in">parse_content</span>(text);</span><br><span class="line">            <span class="comment">//------------------------------</span></span><br><span class="line">            <span class="keyword">if</span>(ret == GET_REQUEST)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">do_request</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            line_status = LINE_OPEN;<span class="comment">//从状态机状态转为允许继续读取数据</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;<span class="comment">//表示socket还需要继续读取数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四主状态机三部分的解析逻辑">四、主状态机三部分的解析逻辑</h2>
<h3 id="解析请求行">4.1 解析请求行</h3>
<p>解析请求行的逻辑主要是通过<code>http_conn</code>类中的<code>parse_request_line</code>函数实现的，这个函数的作用是对请求行进行解析，解析出请求方法、请求URL、HTTP版本号。其中请求行的格式举例如下所示：</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/request_line.jpg"></p>
<p>由于请求头只有一行，所以我们只需要解析一次结束后，就将主状态机的状态从<code>CHECK_STATE_REQUESTLINE</code>转为<code>CHECK_STATE_HEADER</code>。</p>
<p>其中获取的<code>URL</code>在本项目中共有8种情况，分别是：</p>
<ul>
<li><code>/</code>：主页，即<code>judge.html</code>，<strong>（GET）</strong></li>
<li><code>/0</code>：注册页面，即<code>register.html</code>，<strong>（POST）</strong></li>
<li><code>/1</code>：登录页面，即<code>log.html</code>，<strong>（POST）</strong></li>
<li><code>/2CGISQL.cgi</code>：登录检验，<strong>（POST）</strong>
<ul>
<li>成功：跳转到<code>welcome.html</code></li>
<li>失败：跳转到<code>logError.html</code>(action跟<code>log.html</code>相同，都为<code>2CGISQL.cgi</code>)</li>
</ul></li>
<li><code>/3CGISQL.cgi</code>：注册检验，<strong>（POST）</strong>
<ul>
<li>成功：跳转到<code>log.html</code></li>
<li>失败：跳转到<code>registerError.html</code>(action跟<code>register.html</code>相同，都为<code>3CGISQL.cgi</code>)</li>
</ul></li>
<li><code>/5</code>：跳转到<code>picture.html</code>图片请求页面，<strong>（POST）</strong></li>
<li><code>/6</code>：跳转到<code>video.html</code>视频请求页面，<strong>（POST）</strong></li>
<li><code>/7</code>：跳转到<code>fans.html</code>关注页面，<strong>（POST）</strong></li>
</ul>
<p>在请求头我们只对<code>/</code>进行处理，剩下的交给<code>do_request</code>函数统一进行处理和响应。(也就是只处理最开始的主界面)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理主状态机状态1：解析请求行，获得GET/POST方法、url、http版本号</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*请求行格式举例：GET / HTTP/1.1</span></span><br><span class="line"><span class="comment">      请求行的格式：| 请求方法 | \t | URL | \t | HTTP版本号 | \r | \n |</span></span><br><span class="line"><span class="comment">      经过parse_line()函数处理后\r\n被替换成\0\0，所以这里可以直接用字符串函数来处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 获取URL：资源在服务端中的路径</span></span><br><span class="line">    m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);<span class="comment">//m_url:指向请求报文中的URL的index</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">    *m_url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取method：请求方法，本项目中只支持GET和POST</span></span><br><span class="line">    <span class="keyword">char</span> *method = text;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        m_method = GET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(method, <span class="string">&quot;POST&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_method = POST;</span><br><span class="line">        cgi = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取http版本号：http版本号只支持HTTP/1.1</span></span><br><span class="line">    m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!m_version)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    *m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">7</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(m_url, <span class="string">&quot;https://&quot;</span>, <span class="number">8</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_url += <span class="number">8</span>;</span><br><span class="line">        m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 解析URL资源</span></span><br><span class="line">    <span class="comment">// 当URL为/时，显示初始欢迎界面&quot;judge.html&quot;</span></span><br><span class="line">    <span class="comment">// 剩下的其它URL资源的解析在do_request()函数中进行同一实现</span></span><br><span class="line">    <span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(m_url) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">strcat</span>(m_url, <span class="string">&quot;judge.html&quot;</span>);<span class="comment">//将url追加到字符串中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 请求行解析完毕，主状态机由CHECK_STATE_REQUESTLINE转移到CHECK_STATE_HEADER，解析请求头</span></span><br><span class="line">    m_check_state = CHECK_STATE_HEADER;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;<span class="comment">//当前只解析完了请求行，还没解析完完整HTTP报文，所以返回NO_REQUEST</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们再来讲一下HTTP是怎么实现将URL封装在报文中的。</p>
<p>我们知道，静态http页面实际上是通过<code>.html</code>文件来实现的，浏览器可以解析显示对应的html文件。我们在设计<code>.html</code>文件时，会通过html的<code>form</code>标签来实现用户表单的提交，这个表单提交的<code>action</code>属性就是<strong>请求行</strong>的<code>URL</code>，<code>method</code>属性就是请求行的<code>method</code>（GET/POST）。</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/url_action.png"></p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/judge.png"></p>
<h3 id="解析请求头">4.2 解析请求头</h3>
<p>解析请求头的逻辑是通过<code>http_conn</code>类中的<code>parse_headers</code>函数实现的，这个函数的作用是对请求头进行解析，解析出<strong>请求头的字段和值</strong>。其中请求头的格式举例如下所示：</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/headers.jpg"></p>
<p>其中本项目只对<code>Connection</code>、<code>Content-Length</code>、<code>Host</code>三个字段进行处理，剩下的字段直接跳过</p>
<ul>
<li><code>Connection</code>：判断是长连接还是短连接，有两个可能值<code>keep-alive</code>或<code>close</code>
<ul>
<li>HTTP/1.1默认是长连接，所以一般收到的都是<code>keep-alive</code></li>
</ul></li>
<li><code>Content-Length</code>：请求内容的长度，用于判断主状态机是否需要转移到<strong>消息主体解析状态</strong>
<ul>
<li>如果是<strong>GET请求</strong>，那么<strong>请求内容长度为0</strong>，主状态机不需要转移到<code>CHECK_STATE_CONTENT</code>状态，直接执行<code>do_request</code>响应报文就行</li>
<li>如果是<strong>POST请求</strong>，那么<strong>请求内容长度不为0</strong>，主状态机需要被触发转移到<code>CHECK_STATE_CONTENT</code>状态，<strong>结束主状态机中请求头的解析状态</strong>，转为解析请求内容获取请求内容中的数据（用户名和密码）</li>
</ul></li>
<li><code>Host</code>：请求的主机名，用于判断请求的资源是哪个主机的
<ul>
<li>本项目中只有一个主机（采用回环IP<code>127.0.0.1</code>），所以不需要判断</li>
</ul></li>
</ul>
<p>其中代码中要注意<code>m_linger</code>变量是用于<strong>返回响应报文时</strong>添加对应的<code>Connection</code>字段的值的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理主状态机状态2：解析请求头，获取Connection字段、Content-Length字段、Host字段</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*请求行格式举例：Connection:keep-alive</span></span><br><span class="line"><span class="comment">      请求行的格式：| 头部字段名 | : |   | \t | \r | \n |</span></span><br><span class="line"><span class="comment">      经过parse_line()函数处理后\r\n被替换成\0\0，所以这里可以直接用字符串函数来处理</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 遇到空行| \r | \n |，表示头部字段解析完毕</span></span><br><span class="line">    <span class="keyword">if</span>(text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//空行后通过头部字段中的Content-Length字段判断请求报文是否包含消息体（GET命令中Content-Length为0，POST非0）</span></span><br><span class="line">        <span class="keyword">if</span>(m_content_length != <span class="number">0</span>)&#123;</span><br><span class="line">            m_check_state = CHECK_STATE_CONTENT;<span class="comment">//消息体不为空，POST请求，主状态机还需要转移到CHECK_STATE_CONTENT，解析请求内容</span></span><br><span class="line">            <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;<span class="comment">//GET请求，主状态机解析完毕，返回GET_REQUEST</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 解析Connection字段，判断是keep-alive还是close</span></span><br><span class="line">    <span class="comment">//  HTTP/1.1默认是持久连接(keep-alive)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">11</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcasecmp</span>(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_linger = <span class="literal">true</span>;<span class="comment">//用于返回响应报文时添加对应的Connection字段的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 解析Content-Length字段，获取消息体的长度（主要是用于判断主状态机是否需要转为CHECK_STATE_CONTENT状态）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Content-length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">15</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_content_length = <span class="built_in">atol</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 解析Host字段，获取请求的主机名</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncasecmp</span>(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        text += <span class="number">5</span>;</span><br><span class="line">        text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">        m_host = text;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//其它字段本项目不解析，直接跳过</span></span><br><span class="line">        <span class="comment">// LOG_INFO(&quot;oop!unknow header: %s&quot;, text);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析请求内容">4.3 解析请求内容</h3>
<p>请求内容的解析比较简单，只要根据<code>Content-Length</code>字段的值判断是否已经读完了完整的HTTP消息体，然后将消息体内容存放在<code>m_string</code>中用于后面<code>do_request</code>的账号密码处理即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理主状态机状态3：解析请求内容，获取POST请求中的消息体</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断http请求的消息体是否被完整读入</span></span><br><span class="line">    <span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//POST请求中最后为输入的用户名和密码</span></span><br><span class="line">        m_string = text;<span class="comment">//m_string用于存储POST请求中的消息体</span></span><br><span class="line">        <span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息体还没读完，继续读</span></span><br><span class="line">    <span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五报文响应">五、报文响应</h2>
<h3 id="do_request函数解析请求资源路径">5.1
<code>do_request</code>函数解析请求资源路径</h3>
<p>由于<code>do_request</code>需要对用户名和密码进行处理，本项目为了减少对数据库的频繁访问，在<code>main.cpp</code>初始化程序时就将数据库中的所有用户名和密码都读取出来，存放在<code>users</code>map表中，若需要比对则直接跳过<code>users.find()</code>匹配查询即可</p>
<p>在<code>do_request</code>中需要将<code>WebServer</code>类中初始化的<code>root</code>路径和<code>http_conn</code>类中解析的<code>URL</code>路径拼接起来，形成完整的<code>m_real_file</code>资源路径，然后根据资源路径的不同进行不同的处理。</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/url_page_source.png"></p>
<p>从<a href="###4.1-解析请求行">4.1
解析请求行</a>中可知，本项目请求资源路径的响应共有8种情况。</p>
<p>其中对于<strong>注册</strong>，需要先判断用户名是否已存在，之后再申请从<strong>数据库池</strong>中获取一个<strong>新的数据库连接</strong>执行<strong>插入</strong>操作实现注册</p>
<p>对于<strong>登录</strong>，需要<strong>验证用户名和密码</strong>，直接<code>users.find()</code>匹配查询即可</p>
<p>对于<strong>其它资源请求</strong>，直接根据报文的<code>m_url</code>将资源路径存入<code>m_real_file</code>中即可</p>
<p>简化的<code>do_request</code>代码执行流程图如下所示：</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/do_request.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解析完整的HTTP请求后，解析请求的URL进行处理并返回响应报文</span></span><br><span class="line"><span class="comment">//m_real_file:完成处理后拼接的响应资源在服务端中的完整路径</span></span><br><span class="line"><span class="comment">//m_string   :POST请求中在parse_content()中解析出的消息体（包含用户名和密码）</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 将m_real_file初始化为项目的根目录（WebServer类中初始化过的root）</span></span><br><span class="line">    <span class="built_in">strcpy</span>(m_real_file, doc_root);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line">    <span class="comment">//printf(&quot;m_url:%s\n&quot;, m_url);</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="built_in">strrchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 处理登录/注册请求（消息体中都会有用户名和密码）</span></span><br><span class="line">    <span class="comment">//处理cgi：POST请求会将cgi置为1</span></span><br><span class="line">    <span class="keyword">if</span> (cgi == <span class="number">1</span> &amp;&amp; (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span> || *(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据标志判断是登录检测还是注册检测（flag为&quot;2&quot;是登录，为&quot;3&quot;是注册）</span></span><br><span class="line">        <span class="keyword">char</span> flag = m_url[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(m_url_real, m_url + <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.1 将用户名和密码提取出来</span></span><br><span class="line">        <span class="comment">//存于报文的消息体中：user=akira&amp;password=akira</span></span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">100</span>], password[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">//a. 通过识别连接符 &amp; 确定用户名</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">5</span>; m_string[i] != <span class="string">&#x27;&amp;&#x27;</span>; ++i)</span><br><span class="line">            name[i - <span class="number">5</span>] = m_string[i];</span><br><span class="line">        name[i - <span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">//b. 确定密码</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = i + <span class="number">10</span>; m_string[i] != <span class="string">&#x27;\0&#x27;</span>; ++i, ++j)</span><br><span class="line">            password[j] = m_string[i];</span><br><span class="line">        password[j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 处理注册请求</span></span><br><span class="line">        <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//构造sql INSERT语句（插入）</span></span><br><span class="line">            <span class="keyword">char</span> *sql_insert = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(sql_insert, <span class="string">&quot;INSERT INTO user(username, passwd) VALUES(&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, name);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;, &#x27;&quot;</span>);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, password);</span><br><span class="line">            <span class="built_in">strcat</span>(sql_insert, <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//首先查看数据库中是否已有重复的用户名：map中查找</span></span><br><span class="line">            <span class="comment">//没有重名的，进行增加数据</span></span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) == users.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                m_lock.<span class="built_in">lock</span>();</span><br><span class="line">                <span class="keyword">int</span> res = <span class="built_in">mysql_query</span>(mysql, sql_insert);</span><br><span class="line">                users.<span class="built_in">insert</span>(pair&lt;string, string&gt;(name, password));</span><br><span class="line">                m_lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!res)</span><br><span class="line">                    <span class="comment">//注册成功，跳转到登录页面</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//注册失败，跳转到错误页面</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//注册失败，跳转到错误页面(用户名重复)</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/registerError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.2 处理登录请求</span></span><br><span class="line">        <span class="comment">//若浏览器端输入的用户名和密码在map表中可以查找到，返回1，否则返回0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (users.<span class="built_in">find</span>(name) != users.<span class="built_in">end</span>() &amp;&amp; users[name] == password)</span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/welcome.html&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">strcpy</span>(m_url, <span class="string">&quot;/logError.html&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 处理跳转到注册界面的请求</span></span><br><span class="line">    <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/register.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 处理跳转到登录界面的请求</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/log.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 处理图片资源请求</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/picture.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 处理视频资源请求</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/video.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 处理关注界面的请求</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*(p + <span class="number">1</span>) == <span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *m_url_real = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">char</span>) * <span class="number">200</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(m_url_real, <span class="string">&quot;/fans.html&quot;</span>);</span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url_real, <span class="built_in">strlen</span>(m_url_real));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(m_url_real);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断该路径的文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stat</span>(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断文件的权限是否可读</span></span><br><span class="line">    <span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH))</span><br><span class="line">        <span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断请求的资源是文件夹还是文件（文件夹返回BAD_REQUEST，不可响应）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">S_ISDIR</span>(m_file_stat.st_mode))</span><br><span class="line">        <span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过mmap将资源文件映射到内存中，提高文件的访问速度</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="built_in">open</span>(m_real_file, O_RDONLY);</span><br><span class="line">    m_file_address = (<span class="keyword">char</span> *)<span class="built_in">mmap</span>(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>do_request</code>函数中的<code>mmap</code>函数是将资源文件映射到内存中，提高文件的访问速度，这样就不需要每次请求都去读取文件，而是直接从内存中读取，提高了文件的访问速度。关于mmap的介绍将在下面进行报文响应打包时详细说明</p>
<h3 id="打包响应报文">5.2 打包响应报文</h3>
<h4 id="请求报文处理的8种结果">5.2.1 请求报文处理的8种结果</h4>
<ul>
<li>NO_REQUEST
<ul>
<li>请求不完整，需要继续读取请求报文数据</li>
<li>跳转主线程继续监测读事件</li>
</ul></li>
<li>GET_REQUEST
<ul>
<li>获得了完整的HTTP请求</li>
<li>调用do_request完成请求资源映射</li>
</ul></li>
<li>NO_RESOURCE
<ul>
<li>请求资源不存在</li>
<li>跳转process_write完成响应报文</li>
</ul></li>
<li>BAD_REQUEST
<ul>
<li>HTTP请求报文有语法错误或请求资源为目录</li>
<li>跳转process_write完成响应报文</li>
</ul></li>
<li>FORBIDDEN_REQUEST
<ul>
<li>请求资源禁止访问，没有读取权限</li>
<li>跳转process_write完成响应报文</li>
</ul></li>
<li>FILE_REQUEST
<ul>
<li>请求资源可以正常访问</li>
<li>跳转process_write完成响应报文</li>
</ul></li>
<li>INTERNAL_ERROR
<ul>
<li>服务器内部错误，该结果在主状态机逻辑switch的default下，一般不会触发</li>
</ul></li>
</ul>
<p>使用<code>process_write</code>函数进行响应报文打包时，将会根据这8种结果封装<strong>不同的格式化字符串到报文</strong>中</p>
<h4 id="http_conn类中的process_write函数">5.2.2
<code>http_conn</code>类中的<code>process_write</code>函数</h4>
<p>工作线程中<code>process_write</code>根据<code>do_request</code>的请求解析结果（8种状态），通过<strong>5个相关函数</strong>逐个进行响应报文的打包，最后在工作线程中将http_conn用户对应的socketfd注册到epoll中，监听写事件，等待下一次写事件触发，完成响应报文的发送。</p>
<p>通过<code>iovec</code>结构体将多个非连续的内存区域组合在一起（以便在epoll写事件触发时，一次性的I/O操作将内存数据writev写入socketfd中发送给客户端）。</p>
<ul>
<li><code>iovec</code>结构体中的<code>iov_base</code>指向内存区域的起始地址</li>
<li><code>iov_len</code>指明内存区域的长度</li>
</ul>
<p>本项目中，<code>iovec</code>结构体的<code>m_iv</code>数组中存放了两个<code>iovec</code>结构体，分别指向<code>m_write_buf</code>和<code>m_file_address</code></p>
<ul>
<li>如果请求报文处理结果是<code>FILE_REQUEST</code>状态，代表请求的文件资源是可以正常访问的，所以会把响应资源<code>m_file_address</code>也添加到<code>m_iv</code>数组中作为响应报文的<strong>响应体</strong></li>
<li>如果请求报文处理结果是<code>GET_REQUEST</code>状态，代表请求的文件资源是空的，生成一个空的html文件（ok_string）返回</li>
<li>如果请求报文处理结果是其它状态，只申请一个buff的iovec，将<code>m_write_buf</code>添加到<code>m_iv</code>数组中，报文<strong>响应体</strong>调用<code>add_content</code>函数直接添加<strong>格式化的字符串</strong>到<code>m_write_buf</code>中，不需要第二个<code>iovec</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//报文打包状态机：根据服务器处理HTTP请求的结果和状态ret，打包相应的HTTP响应报文</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ret)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//1. 服务器内部错误：500</span></span><br><span class="line">    <span class="comment">//在主状态机switch-case出现的错误，一般不会触发</span></span><br><span class="line">    <span class="keyword">case</span> INTERNAL_ERROR:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">500</span>, error_500_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_500_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 请求报文语法有错/请求的资源不是文件，是文件夹：404</span></span><br><span class="line">    <span class="keyword">case</span> BAD_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">404</span>, error_404_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_404_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 请求资源没有访问权限：403</span></span><br><span class="line">    <span class="keyword">case</span> FORBIDDEN_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">403</span>, error_403_title);</span><br><span class="line">        <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">add_content</span>(error_403_form))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 请求资源可以正常访问：200</span></span><br><span class="line">    <span class="keyword">case</span> FILE_REQUEST:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add_status_line</span>(<span class="number">200</span>, ok_200_title);</span><br><span class="line">        <span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add_headers</span>(m_file_stat.st_size);<span class="comment">//文件字节数，用于Content-Length字段</span></span><br><span class="line">            <span class="comment">// iovec 结构体将多个非连续的内存区域组合在一起，进行一次性的 I/O 操作</span></span><br><span class="line">            <span class="comment">//FILE_REQUEST状态代表请求的文件资源是可以正常访问的，所以需要多申请一个文件资源的iovec</span></span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">            m_iv_count = <span class="number">2</span>;</span><br><span class="line">            bytes_to_send = m_write_idx + m_file_stat.st_size;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//请求的文件资源是空的，生成一个空的html文件（ok_string）返回</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">            <span class="built_in">add_headers</span>(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">add_content</span>(ok_string))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求资源异常的，只申请一个buff的iovec</span></span><br><span class="line">    m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">    m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">    m_iv_count = <span class="number">1</span>;</span><br><span class="line">    bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现process_write的各行报文打包函数">5.2.3
实现<code>process_write</code>的各行报文打包函数</h4>
<ul>
<li><code>add_response</code>：更新<code>m_write_idx</code>指针和缓冲区<code>m_write_buf</code>中的内容，将字符串写入缓冲区
<ul>
<li>采用<strong>可变参函数</strong>，向缓冲区写入格式化字符串</li>
<li>用<code>va_list</code> <code>va_start</code>
<code>va_end</code>来实现变参的列表处理</li>
<li>用<code>vsprintf</code>将格式化的字符串写入缓冲区（<code>m_write_buf</code>）中</li>
</ul></li>
<li><code>add_status_line</code>：添加<strong>状态行</strong>，即HTTP版本号、状态码、状态码描述
<ul>
<li>举例：<code>HTTP/1.1 200 OK\r\n</code></li>
</ul></li>
<li><code>add_headers</code>：添加<strong>消息报头和空行</strong>
<ul>
<li><code>Content-Length</code>字段：Content-Length: 78443</li>
<li><code>Connection</code>字段：Connection: keep-alive</li>
<li>空行：</li>
</ul></li>
<li><code>add_content</code>：添加<strong>响应体</strong>
<ul>
<li>将<code>content</code>中的内容添加到<code>m_write_buf</code>中</li>
</ul></li>
</ul>
<p>其中，<strong>状态行</strong>下的<strong>状态码</strong>有以下几种：</p>
<ul>
<li>200：请求成功</li>
<li>400：请求报文语法有错</li>
<li>403：禁止访问</li>
<li>404：请求资源不存在</li>
<li>500：服务器内部错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ok_200_title = <span class="string">&quot;OK&quot;</span>;<span class="comment">//状态码200表示请求成功，只有这个状态码才是正常状态</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>响应体</strong>的内容有以下几种（只针对请求处理错误的情况，请求资源可访问的情况会返回对应的文件资源而不是这种格式化字符串）：</p>
<ul>
<li>error_400_form：请求报文语法有错</li>
<li>error_403_form：禁止访问</li>
<li>error_404_form：请求资源不存在</li>
<li>error_500_form：服务器内部错误</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to staisfy.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_form = <span class="string">&quot;You do not have permission to get file form this server.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_form = <span class="string">&quot;There was an unusual problem serving the request file.\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>1. add_response</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新m_write_idx指针和缓冲区m_write_buf中的内容：将数据写入缓冲区</span></span><br><span class="line"><span class="comment">//采用可变参函数，向缓冲区写入格式化字符串</span></span><br><span class="line"><span class="comment">//用va_list va_start va_end来实现变参的列表处理</span></span><br><span class="line"><span class="comment">//用vsprintf将格式化的字符串写入缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//已些入的数据m_write_idx指针越界，缓冲区m_write_buf不允许再写入了</span></span><br><span class="line">    <span class="keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可变参数列表接收，通过vsnprintf函数格式化写入缓冲区</span></span><br><span class="line">    va_list arg_list;</span><br><span class="line">    <span class="built_in">va_start</span>(arg_list, format);</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">vsnprintf</span>(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list);</span><br><span class="line">    <span class="comment">//格式化的字符串长度超过缓冲区剩余长度，写入失败</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//格式化字符串写入缓冲区成功，更新m_write_idx指针</span></span><br><span class="line">    m_write_idx += len;</span><br><span class="line">    <span class="built_in">va_end</span>(arg_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LOG_INFO(&quot;request:%s&quot;, m_write_buf);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. add_status_line</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1. 添加状态行：HTTP/1.1 200 OK</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *title)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s %d %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3. add_headers</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 添加消息报头和空行</span></span><br><span class="line"><span class="comment">// Content-Length字段：Content-Length: 78443</span></span><br><span class="line"><span class="comment">// Connection字段：Connection: keep-alive</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="keyword">int</span> content_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_content_length</span>(content_len) &amp;&amp; <span class="built_in">add_linger</span>() &amp;&amp;</span><br><span class="line">           <span class="built_in">add_blank_line</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="keyword">int</span> content_len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// bool http_conn::add_content_type()</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     return add_response(&quot;Content-Type:%s\r\n&quot;, &quot;text/html&quot;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="literal">true</span>) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4. add_content</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 添加响应体：文件资源无法访问的才需要调用这个函数，其他情况都是通过mmap映射到内存中的</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *content)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add_response</span>(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册epoll写事件发送响应报文">5.3
注册epoll写事件发送响应报文</h3>
<p>服务器工作线程在<code>process_write</code>函数中完成<strong>解析请求报文process_read</strong>、<strong>生成响应报文process_write</strong>一系列操作后，在<code>process</code>函数中将http_conn用户对应的socketfd注册到epoll中，监听写事件，等待下一次写事件触发，写事件触发后，调用<code>http_conn</code>类中的<code>write</code>函数，最终将报文发送给客户端。（<strong>Reactor模式</strong>下<code>write</code>函数在工作线程中执行的,<strong>Proactor模式</strong>下<code>write</code>函数在主线程中执行的）</p>
<p>在发送完报文后，如果HTTP的连接属于长连接，那么就继续监听读事件，等待下一次读事件触发；如果HTTP的连接属于短连接，在webserver类或者工作线程中结束write后会调用deal_timer中timer的cb_func函数关闭客户端连接</p>
<p><strong><code>write</code>函数：将缓冲区中的数据通过epoll事件监听发送给客户端</strong></p>
<p>该函数具体逻辑如下：</p>
<p>在生成响应报文时初始化<code>byte_to_send</code>，包括头部信息和文件数据大小。通过<strong><code>writev</code>函数循环发送响应报文数据</strong>，根据返回值更新byte_have_send和iovec结构体的指针和长度，并判断响应报文整体是否发送成功。</p>
<ul>
<li>若writev单次发送成功，更新byte_to_send和byte_have_send的大小，若响应报文整体发送成功,则取消mmap映射,并判断是否是长连接.
<ul>
<li>长连接重置http类实例，注册读事件，不关闭连接，</li>
<li>短连接直接关闭连接</li>
</ul></li>
<li>若writev单次发送不成功，判断是否是写缓冲区满了。
<ul>
<li>若不是因为缓冲区满了而失败，<strong>取消mmap映射</strong></li>
<li>若eagain则满了，更新iovec结构体的指针和长度，并注册写事件，等待下一次写事件触发（当写缓冲区从不可写变为可写，触发epollout），因此在此期间无法立即接收到同一用户的下一请求，但可以保证连接的完整性。</li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向socketfd写数据：</span></span><br><span class="line"><span class="comment">// Reactor模式下，工作线程调用users[sockfd].write函数向客户端发送响应报文</span></span><br><span class="line"><span class="comment">// Proactor模式下，主线程调用users[sockfd].write函数向客户端发送响应报文，不经过工作线程处理</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有数据需要发送，将sockfd从epoll中注册写事件（EPOLLOUT）改为读事件（EPOLLIN）继续监听</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将响应报文发送给客户端</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = <span class="built_in">writev</span>(m_sockfd, m_iv, m_iv_count);<span class="comment">//将多个缓冲区iovec的数据一次性写入（发送）I/O描述符（m_sockfd）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送失败：eagain满了暂时不可用 or 其他情况（取消映射）</span></span><br><span class="line">        <span class="keyword">if</span> (temp &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//I/O缓冲区暂时满了，将sockfd再次注册写事件（EPOLLOUT）继续等待下一次写事件继续发送</span></span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//未知原因发送失败，取消响应资源文件的映射</span></span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//writev负责将缓冲区iovec数据写入I/O描述符，但是不会对已发送的数据进行删除，所以需要更新缓冲区iovec已发送的数据长度</span></span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个缓冲区m_write_buf已全部发送完</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_have_send &gt;= m_iv[<span class="number">0</span>].iov_len)</span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = <span class="number">0</span>;</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_base = m_file_address + (bytes_have_send - m_write_idx);</span><br><span class="line">            m_iv[<span class="number">1</span>].iov_len = bytes_to_send;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个缓冲区m_write_buf还没发送完，更新m_iv[0]后继续发送</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_base = m_write_buf + bytes_have_send;</span><br><span class="line">            m_iv[<span class="number">0</span>].iov_len = m_iv[<span class="number">0</span>].iov_len - bytes_have_send;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//缓冲区全部发送完毕，取消响应资源文件的映射并重新将sockfd注册为读事件（EPOLLIN）</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_to_send &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unmap</span>();</span><br><span class="line">            <span class="built_in">modfd</span>(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//保持长连接，重新初始化http_conn类中的一些参数</span></span><br><span class="line">            <span class="keyword">if</span> (m_linger)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">init</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//短连接return false，在webserver类或者工作线程中结束write后会调用deal_timer中timer的cb_func函数关闭连接</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六浅聊一下mmap延申的内存映射问题">六、浅聊一下mmap延申的内存映射问题</h2>
<p>经过最后epoll监听写事件，我们的完整客户端请求-响应流程就结束了。但是在响应报文生成的过程中，我们提到了<code>mmap</code>，这里我们简单聊一下<code>mmap</code>。</p>
<p><code>mmap</code>是一种内存映射文件的方法，它可以将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中的一段地址的一一对应关系。这样，进程就可以采用指针的方式读写文件，而且可以实现进程间的文件共享。说到这，我们就先得来了解一下什么是<strong>虚拟内存</strong>，什么是<strong>物理内存和驻留内存</strong>。</p>
<p><code>mmap</code>的操作流程如下所示：</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/PageTableProcess.png" width="70%"></p>
<p>如图所示，使用<code>mmap</code>与普通的通过<strong>中断+系统调用</strong>进行I/O文件阻塞读写的区别在于，<code>mmap</code>是通过<strong>内存映射</strong>的方式将文件通过<strong>映射到虚拟内存</strong>中，然后通过<strong>页表</strong>将虚拟内存<strong>映射到物理内存</strong>中，这样可以不经过<strong>用户态和内核态的切换</strong>，直接通过<strong>指针</strong>访问文件，提高了I/O的效率。</p>
<h3 id="虚拟内存vs物理内存和驻留内存">6.1
虚拟内存vs物理内存和驻留内存</h3>
<p><strong>虚拟内存</strong></p>
<p>虚拟内存是操作系统为了对进程地址进行管理而设计的<strong>逻辑上的内存空间</strong>，比如我们编写一个C++程序，采用g++<strong>编译</strong>的时候编译器处理各种指针、变量等采用的就是<strong>虚拟内存</strong>，因为此时程序还未运行，不可能直接访问物理内存。虚拟内存是<strong>连续的</strong>，是<strong>逻辑上的</strong>，是<strong>抽象的</strong>，是<strong>不受物理内存大小限制</strong>的。</p>
<p>所以程序运行过程中用到的指令、代码、数据都必须存在于虚拟内存中。虚拟内存的存在解放了物理内存的大小限制。</p>
<p><strong>物理内存</strong></p>
<p>物理内存是指实实在在的<strong>RAM内存上的空间</strong>，虚拟内存中的程序在物理机器上运行时，通过<strong>页映射表</strong>将虚拟内存中的地址映射到物理内存中的地址，从而真正实现程序运行。</p>
<p>虚拟内存向物理内存的映射是<strong>按需映射</strong>的，因为虚拟内存很大，可能有一部分程序在运行中根本不需要访问到，所以映射时只会讲访问到的部分映射到物理内存中。当需要访问另一部分程序时再将其映射到物理内存中（在<strong>触发缺页中断</strong>时利用<strong>分页技术</strong>将实际的物理内存分配给虚拟内存），所以一个程序运行时在虚拟内存中是<strong>碎片化</strong>存在的（不连续）。</p>
<p><strong>驻留内存</strong></p>
<p>驻留内存是指<strong>已经映射到物理内存中的虚拟内存</strong>，是实实在在<strong>存在于物理内存</strong>中的。</p>
<h3 id="图解三种内存的关联">6.2 图解三种内存的关联</h3>
<p>以下面的图为例，<strong>灰色</strong>代表运行程序中未被访问的部分（没被映射到物理内存中）；<strong>彩色</strong>代表运行程序中被访问的部分在虚拟内存和物理内存中的映射关系。</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/mmap_virtual_physical_space.png"></p>
<p>通过上图可以直观感受到一个程序在<strong>虚拟内存</strong>上是<strong>连续</strong>的，运行时在物理内存是<strong>按需映射</strong>后<strong>碎片化</strong>存在的。也可以得到<strong>虚拟内空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大</strong>的结果。</p>
<p>但是我们可以发现一个很奇怪的现象，为什么程序A中的A4和程序B中的B4<strong>映射到了同一块物理内存中</strong>呢？其实这就涉及<strong>内存共享</strong>的概念，也就是说程序A和程序B中的一部分数据或代码是共享的，这样可以节省物理内存的使用。</p>
<h3 id="内存共享">6.3 内存共享</h3>
<p>程序共享内存主要存在于以下几种情况</p>
<ul>
<li><p><strong>共享库</strong>：多个程序使用相同的库，操作系统可以把这些库加载到内存中的一块区域，这样只用维护一块内存空间</p></li>
<li><p><strong>父子进程</strong>：父子进程之间可以通过<strong>共享内存</strong>进行通信，这样可以减少进程间通信的开销，使他们共同读写一块内存区域</p></li>
<li><p><strong>内存映射文件</strong>：操作系统可以将文件映射到进程的虚拟内存中，本项目中使用的<code>mmap</code>就是这种方式，将文件映射到进程的虚拟内存中，这样可以减少文件拷贝到内存的开销，提高I/O读取效率</p>
<ul>
<li>进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。</li>
</ul></li>
</ul>
<h3 id="从c的角度深入理解内存映射">6.4 从C++的角度深入理解内存映射</h3>
<h4 id="c内存分区">6.4.1 C++内存分区</h4>
<p>C++的代码存于虚拟内存中，C++内存主要分为<strong>栈区</strong>、<strong>堆区</strong>、<strong>全局/静态区</strong>、<strong>常量区</strong>和<strong>代码区</strong>五个区。</p>
<ul>
<li><strong>栈区</strong>：由编译器自动分配释放，存放<strong>函数的实参值</strong>、<strong>局部变量</strong>的值等，栈上的变量⽣命周期与其所在函数的执⾏周期相同。由编译器负责自动分配和释放。（先进后出）</li>
<li><strong>堆区</strong>：由<strong>程序员分配释放</strong>，若程序员不释放，程序结束时由操作系统回收，堆上的变量⽣命周期由程序员显式控制。在C++中可以分配（使⽤
new 或 malloc ）和释放（使⽤ delete 或 free ）。（先进先出）</li>
<li><strong>全局/静态区</strong>：存放<strong>全局变量、静态变量</strong>，程序<strong>一经编译</strong>这些变量就会存在，程序结束后由操作系统释放。</li>
<li><strong>常量区</strong>：存放<strong>常量字符串</strong>，程序结束后由操作系统释放。</li>
<li><strong>代码区</strong>：存放<strong>函数体的二进制代码</strong>。</li>
</ul>
<p>其中栈(stack)的内存地址是向下增长的，堆(heap)的内存地址是向上增长的</p>
<p><img src="/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/mmap_virtual_memory.png"></p>
<p>所以我们平时所说的代码的<strong>运行，分配，操作</strong>等，都是指的<strong>虚拟内存</strong>！！！！！！！！</p>
<p>程序<strong>申请和操作</strong>的内存都是在<strong>虚拟内存</strong>上的，包括<strong>堆(heap)</strong>、<strong>栈(stack)</strong>等。</p>
<h4 id="内存的延迟分配">6.4.2 内存的延迟分配</h4>
<p>前面提到虚拟内存中，其实就属于<strong>延迟分配</strong>，Linux内核在用户申请内存时（比如<code>malloc</code>和<code>new</code>），只是先给它分配在<strong>虚拟内存</strong>中，并不分配实际的物理内存。</p>
<p>只有当用户<strong>使用这块内存</strong>时（比如赋值、读取等），才会触发<strong>缺页中断</strong>，内核才会分配<strong>具体的物理页面</strong>给用户，此时才占用宝贵的物理内存。</p>
<p>内核释放物理页面是<strong>通过虚拟内存找到对应的物理页面</strong>，然后释放物理页面，但是虚拟内存中的映射关系不会立即释放，只有当用户再次访问这块内存时，才会触发<strong>缺页中断</strong>，重新分配物理页面。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *p=<span class="built_in">malloc</span>(<span class="number">2048</span>);<span class="comment">//这里只是分配了虚拟内存2048，并不占用实际内存。 </span></span><br><span class="line"><span class="built_in">strcpy</span>(p,<span class="string">&quot;123&quot;</span>);     <span class="comment">//分配物理页面，虽只使用了3个字节，但内存还是为它分配了2048字节的物理内存。</span></span><br><span class="line"><span class="built_in">free</span>(p);             <span class="comment">//通过虚拟地址，找到其所对应的物理页面，释放物理页面，释放虚拟内存。</span></span><br></pre></td></tr></table></figure>
<h4 id="内存空洞问题">6.4.3 内存空洞问题</h4>
<p>一个场景，我们知道C++中堆是从下往上的，而堆又是先进先出的，所以当<strong>堆顶申请的物理内存还在使用时中</strong>，如果底下有些内存块被释放了，那么<strong>这些释放的物理内存就不会返回到系统中</strong>，形成了<strong>内存空洞</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//申请11个2K的内存</span></span><br><span class="line">    <span class="keyword">char</span> *p[<span class="number">11</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(p[i],<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    p[<span class="number">10</span>]=(<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">1024</span>*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p[<span class="number">10</span>],<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放前10个2k内存</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pid_t</span> pid=<span class="built_in">getpid</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid:%d\n&quot;</span>,pid);</span><br><span class="line">    <span class="built_in">pause</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上面的代码，如果没有内存空洞，那么此时进程应该只是占用了一个物理页面，剩下堆顶一个2k</p>
<p>但是通过查看<code>memmap</code>命令，我们可以看到<code>1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</code>，说明堆顶的2k内存还在使用，但是底下的10个2k内存已经被释放，但是并没有返回给系统，这就是<strong>内存空洞</strong>。</p>
<h4 id="mmap的内存映射">6.4.4 mmap的内存映射</h4>
<p>最后经过前面基础知识的铺垫，我们再来聊一下<code>mmap</code>的优点：</p>
<ul>
<li><p><strong>减少I/O操作</strong>：<code>mmap</code>将文件映射到内存中，提高了文件的访问速度，不需要每次请求都去读取文件，而是直接从内存中读取</p></li>
<li><p><strong>减少内存拷贝</strong>：<code>mmap</code>将文件映射到内存中，减少了内存拷贝的次数，提高了文件的访问速度</p></li>
<li><p><strong>内存共享</strong>：<code>mmap</code>可以实现内存共享，多个进程可以映射同一个文件，实现进程间的文件共享</p></li>
<li><p><strong>延迟分配</strong>：<code>mmap</code>是按需映射的，只有在访问到文件时才会映射到内存中，减少了内存的占用</p></li>
</ul>
<h3 id="参考">6.5 参考</h3>
<p><a href="https://blog.csdn.net/qq_41687938/article/details/120479067">详解进程的虚拟内存，物理内存，共享内存</a>
<a href="https://zhuanlan.zhihu.com/p/393403828">一文理解虚拟内存、物理内存、内存分配、内存管理</a></p>
<h2 id="七总结">七、总结</h2>
<p>这篇博客应该是本项目最长的一篇了，而HTTP报文的实现也确实是这个项目的主体部分，所以花了比较长的篇幅，还是要好好理解一下</p>
<p>这里需要结合前面<strong>线程池</strong>的相关实现以及<strong>Reactor和Proactor模式</strong>的相关知识，才能更好地理解HTTP类实现的整个流程。还是需要好好消化一下</p>
<p>最后，到这里我们已经实现了HTTP服务器的基础功能了，接下来我们将会实现<strong>日志系统</strong>、<strong>定时器</strong>两个功能，最后再进行<strong>压力测试</strong>，最终完成整个项目的实现。</p>
<p>关于后续的学习，我们先从<strong>定时器</strong>入手，具体内容请看下一篇博客<a href="https://akirazheng.github.io/2024/03/26/WebServer%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8%E6%8E%A7%E5%88%B6%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E6%B4%BB%E6%97%B6%E9%97%B4/">WebServer学习7：定时器控制客户端存活时间</a></p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习9：WebBench压力测试</title>
    <url>/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="一webbench简介">一、WebBench简介</h2>
<p>WebBench是一个在Linux下使用的网站压力测试工具，它使用<code>fork()</code>实现多进程并发，每个进程都是一个客户端，可以模拟多个客户端访问Web服务器，可以用来测试Web服务器的性能，测试Web服务器能够支持多少用户同时访问。</p>
<p>WebBench是由<a href="https://www.lionbridge.com/">Lionbridge</a>开发的开源网站压测工具，除了能测试静态页面外，还可以测试动态页面，如PHP、JSP、ASP等。同时还支持SSL安全网站的测试。</p>
<p><strong>webbench压测原理</strong></p>
<ul>
<li>⾸先在主进程中 fork
出多个⼦进程，每个<strong>子进程</strong>在用户要求的时间内对目标网站(Web)<strong>循环发出实际访问请求</strong></li>
<li>子进程通过<strong>管道(pipe)写端</strong>向父进程传递请求访问完毕后记录到的总信息，⽗进程做最终的统计结果</li>
<li>待时间到后所有子进程结束，<strong>父进程统计</strong>并给用户显示<strong>最后的测试结果</strong>，然后退出</li>
<li>webbench
最多可以模拟<strong>3万</strong>个并发连接去测试⽹站的负载能⼒。</li>
</ul>
<h2 id="二webbench使用">二、WebBench使用</h2>
<p>WebBench的标准测试可以向我们展示服务器的两项内容：<strong>每秒钟的请求数</strong>和<strong>每秒钟的传输速度</strong>。</p>
<h3 id="webbench下载安装">1. WebBench下载安装</h3>
<p><a href="http://home.tiscali.cz/~cz210552/webbench">WebBench的官方主页</a></p>
<p><a href="http://www.ha97.com/webbench-1.5.tar.gz">WebBench工具的下载地址</a></p>
<p>Linux下的下载安装步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://www.ha97.com/webbench-1.5.tar.gz</span><br><span class="line">tar -zxvf webbench-1.5.tar.gz</span><br><span class="line">cd webbench-1.5</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>在本人的WebServer项目中已经将WebBench的源码放在了<code>/MyWebServer/WebBench_test/webbench-1.5</code>目录下，已经编译过了，可以直接使用，不需要重新在官网下载安装。</p>
<h3 id="webbench使用">2. WebBench使用</h3>
<h4 id="启动webserver服务器">2.1 启动WebServer服务器</h4>
<p>首先确保webserver项目已经通过<code>make</code>编译成可执行文件了，然后在<code>/MyWebServer</code>项目的根目录下以关闭日志的形式启动WebServer服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./server -c 0</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/webBench_runserver.png"></p>
<h4 id="使用webbench进行压力测试">2.2 使用WebBench进行压力测试</h4>
<p>启动了服务器后，在<code>/MyWebServer/WebBench_test/webbench-1.5</code>的目录下查看<code>webbench</code>的使用方式和版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./webbench -h</span><br><span class="line">./webbench -V</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/webBench_help.png"></p>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/webBench_version.png"></p>
<p>使用WebBench进行压力测试，例如对本项目中，WebServer服务器的IP地址为<code>http://127.0.0.1:9006/</code>进行压力测试，测试时间为<code>5</code>秒，模拟<code>4000</code>个客户端并发访问。</p>
<p><strong>注意：</strong>根据webBench的源码，输入的URL地址必须以<code>http://</code>开头，且要以<code>/</code>结尾，否则会报错。</p>
<blockquote>
<p>-t 5：表示测试时间为5秒</p>
<p>-c 4000：表示模拟4000个客户端并发访问</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./webbench -c 4000 -t 5 http://127.0.0.1:9006/</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/webBench_test4000.png"></p>
<p><strong>结果分析：</strong></p>
<p>从结果上来看，每秒钟响应请求数：24525
pages/min，每秒钟传输数据量20794612 bytes/sec.</p>
<blockquote>
<p>并发连接总数：4000</p>
<p>服务器压测访问时间：5s</p>
<p>响应请求：24525 pages/min</p>
<p>传输速度：20794612 bytes/sec</p>
<p>共发送82965个请求，所有访问请求都成功了，说明未超负荷</p>
<p>测试结果QPS计算：QPS=N/T=82965/5=16593（请求数量/压测时间），QPS大概为<strong>1.66万</strong></p>
</blockquote>
<p>由于服务器配置只有<code>4核4G</code>，所以在<code>4000</code>个并发连接下，服务器的QPS大概为<strong>1.66万</strong>，破了<strong>万级QPS</strong>，如果服务器配置更高，那么QPS会更高。</p>
<h4 id="webbench受限原因分析">2.3 WebBench受限原因分析</h4>
<p>然而，当我尝试将并发连接数增加到10000时，webBench会报错，提示<code>problems forking worker no.4552</code>，所以我尝试将并发连接数减少到<code>4552</code>是可以正常测试的，但是并发连接数超过<code>4552</code>就会报错。说明肯定有某个地方收到了数量限制。那么我们继续来看一下到底是什么原因导致的。</p>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/webBench_test10000.png"></p>
<p>根据报错提醒可以初步断定是<code>fork()</code>函数的问题，也就是进程数量受Linux系统资源限制，因此测试不到上万的并发连接，最多只能测试到<code>4552</code>个并发连接。</p>
<p><code>fork()</code>函数的限制是由<code>ulimit -a</code>命令查看的，其中<code>max user processes</code>表示用户最大进程数，<code>open files</code>表示用户最大打开文件数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/webBench_testlimit1.png"></p>
<p>可以看到<code>max user processes</code>的值是<code>15183</code>，<code>open files</code>的值是<code>1024</code>，既然<code>max user processes</code>可以达到<code>15183</code>，那么为什么会失败呢？</p>
<p>使用<code>ps -ef | grep server</code>命令查看当前进程数，发现<code>server</code>进程数已经达到了<code>15183</code>，也就是说<code>server</code>进程数已经达到了系统的最大进程数限制，所以无法再创建新的进程了。</p>
<p>使用<code>ulimit -u 2048</code>和<code>ulimit -n 2048</code>修改系统配置后依然无法解决问题，暂时先不深究了，后续有时间再研究。</p>
<h2 id="三总结">三、总结</h2>
<p>实现服务器压测后，可以看到在<code>4000</code>个并发连接下，硬件配置为<code>4核4G</code>的服务器，本项目HTTP服务器的QPS大概为<strong>1.66万</strong>，如果服务器配置更高，那么QPS会更高。但是由于<code>fork()</code>函数的限制，最多只能测试到<code>4552</code>个并发连接，无法测试到上万的并发连接。</p>
<p>完成了WebBench的压力测试后，WebServer项目的学习也就告一段落了，后续会继续准备学习<strong>基于raft的并发KV存储系统</strong>，敬请期待。</p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>WebServer学习8：通用日志系统的设计</title>
    <url>/2024/03/27/WebServer%E5%AD%A6%E4%B9%A08%EF%BC%9A%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="一两种日志系统类型">一、两种日志系统类型</h2>
<h3 id="同步日志系统">1.1 同步日志系统</h3>
<p>同步日志系统是指日志写入和日志输出是同步的，即写入日志后，立即输出到日志文件中。（本项目中配置文件默认为同步日志）</p>
<p>由于同步日志中日志写入函数跟工作函数是串行的，所以涉及到文件IO操作，如果单条日志内容较大时，会导致工作函数阻塞，影响工作效率。</p>
<h3 id="异步日志系统">1.2 异步日志系统</h3>
<p>异步日志系统是指日志写入和日志输出是异步的，即写入日志后，不立即输出到日志文件中，而是先写入到一个<strong>队列</strong>中，然后由另一个线程（日志线程）负责将缓冲区中的日志内容输出到日志文件中。也就是说工作线程和日志线程是并行的，工作线程作为<strong>生产者</strong>只负责将日志信息传到<strong>队列</strong>中就结束了，剩下的操作交由日志线程作为<strong>消费者</strong>全权处理。</p>
<p>由于异步日志中单独开辟了一个线程来处理日志输出，所以这里需要有一些关于线程的基础知识，比如线程的创建、线程的同步（互斥锁&amp;条件变量）、线程的销毁等。具体这部分基础知识可以先学习本人的另一篇博客：<a href="https://akirazheng.github.io/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/">从0开始实现线程池(C++)</a>。</p>
<p>在上面推荐的博客中，我们了解到生产者-消费者模型，异步日志系统就是一个典型的生产者-消费者模型。</p>
<ul>
<li><strong>生产者</strong>：主线程 &amp;&amp;
线程池中的工作线程，将日志信息写入到队列中</li>
<li><strong>消费者</strong>：日志线程，从队列中取出日志信息，输出到日志文件中</li>
</ul>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A08%EF%BC%9A%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/producter-consumer.png"></p>
<h2 id="二单例模式">二、单例模式</h2>
<p>单例模式是一种常见的设计模式，它保证单例类<strong>只有一个实例</strong>，并提供一个全局访问点。</p>
<p>实现思路：</p>
<ul>
<li><strong>私有化</strong>它的<strong>构造函数</strong>，以防止外界创建单例类的对象；</li>
<li>使用<strong>类的私有静态指针变量</strong>指向类的唯一实例，并用一个公有的静态方法获取该实例。</li>
</ul>
<p>实现单例模式有两种方式：</p>
<ul>
<li><strong>饿汉模式</strong>：迫不及待地，在程序启动或单例类被加载的时候就创建单例对象；
<ul>
<li>由于在程序启动时就创建单例对象，所以是线程安全的</li>
</ul></li>
<li><strong>懒汉模式</strong>：懒得理你，只有在第一次调用获取单例对象的方法时才创建单例对象；
<ul>
<li>由于多线程中可能会有多个线程同时<strong>第一次</strong>调用获取单例对象的方法，所以在首次调用中需要确保线程安全</li>
<li>实现线程安全：<strong>加锁</strong>、<strong>双重检查锁</strong>。</li>
</ul></li>
</ul>
<p>关于单例模式的详细内容，可以参考本人的另一篇博客：<a href="https://akirazheng.github.io/2024/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式1：单例模式(C++)</a>。</p>
<p>在单例模式的博客中，我们需要重点关注C++11后，局部静态变量可以实现无锁保证线性安全，所以在实现日志系统时，我们可以使用局部静态变量来实现单例模式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//日志采用单例模式-懒汉模式，需要考虑线程安全</span></span><br><span class="line">    <span class="comment">//C++11之后，静态局部变量的初始化是线程安全的，所以可以直接使用静态局部变量，不需要加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Log *<span class="title">get_instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> Log instance;<span class="comment">//局部静态变量，只会初始化一次</span></span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//单例模式-私有构造函数</span></span><br><span class="line">    <span class="built_in">Log</span>();</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Log</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="三阻塞队列">三、阻塞队列</h2>
<p>如果选择<strong>异步日志系统</strong>，那么就需要使用<strong>阻塞队列</strong>来实现生产者-消费者模型。</p>
<ul>
<li>对于<strong>生产者</strong>来说，写日志到队列中如果队列已经满了，那么直接返回写入失败，不会阻塞（因为生产者是主线程和线程池中的工作线程，不能阻塞，队列满时写入日志就会丢失一条日志，所以队列尽可能设置大一点）</li>
<li>但是对于<strong>消费者</strong>来说，如果队列为空，那么消费者线程就会阻塞，直到队列中有新的数据再继续消费（也就是说队列执行<code>pop</code>操作时，如果队列为空，日志线程就会一直阻塞在<code>pop</code>操作）</li>
</ul>
<p>所以我们实现阻塞队列的思想就是：</p>
<ul>
<li><strong>消费者</strong>读取队列<code>pop</code>操作：如果队列为空，就一直阻塞，直到队列中有新的数据再继续消费</li>
<li><strong>生产者</strong>写入队列<code>push</code>操作（失败）：如果队列满了，直接返回写入失败</li>
<li><strong>生产者</strong>写入队列<code>push</code>操作（成功）：如果队列不为空，就唤醒消费者线程（日志线程），日志线程会结束<code>pop</code>阻塞，从队列中取出日志信息，输出到日志文件中</li>
</ul>
<p>在实现阻塞队列时，我们需要考虑线程安全问题，所以需要使用<strong>互斥锁</strong>和<strong>条件变量</strong>来保证线程安全。</p>
<p>我们前面已经在<strong>线程池</strong>的设计中封装了<strong>互斥锁</strong>和<strong>条件变量</strong>，所以可以直接使用封装后的<code>locker</code>。</p>
<p>在C++中，阻塞队列可以很方便地使用<code>std::queue</code>来实现，在本项目中，我们尝试通过<strong>循环数组</strong>来模拟实现一个<strong>阻塞队列</strong>（先进先出）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">m_back = (m_back + <span class="number">1</span>) % m_max_size; <span class="comment">//循环数组</span></span><br><span class="line">m_front = (m_front + <span class="number">1</span>) % m_max_size; <span class="comment">//循环数组</span></span><br></pre></td></tr></table></figure>
<p>循环数组的概念使我们在<code>push</code>时其实是向右循环移动<strong>队尾指针</strong>并覆盖这个位置上原有的数据；在<code>pop</code>时其实是向右循环移动<strong>队首指针</strong>并覆盖这个位置上原有的数据。（先进先出）</p>
<p>阻塞队列的实现主要包含<strong>入队push</strong>、<strong>出队pop</strong>、<strong>清空clear</strong>三个操作，以及<strong>队列是否为空</strong>和<strong>队列是否已满</strong>的判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 利用循环数组实现队列效果（也可以直接用std::queue）：m_back = (m_back + 1) % m_max_size; </span></span><br><span class="line"><span class="comment">* 为了线程安全，进行队列操作时需要加互斥锁</span></span><br><span class="line"><span class="comment">* 为了实现队列的阻塞功能，需要使用条件变量：</span></span><br><span class="line"><span class="comment">*   阻塞队列中，各个线程生产者负责往阻塞队列中`push`日志消息，消费者线程（日志线程）负责从阻塞队列中`pop`日志消息并写入日志文件</span></span><br><span class="line"><span class="comment">*   因此日志线程的`worker`函数中需要不断地从阻塞队列中取出日志消息并写入日志文件。</span></span><br><span class="line"><span class="comment">*       也就是`worker`函数作为消费者`pop`队列中的数据时，遇到队列为空时需要通过条件变量阻塞等待，</span></span><br><span class="line"><span class="comment">*       直到生产者线程往队列中`push`数据后唤醒日志线程，继续`pop`队列中的数据写进日志文件缓冲区中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BLOCK_QUEUE_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_QUEUE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../lock/locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">block_queue</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数：初始化创建队列</span></span><br><span class="line">    <span class="built_in">block_queue</span>(<span class="keyword">int</span> max_size = <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_size &lt;= <span class="number">0</span>)<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        m_max_size = max_size;</span><br><span class="line">        m_array = <span class="keyword">new</span> T[m_max_size];</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空队列：数组数据内容是可以覆盖的，所以循环数组的清空只需要将队头和队尾指针置为-1即可</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();<span class="comment">//队列操作需要加锁</span></span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_front = <span class="number">-1</span>;</span><br><span class="line">        m_back = <span class="number">-1</span>;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数：释放队列资源</span></span><br><span class="line">    ~<span class="built_in">block_queue</span>()&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_array != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span>[] m_array;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否满</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_size &gt;= m_max_size)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_size == <span class="number">0</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队首</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">front</span><span class="params">(T &amp;value)</span></span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_size == <span class="number">0</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_front];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队尾</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">back</span><span class="params">(T &amp;value)</span></span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_size == <span class="number">0</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        value = m_array[m_back];</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列当前大小</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmpSize = m_size;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmpSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回队列最大容量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmpMaxSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        tmpMaxSize = m_max_size;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tmpMaxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往队列中添加元素：生产者</span></span><br><span class="line">    <span class="comment">//需要唤醒阻塞的消费者线程（日志线程）</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T &amp;item)</span></span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 队列满时，写入日志失败，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(m_size &gt;= m_max_size)&#123;</span><br><span class="line">            m_cond.<span class="built_in">broadcast</span>();<span class="comment">//唤醒日志线程，使其尽快将队列中的日志写入缓冲区，腾出队列空间</span></span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 队列不满时，将日志写入队列，写入成功，返回true</span></span><br><span class="line">        m_back = (m_back + <span class="number">1</span>) % m_max_size;<span class="comment">//循环数组实现队列</span></span><br><span class="line">        m_array[m_back] = item;</span><br><span class="line"></span><br><span class="line">        m_size++;</span><br><span class="line"></span><br><span class="line">        m_cond.<span class="built_in">broadcast</span>();<span class="comment">//唤醒日志线程，通知其队列中有日志需要写入缓冲区</span></span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中取出元素：消费者</span></span><br><span class="line">    <span class="comment">//为了实现阻塞日志队列，消费者线程在队列为空时需要阻塞等待</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item)</span></span>&#123;</span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 队列为空时，阻塞消费线程（日志线程），等待生产者往队列中push数据从而唤醒消费者线程</span></span><br><span class="line">        <span class="keyword">while</span> (m_size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m_cond.<span class="built_in">wait</span>(m_mutex.<span class="built_in">get</span>()))&#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻塞等待失败，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 队列不为空或阻塞结束时，从队列中取出日志，取出成功，返回true</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;<span class="comment">//循环数组实现队列</span></span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中取出元素：消费者(增加阻塞超时处理-虽然本项目中未使用)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T &amp;item, <span class="keyword">int</span> ms_timeout)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">t</span> =</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//超时时间&#123;秒，纳秒&#125;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span> =</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//当前时间</span></span><br><span class="line">        <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);<span class="comment">//获取当前时间</span></span><br><span class="line"></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="comment">//1. 队列为空时，阻塞消费线程（日志线程）一定时间</span></span><br><span class="line">        <span class="keyword">if</span>(m_size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//绝对超时时间：当前时间+超时时间</span></span><br><span class="line">            t.tv_sec = now.tv_sec + ms_timeout / <span class="number">1000</span>;</span><br><span class="line">            t.tv_nsec = (ms_timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等待条件变量：阻塞等待一定时间</span></span><br><span class="line">            <span class="keyword">if</span>(!(m_cond.<span class="built_in">timewait</span>(m_mutex.<span class="built_in">get</span>(), t)))&#123;</span><br><span class="line">                m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻塞等待失败，返回false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 阻塞一段时间后队列任为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (m_size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 队列不为空或阻塞结束时，从队列中取出日志，取出成功，返回true</span></span><br><span class="line">        m_front = (m_front + <span class="number">1</span>) % m_max_size;<span class="comment">//循环数组实现队列</span></span><br><span class="line">        item = m_array[m_front];</span><br><span class="line">        m_size--;</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    locker m_mutex; <span class="comment">//互斥锁：线程安全</span></span><br><span class="line">    cond m_cond;    <span class="comment">//条件变量：实现阻塞队列</span></span><br><span class="line"></span><br><span class="line">    T *m_array;     <span class="comment">//循环数组实现队列</span></span><br><span class="line">    <span class="keyword">int</span> m_size;     <span class="comment">//队列当前容量</span></span><br><span class="line">    <span class="keyword">int</span> m_max_size; <span class="comment">//队列最大容量</span></span><br><span class="line">    <span class="keyword">int</span> m_front;    <span class="comment">//队头</span></span><br><span class="line">    <span class="keyword">int</span> m_back;     <span class="comment">//队尾</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中重点关注<code>pop</code>操作，当判断队列满时，在<code>pop()</code>函数中会调用<code>m_cond.wait(m_mutex.get())</code>函数使日志线程阻塞在当前的<code>pop</code>函数中，等待生产者线程往队列中成功<code>push</code>数据从而唤醒消费者线程（生产者添加数据后，通过<code>m_cond.broadcast()</code>唤醒消费者线程）。</p>
<h2 id="四日志读写的基础api">四、日志读写的基础API</h2>
<h3 id="fputs函数">4.1 fputs函数</h3>
<p>fputs函数是C/C++的一个标准库函数，用于将字符串写入到指定的文件流中。对于打开的文件流，fputs函数会将字符串写入到文件流的当前位置，然后将文件流的当前位置后移，以便下次写入。</p>
<p><img src="/2024/03/27/WebServer%E5%AD%A6%E4%B9%A08%EF%BC%9A%E9%80%9A%E7%94%A8%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1/fputs_fflush.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>str：要写入的字符串（经过自定义格式化处理的日志信息）</li>
<li>stream：文件流指针（日志文件指针）</li>
</ul>
<h3 id="fflush函数">4.2 fflush函数</h3>
<p>fflush函数是C/C++的一个标准库函数，用于刷新流的缓冲区。对于输出流，fflush函数会将缓冲区的内容立即写入到文件中。</p>
<p>fputs函数写入文件时，会先写入到缓冲区，当缓冲区满了或者调用fflush函数时，才会将缓冲区的内容写入到文件中。所以为了避免日志信息丢失，需要在每次写入日志后调用fflush函数，强制将缓冲区的内容写入到文件中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="五日志类实现同步异步">五、日志类实现（同步+异步）</h2>
<h3 id="日志类的初始化">5.1 日志类的初始化</h3>
<p>日志类的初始化可以分为同步初始化和异步初始化，同步和异步的判断由传入的<strong>阻塞队列大小</strong>决定。</p>
<ul>
<li><strong>同步初始化</strong>：阻塞队列大小<strong>为0</strong></li>
<li><strong>异步初始化</strong>：阻塞队列大小<strong>大于0</strong></li>
</ul>
<p>日志初始化的内容为：</p>
<ul>
<li>初始化日志方式（同步/异步），异步初始化需要创建<strong>日志线程</strong>以及<strong>阻塞队列</strong></li>
<li>初始化日志文件路径、日志文件名、日志最大行数、日志缓冲区大小</li>
<li>根据解析的日志文件路径和日志文件名，<strong>创建/打开</strong>日志文件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据同步和异步的不同初始化日志（异步需要初始化阻塞队列、初始化互斥锁、初始化阻塞队列）</span></span><br><span class="line"><span class="comment">//实现参数初始化、根据当前时间创建or打开日志文件</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Log::init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, <span class="keyword">int</span> close_log, <span class="keyword">int</span> log_buf_size, <span class="keyword">int</span> split_lines, <span class="keyword">int</span> max_queue_size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 如果max_queue_size&gt;0，则表示选择的方式是异步写日志，需要初始化阻塞队列、初始化互斥锁、初始化阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span>(max_queue_size &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        m_is_async = <span class="literal">true</span>;<span class="comment">//异步</span></span><br><span class="line">        m_log_queue = <span class="keyword">new</span> block_queue&lt;string&gt;(max_queue_size);<span class="comment">//初始化阻塞队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//异步写日志需要创建单独的日志线程，回调函数为flush_log_thread实现pop阻塞队列中的日志消息并写入日志文件</span></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, flush_log_thread, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 初始化参数，包括缓冲区大小、日志文件行数上限、关闭日志、日志文件名</span></span><br><span class="line">    m_close_log = close_log;</span><br><span class="line">    m_log_buf_size = log_buf_size;</span><br><span class="line">    m_buf = <span class="keyword">new</span> <span class="keyword">char</span>[m_log_buf_size];</span><br><span class="line">    <span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, m_log_buf_size);</span><br><span class="line">    m_split_lines = split_lines;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 根据当前时间创建or打开日志文件</span></span><br><span class="line">    <span class="comment">//3.1 解析文件路径</span></span><br><span class="line">    <span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="keyword">time_t</span> t = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">sys_tm</span> =</span> <span class="built_in">localtime</span>(&amp;t);<span class="comment">//获取当前时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">my_tm</span> =</span> *sys_tm;</span><br><span class="line">    <span class="comment">//解析路径</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *p = <span class="built_in">strrchr</span>(file_name, <span class="string">&#x27;/&#x27;</span>);<span class="comment">//为了判断文件名是否传入了路径</span></span><br><span class="line">    <span class="comment">//格式化解析的  路径_时间_文件名 通过fopen打开或创建文件</span></span><br><span class="line">    <span class="keyword">char</span> log_full_name[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//路径+时间+文件名(存储完整的路径名)</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//a. 未传入路径，直接将 时间+文件名 拼接</span></span><br><span class="line">        <span class="comment">//eg文件名: ServerLog</span></span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%d_%02d_%02d_%s&quot;</span>, my_tm.tm_year+<span class="number">1900</span>, my_tm.tm_mon+<span class="number">1</span>, my_tm.tm_mday, file_name);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//b. 传入了路径，解析路径，将路径+时间+文件名拼接</span></span><br><span class="line">        <span class="comment">//eg文件名: /MyWebServer/ServerLog</span></span><br><span class="line">        <span class="built_in">strcpy</span>(log_name, p + <span class="number">1</span>);<span class="comment">//p + 1取出文件名</span></span><br><span class="line">        <span class="built_in">strncpy</span>(dir_name, file_name, p - file_name + <span class="number">1</span>);<span class="comment">//将dir路径与文件名包含的路径进行拼接</span></span><br><span class="line">        <span class="built_in">snprintf</span>(log_full_name, <span class="number">255</span>, <span class="string">&quot;%s%d_%02d_%02d_%s&quot;</span>, dir_name, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday, log_name);</span><br><span class="line">    &#125;</span><br><span class="line">    m_today = my_tm.tm_mday;<span class="comment">//记录当前日期</span></span><br><span class="line">    <span class="comment">//3.2 打开or创建文件</span></span><br><span class="line">    m_fp = <span class="built_in">fopen</span>(log_full_name, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(m_fp == <span class="literal">NULL</span>)&#123;<span class="comment">//打开失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日志的等级">5.2 日志的等级</h3>
<p>日志的等级分为<strong>INFO</strong>、<strong>DEBUG</strong>、<strong>WARN</strong>、<strong>ERROR</strong>四个等级。</p>
<ul>
<li><strong>INFO</strong>：普通信息，报告系统正常工作的信息，当前执行的流程和收发信息等</li>
<li><strong>DEBUG</strong>：调试信息，报告系统调试信息，用于调试程序，在开发和测试阶段使用</li>
<li><strong>WARN</strong>：警告信息，报告系统警告信息，表明一个可能的问题，不影响程序的正常运行，同样是调试开发时使用</li>
<li><strong>ERROR</strong>和<strong>Fatal</strong>：错误信息，报告系统错误信息，表明一个严重的问题，程序可能无法继续运行</li>
</ul>
<p>日志等级的设置可以通过<strong>宏定义</strong>来实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG(format, ...) <span class="meta-keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(0, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO(format, ...) <span class="meta-keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(1, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARN(format, ...) <span class="meta-keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(2, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR(format, ...) <span class="meta-keyword">if</span>(0 == m_close_log) &#123;Log::get_instance()-&gt;write_log(3, format, ##__VA_ARGS__); Log::get_instance()-&gt;flush();&#125;</span></span><br></pre></td></tr></table></figure>
<p>在生产者通过宏定义调用日志写入函数时，需要传入<strong>日志等级</strong>、<strong>日志内容format</strong>、<strong>可变参数</strong>。调用宏定义日志函数后，依此执行<code>write_log</code>函数实现写入（同步直接<code>fputs</code>写入，异步<code>push</code>进阻塞队列）和<code>flush</code>函数。</p>
<p>其中<strong>日志内容format</strong>和<strong>可变参数</strong>使用<code>vsnprintf</code>函数实现格式化解析输出</p>
<h3 id="日志的写入write_log函数">5.3 日志的写入write_log函数</h3>
<p>日志类中通过<code>write_log</code>函数实现对生产者传入的<strong>日志等级、日志内容</strong>进行格式化解析和封装。</p>
<h4 id="可变参数的格式化解析vsnprintf函数">5.3.1
可变参数的格式化解析<code>vsnprintf</code>函数</h4>
<p>c++中的可变参数格式化解析可以使用<code>vsnprintf</code>函数实现</p>
<p><code>vsnprintf</code>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>str：存储格式化后的字符串（日志主体内容）</li>
<li>size：存储格式化后的字符串的大小（手动分配的）</li>
<li>format：格式化字符串（日志内容），类似printf函数的格式化字符串</li>
<li>ap：可变参数列表</li>
</ul>
<p>如<code>LOG_INFO("%s%d", "listen the port ", m_port);</code>中的<code>"%s%d"</code>代表<code>format</code>，<code>"listen the port "</code>和<code>m_port</code>是可变参数</p>
<h4 id="日志内容格式化输出">5.3.2 日志内容格式化输出</h4>
<p>本项目中的日志按照<strong>日期 时间 日志等级
日志内容</strong>的格式输出，同时日志文件具有<strong>行数限制</strong>和<strong>按天分文件</strong>的特性。因此在写入日志前：</p>
<ul>
<li>需要判断<strong>当前日期是否改变</strong>
<ul>
<li>如果日期改变，需要关闭当前日志文件，重新根据当前日期创建新的日志文件</li>
</ul></li>
<li>需要判断<strong>当前日志行数是否达到上限</strong>
<ul>
<li>如果日志行数达到上限，需要关闭当前日志文件，在<strong>当前日期的文件名基础上加上行数后缀，重新创建新的日志文件</strong></li>
</ul></li>
</ul>
<p>完成格式化内容处理后，再根据<strong>同步/异步</strong>的不同，进行日志内容的写入操作。从这里也可以看出，<strong>异步日志</strong>中，添加到<strong>阻塞队列</strong>中的日志内容是<strong>格式化后的字符串</strong>，所以在日志线程中取出后直接调用<code>fputs()</code>写入到日志文件中即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//write_log由define宏定义的宏函数自动调用的</span></span><br><span class="line"><span class="comment">//生产者向阻塞队列中写入日志消息，解析日志消息类型，并将缓冲区强制刷新到日志文件</span></span><br><span class="line"><span class="comment">//传入可变参数列表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Log::write_log</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//解析选择的日志级别（level）</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//存储日志级别</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (level)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[debug]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[warn]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[erro]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">strcpy</span>(s, <span class="string">&quot;[info]:&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前时间，用于判断是否到第二天了，需要创建新的日志文件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span> =</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">gettimeofday</span>(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">time_t</span> t = now.tv_sec;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">sys_tm</span> =</span> <span class="built_in">localtime</span>(&amp;t);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">my_tm</span> =</span> *sys_tm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 写入日志前的处理：更新日志文件名</span></span><br><span class="line">    <span class="comment">//1.1 判断当前行数是否达到最大行数，或者是否到了第二天</span></span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    m_count++;<span class="comment">//行数+1</span></span><br><span class="line">    <span class="keyword">if</span> (m_today != my_tm.tm_mday || m_count % m_split_lines == <span class="number">0</span>) <span class="comment">//everyday log</span></span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span> new_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fflush</span>(m_fp);<span class="comment">//先强制将缓冲区的内容写入文件，避免日志丢失</span></span><br><span class="line">        <span class="built_in">fclose</span>(m_fp);</span><br><span class="line">        <span class="keyword">char</span> tail[<span class="number">16</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//时间戳</span></span><br><span class="line">       </span><br><span class="line">        <span class="built_in">snprintf</span>(tail, <span class="number">16</span>, <span class="string">&quot;%d_%02d_%02d_&quot;</span>, my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//a. 到第二天了，需要创建新的日志文件</span></span><br><span class="line">        <span class="keyword">if</span> (m_today != my_tm.tm_mday)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s&quot;</span>, dir_name, tail, log_name);</span><br><span class="line">            m_today = my_tm.tm_mday;</span><br><span class="line">            m_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//b. 行数达到最大行数，需要创建新的日志文件</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(new_log, <span class="number">255</span>, <span class="string">&quot;%s%s%s.%lld&quot;</span>, dir_name, tail, log_name, m_count / m_split_lines);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建打开新的日志文件</span></span><br><span class="line">        m_fp = <span class="built_in">fopen</span>(new_log, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 解析日志消息内容</span></span><br><span class="line">    <span class="comment">//2.1 格式化解析可变参数列表</span></span><br><span class="line">    va_list valst;</span><br><span class="line">    <span class="built_in">va_start</span>(valst, format);</span><br><span class="line"></span><br><span class="line">    string log_str;</span><br><span class="line">    m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">//写入的具体时间内容格式</span></span><br><span class="line">    <span class="comment">//eg: 2024-03-11 17:46:21.755040 [info]:</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">snprintf</span>(m_buf, <span class="number">48</span>, <span class="string">&quot;%d-%02d-%02d %02d:%02d:%02d.%06ld %s &quot;</span>,</span><br><span class="line">                     my_tm.tm_year + <span class="number">1900</span>, my_tm.tm_mon + <span class="number">1</span>, my_tm.tm_mday,</span><br><span class="line">                     my_tm.tm_hour, my_tm.tm_min, my_tm.tm_sec, now.tv_usec, s);</span><br><span class="line">    <span class="comment">//写入的具体内容：可变参数列表的内容</span></span><br><span class="line">    <span class="comment">//eg: 2024-03-11 17:46:21.755040 [info]: hello world</span></span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">vsnprintf</span>(m_buf + n, m_log_buf_size - n - <span class="number">1</span>, format, valst);</span><br><span class="line">    m_buf[n + m] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    m_buf[n + m + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    log_str = m_buf;</span><br><span class="line"></span><br><span class="line">    m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 将日志消息写入阻塞队列（异步）or直接写入日志文件（同步）</span></span><br><span class="line">    <span class="keyword">if</span> (m_is_async &amp;&amp; !m_log_queue-&gt;<span class="built_in">full</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//异步写日志，将日志消息写入阻塞队列</span></span><br><span class="line">        m_log_queue-&gt;<span class="built_in">push</span>(log_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//同步写日志，直接将日志消息写入文件</span></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">fputs</span>(log_str.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(valst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日志的刷新flush函数">5.4 日志的刷新flush函数</h3>
<p>日志类中通过<code>flush</code>函数实现对日志文件的刷新操作，即将缓冲区的内容强制写入到文件中。保证有新的日志到达后，先将当前缓冲区的内容写入到文件中，避免日志丢失。</p>
<h3 id="异步日志中线程的实现">5.5 异步日志中线程的实现</h3>
<p>异步日志在初始化时创建了一个<strong>日志线程</strong>，该线程的工作函数是<code>flush_log_thread</code>，主要负责从阻塞队列中取出日志消息并写入到日志文件中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步写日志需要创建单独的日志线程，回调函数为flush_log_thread实现pop阻塞队列中的日志消息并写入日志文件</span></span><br><span class="line"><span class="keyword">pthread_t</span> tid;</span><br><span class="line"><span class="built_in">pthread_create</span>(&amp;tid, <span class="literal">NULL</span>, flush_log_thread, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p><strong>关于<code>flush_log_thread</code>函数的实现</strong></p>
<p>异步日志的工作线程函数<code>flush_log_thread</code>是一个静态函数，会调用日志类的<code>async_write_log</code>函数，实现从阻塞队列中取出日志消息并写入到日志文件中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步方式中 日志线程的工作函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">flush_log_thread</span><span class="params">(<span class="keyword">void</span> *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Log::<span class="built_in">get_instance</span>()-&gt;<span class="built_in">async_write_log</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关于<code>async_write_log</code>函数的实现</strong></p>
<p>异步日志的工作线程函数中，<code>async_write_log</code>会不断地从阻塞队列中取出日志消息并写入到日志文件中。根据前面实现的<strong>阻塞队列</strong>的特性，如果队列为空，那么日志线程会阻塞在<code>pop</code>操作中</p>
<p>所以日志工作线程的<code>while</code>循环执行<code>pop</code>操作时，如果队列为空，会一直阻塞在<code>while</code>语句中，直到队列中生产者添加新的日志消息，唤醒日志线程，继续<code>pop</code>操作，并进入<code>while</code>循环里面的执行语句中</p>
<p>此时获得的日志字符串已经是格式化过的了（阻塞队列中的消息全是格式化后再由生产者<code>push</code>进去的），所以直接调用<code>fputs</code>函数写入到日志文件中即可。</p>
<p>当阻塞队列中的日志消息全部写入到日志文件中后，日志线程会继续阻塞在<code>pop</code>操作中，等待生产者线程继续往队列中<code>push</code>新的日志消息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异步日志写入(从阻塞队列中取出日志消息并写入日志文件)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">async_write_log</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string single_log;<span class="comment">//存储从pop中取出的单条日志</span></span><br><span class="line">    <span class="keyword">while</span> (m_log_queue-&gt;<span class="built_in">pop</span>(single_log))&#123;</span><br><span class="line">        <span class="comment">//结束消费者阻塞后，将日志写入文件缓冲区（还需要配合fflush将缓冲区内容写入文件）</span></span><br><span class="line">        m_mutex.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="built_in">fputs</span>(single_log.<span class="built_in">c_str</span>(), m_fp);</span><br><span class="line">        m_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六总结">六、总结</h2>
<p>至此我们已经完成了一个通用的日志系统的设计和实现，包含了<strong>同步日志</strong>和<strong>异步日志</strong>两种方式。相当于造了个轮子，以后可以直接拿来使用。</p>
<p>本文关键的知识点为<strong>线程安全</strong>、<strong>生产者-消费者模型</strong>、<strong>单例模式</strong>、<strong>阻塞队列</strong>、<strong>日志格式化解析和封装</strong>等。</p>
<p>到目前为止，WebServer的功能基本实现了，通过<code>Makefile</code>文件执行<code>make</code>命令编译生成可执行文件<code>server</code>，通过<code>./server</code>命令运行服务器，即可在浏览器中访问<code>http://localhost:9006</code>查看效果。同时完整项目在<a href="https://github.com/AkiraZheng/MyWebServer">GitHub</a>上。</p>
<p>在WebServer项目的实现中，我们最后还需要通过Web性能压测工具<code>WebBench</code>对服务器进行压力测试，以验证服务器的性能和稳定性。具体压测的内容和结果可以参考本人的另一篇博客：<a href="https://akirazheng.github.io/2024/03/27/WebServer%E5%AD%A6%E4%B9%A09%EF%BC%9AWebBench%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/">WebServer项目实战9：WebBench压力测试</a>。</p>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>分布式Kafka学习</title>
    <url>/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="一消息队列">一、消息队列</h1>
<p>消息队列是<strong>传递消息的容器（队列）</strong>，自然遵循<strong>先进先出</strong>的原则。</p>
<p>消息队列的<strong>三大主要作用</strong>是</p>
<ul>
<li><strong>解耦</strong>：<strong>无依赖</strong>的业务间解耦（不需要给上一个任务返回结果），因此可以处理统一条消息的多个任务
<img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/MQ_decouple.png" width="40%"></li>
<li><strong>异步</strong>：耗时任务提交给消息队列后，立即返回，不阻塞，允许水平扩展多个机器，轮询处理结果（还是需要返回结果的）</li>
<li><strong>削峰填谷</strong>：流量控制，特别是在<strong>秒杀场景</strong>避免瞬间大量请求导致系统崩溃</li>
</ul>
<p>下面将介绍一下保证消息队列性能的一些设计</p>
<h2 id="消息可靠性保证消息不丢失">1. 消息可靠性：保证消息不丢失</h2>
<p><strong>1）三种消息丢失场景</strong></p>
<p>在以下三个环节有可能发生消息丢失：</p>
<ul>
<li><strong>生产阶段</strong>：生产者发送消息时，<strong>网络中断</strong>等原因导致消息丢失</li>
<li><strong>存储阶段（到达中间件broken）</strong>：消息队列中间件接收到消息后，<strong>存储阶段</strong>可能导致消息丢失</li>
<li><strong>消费阶段</strong>：消费者消费消息进行处理后，未成功<strong>提交偏移量</strong>就会导致消息丢失</li>
</ul>
<p><strong>2）保证消息不丢失的方法</strong></p>
<p>针对以上三种场景，可以采取以下措施：</p>
<ul>
<li><strong>生产阶段</strong>：需要考虑网络中断问题
<ul>
<li>可以采用<strong>客户端重试机制</strong></li>
<li><strong>ACK消息确认机制</strong>（即<strong>生产者发送消息后</strong>，<strong>消息队列返回确认消息</strong>，生产者<strong>再发送下一条消息</strong>）来保证消息<strong>at
least once</strong>发送
<ul>
<li>Kafka生产侧有<strong>3种</strong>返回acks的配置方式：<strong>0</strong>（不返回）、<strong>1（也是默认的）</strong>（只需要leader确认持久化后的ACK，不等待所有副本的同步）、<strong>all或-1</strong>（需要leader及所有ISR副本都同步后返回ACK）</li>
</ul></li>
</ul></li>
<li><strong>存储阶段</strong>：
<ul>
<li>消息队列中间件可以采用<strong>MySQL数据库持久化</strong>的方式，将消息<strong>持久化到磁盘</strong></li>
<li>同时配合生产阶段，当确认持久化完成后，再返回ACK确认消息</li>
</ul></li>
<li><strong>消费阶段</strong>：
<ul>
<li>消费者消费<strong>消息后</strong>，<strong>需要提交偏移量</strong>，以保证消息<strong>至少被处理一次</strong>
<ul>
<li>说明：这样就算消费者宕机，重启后也可以再拉取消息消费</li>
</ul></li>
</ul></li>
</ul>
<p>三种阶段的消息丢失场景示意图：</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/messageLost.png" width="60%"></p>
<h2 id="消息顺序性保证消息有序">2. 消息顺序性：保证消息有序</h2>
<p>有序指的是<strong>消息的消费顺序</strong>和<strong>发送的顺序</strong>一致，即<strong>先发送的消息先被消费</strong></p>
<p>Kafka的<strong>一个topic主题</strong>由<strong>很多不同的partition</strong>存储，<strong>在一个Partition里是有序的</strong>，所以可以在<strong>Partition的路由</strong>上实现有序</p>
<p>在实际中，我们可以根据<strong>不同场景有序性的需求</strong>，来进行路由设计</p>
<ul>
<li><strong>业务分区</strong>：不同用户的操作必须有序
<ul>
<li><strong>每个细化的子业务</strong>有一个单独的key分到<strong>某个Partition</strong></li>
<li>扩展性低，当某个业务增长快的话，会加重那个Partition的压力</li>
</ul></li>
<li><strong>客户分区</strong>：<strong>同一个用户</strong>的操作必须有序
<ul>
<li><strong>user_id%n</strong>作为路由规则，分到<strong>某个Partition</strong>
<ul>
<li>缺点：<strong>扩展新Partition分区后需要全部迁移数据</strong></li>
</ul></li>
<li>用<strong>hash(id)%哈希槽</strong>（每个Partition分配几个负责的节点），通过循环哈希环减少迁移压力（通过分配一些槽给新Partition，这样只需要将这些槽进行迁移）</li>
</ul></li>
</ul>
<p>比如在交易场景下，某个用户账户余额为0，我们要保证用户先充值1000元再转账2000元的可实现性，这个时候就要求必须按顺序执行这个用户的多条消息，否则在充值1000元还没处理完的情况下，转账2000元就会出现余额不足</p>
<ul>
<li>解决方法：要保证同一个用户的多条消息必须有序，通过<strong>user_id路由同一个用户永远打到一个Partition中</strong></li>
</ul>
<p>路由方式示意图：</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/orderPartition.png" width="60%"></p>
<h2 id="消息幂等性保证消息不重复">3. 消息幂等性：保证消息不重复</h2>
<p>消息幂等的方式一般就是保证<strong>对外接口的幂等性</strong>，即<strong>多次调用接口返回的结果是一样的</strong>，在数学上表示为<strong>f(f(x))=f(x)，比如绝对值函数abs(abs(x))=abs(x)</strong></p>
<p><strong>1）幂等性的场景</strong></p>
<p>首先要让消息不重复同样需要控制三个阶段：</p>
<ul>
<li><strong>生产阶段</strong>：<strong>由于网络抖动和Web的重试机制导致重复发送</strong>，一个相同的请求总有概率重放到Kafka中，所以需要引入幂等式</li>
<li><strong>存储阶段</strong>：天然不重复存储</li>
<li><strong>消费阶段</strong>：<strong>消费者消费后，未及时提交偏移量</strong>，重启后再次拉取消费</li>
</ul>
<p><strong>2）CRUD接口的幂等性</strong></p>
<p>后端操作中的接口一般就是CRUD操作，而这4种接口的幂等性如下：</p>
<table>
<colgroup>
<col style="width: 62%">
<col style="width: 37%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;">接口类型</th>
<th>幂等性描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>新增插入</strong></td>
<td><strong>必须保证幂等性</strong>，因为<strong>重复插入</strong>会导致<strong>数据重复</strong></td>
</tr>
<tr>
<td style="text-align: center;"><strong>删除</strong></td>
<td><strong>不需要保证幂等性</strong>，因为<strong>重复删除</strong>的最终结果都是删掉这条数据</td>
</tr>
<tr>
<td style="text-align: center;"><strong>更新</strong></td>
<td>将字段确定性的更新，<strong>不需要保证幂等性</strong>，因为<strong>重复更新</strong>的最终结果都是一样的；但是如果是<strong>非确定性更新（如自增）</strong>，则<strong>需要保证幂等性</strong></td>
</tr>
<tr>
<td style="text-align: center;"><strong>查询</strong></td>
<td><strong>不需要保证幂等性</strong>，因为<strong>事务性操作重复查询</strong>的结果都是一样的</td>
</tr>
</tbody>
</table>
<p>综上所述，<strong>增（数据库唯一ID）</strong>、<strong>自增性的改操作（乐观锁version）</strong>都要保证幂等</p>
<p><strong>3）幂等性的实现</strong></p>
<p>在解决消息重复的问题上，一般有以下几种方式：</p>
<ul>
<li><strong>唯一ID（最常用，适用于新增插入）</strong>：<strong>服务端</strong>采用分布式ID（UUID/雪花算法）生成唯一ID返回给客户端，字段中ID字段为有唯一性约束
<ul>
<li>为什么要用分布式ID？UUID/雪花算法分库下<strong>保证全局唯一</strong>，而自增不能保证</li>
<li>为什么是服务端生成？因为<strong>客户端生成</strong>的话，不同客户端生成的ID可能会重复</li>
<li>服务的生成的唯一ID什么时候能起幂等作用？
<ul>
<li>数据网络抖动的多次发送主要是由前端去控制的，全局唯一ID的后端接口幂等其实是为了保证当用户觉得该条消息被消费很久没得到返回，<strong>会重新根据前面拿过的全局唯一ID再次请求</strong>，此时如果服务端发现该ID已经存在则不会再插入</li>
</ul></li>
</ul></li>
<li><strong>防重表（适用于新增插入）</strong>：<strong>允许ID重复</strong>，但是加了一个<strong>唯一索引字段unique_key用于隐性保证唯一性</strong></li>
<li><strong>乐观锁（适用于更新）</strong>：<strong>version字段</strong>作为<strong>乐观锁</strong>，每次更新时<strong>version+1</strong>，这样即使重复更新也不会影响数据
<ul>
<li>step1：客户端查询version</li>
<li>step2：客户端发起更新请求，带上version</li>
<li>step3：服务端校验version，如果一致则更新，否则返回错误</li>
</ul></li>
<li><strong>Token（同时适用于增删更）</strong>：<strong>Token</strong>是<strong>一次性的</strong>，<strong>删除后</strong>就<strong>不能再次删除</strong>，因此<strong>重复删除</strong>不会有影响
<img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/token.png" width="60%"></li>
</ul>
<p><strong>4）redis和数据库的幂等性</strong></p>
<ul>
<li><strong>redis</strong>
<ul>
<li><strong>唯一ID</strong>：每个消息分配一个唯一ID</li>
<li>Redis Set：将已消费的消息ID存入Redis
Set中，每次消费前先判断是否在Set中</li>
<li><strong>原子操作</strong>：SISMEMBER和SADD是原子操作，保证了幂等性</li>
</ul></li>
<li><strong>数据库</strong>
<ul>
<li><strong>唯一ID约束</strong>：ID字段设置唯一约束</li>
<li><strong>INSERT IGNORE</strong>：插入时使用INSERT
IGNORE，如果ID重复则不插入</li>
<li><strong>事务</strong>：使用事务保证原子性</li>
</ul></li>
<li><strong>Redis和MySQL结合实现幂等</strong>：在MySQL唯一ID前面加一层Redis
Set先过滤重复的UID</li>
</ul>
<h2 id="消息的积压处理">4. 消息的积压处理</h2>
<p><strong>1）消息积压的原因</strong></p>
<ul>
<li><strong>消费者处理能力不足</strong>：消费者处理消息的速度不够快，导致消息积压</li>
<li><strong>消费者线程阻塞</strong></li>
<li><strong>消费者宕机</strong></li>
</ul>
<p><strong>2）消息积压的解决方案</strong></p>
<ul>
<li><strong>扩容提高消费速率</strong>：增加消费者进行水平扩容
<ul>
<li>由于要保持<strong>消息有序性</strong>，因此一个<strong>Partition只能有一个消费者</strong>，所以水平扩容也是有要求的，当消费者与Partition持平时，还要扩容Partition</li>
</ul></li>
<li><strong>服务主动降级</strong>：紧急情况下可以先<strong>取消一些非核心业务或流程</strong>，如阿里通过orange开关取消某个非核心业务链路</li>
</ul>
<h1 id="二kafka">二、Kafka</h1>
<h2 id="kafka简介">1. Kafka简介</h2>
<p>Kafka是<strong>分布式消息队列</strong>，是<strong>高吞吐量</strong>的分布式<strong>发布订阅</strong>消息系统，具有<strong>持久性（zookeeper提供的主从管理）</strong>、<strong>高性能（10w/s级别）</strong>、<strong>高可用性（健壮的副本Partition）</strong>、<strong>最终一致性（主从一致）</strong>等特点。</p>
<p>单机吞吐支持<strong>10W/s级别</strong>，与RocketMQ相比，其<strong>不具备消息回溯能力</strong>且支持主题数在<strong>百级</strong>（RocketMQ支持<strong>千级</strong>）。</p>
<h2 id="kafka架构">2. Kafka架构</h2>
<p>Kafka的架构主要包括<strong>生产者</strong>、<strong>消费者</strong>、<strong>broker（单机）</strong>、<strong>topic（消息发布订阅模式）</strong>、<strong>partition（一个topic的Partition可以分布在多台机器上-主从一致）</strong>、<strong>replica</strong>、<strong>leader</strong>、<strong>follower</strong>等概念。</p>
<p>除此以外，还有<strong>zookeeper</strong>用于<strong>管理集群broker</strong>，它相当于管家，可以<strong>选举leader、follow保存副本</strong>，保证数据可用性（可以用于broken的注册、发现与选举）</p>
<p>总的架构如下：</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/Kafka_structure.png" width="80%"></p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/Kafka_structure2.png" width="80%"></p>
<p>Kafka的设计理念可分解为以下主要部分：</p>
<p><strong>1）MQ数据堆积</strong></p>
<p>MQ中数据堆积本质是消费者消费能力差，可以通过<strong>增加消费者线程</strong>，也就是多消费者模式，同理也可以添加多生产者提高吞吐量</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/multiConsumers.jpg" width="60%"></p>
<p><strong>2）多生产者和多消费者竞争MQ</strong></p>
<p><strong>分Topic</strong></p>
<p>将消息队列根据<strong>不同主题Topic</strong>分为<strong>多个MQ</strong>减少冲突等待</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/multiTopic.jpg" width="60%"></p>
<p><strong>Topic的Partition分区</strong></p>
<p>单个Topic中还可以再细分成<strong>多个Partition分区</strong>，每个消费者对应一个Partition分区，从而<strong>降低多线程竞争</strong></p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/multiPartition.jpg" width="60%"></p>
<p><strong>3）高性能</strong></p>
<p>将多个Partition分布在不同机器上，每个机器称为<strong>broker</strong></p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/multiBroker.jpg" width="60%"></p>
<p><strong>4）高可用</strong></p>
<p>单个broker如果宕机了，该部分的功能将无法继续进行，因此可以设计<strong>leader-follower</strong>的集群方式</p>
<p><strong>leader</strong>负责读写数据，<strong>follower</strong>负责复制数据，当<strong>leader</strong>宕机时可以从<strong>follower</strong>中选举出新的<strong>leader</strong></p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/leader-follower.jpg" width="60%"></p>
<p><strong>5）持久化</strong></p>
<p>数据放在内存中有宕机丢失的风险，因此数据还应该具备<strong>持久化到磁盘</strong>的能力</p>
<p>同时为了防止磁盘溢出，还应该设置<strong>过期时间</strong></p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/savetodisk.jpg" width="60%"></p>
<h2 id="kafka的优缺点">3. Kafka的优缺点</h2>
<h3 id="优点">3.1 优点</h3>
<ul>
<li><strong>高吞吐量</strong>：支持<strong>10W/s级别</strong>的消息堆积吞吐量（RocketMQ一样）</li>
<li><strong>高可用性</strong>：通过<strong>leader-follower</strong>机制保证数据的可用性</li>
<li><strong>持久化</strong>：支持数据持久化到磁盘</li>
<li><strong>分布式</strong>：支持<strong>多broker</strong>、<strong>多partition</strong>、<strong>多topic</strong>的分布式架构</li>
<li><strong>水平扩展</strong>：支持<strong>水平扩展</strong>，可以通过增加broker、partition等方式提高吞吐量</li>
<li><strong>支持批量处理</strong>（RocketMQ不支持）</li>
<li><strong>支持消息顺序</strong>：在<strong>一个队列中</strong>可靠的<strong>先进先出</strong>（FIFO）和严格的顺序传递；支持拉（pull）和推（push）两种消息模式；</li>
</ul>
<h3 id="缺点">3.2 缺点</h3>
<ul>
<li><strong>不支持消息回溯</strong>：Kafka不支持消息回溯，即<strong>消费者消费过的消息无法再次消费，也就不支持重试</strong></li>
<li>使用短轮询，实时性取决于轮询频率</li>
</ul>
<h2 id="kafka高性能的原因">4. Kafka高性能的原因</h2>
<p>Kafka高性能的原因有：<strong>零拷贝</strong>、<strong>批量操作</strong>、<strong>顺序写</strong>、数据压缩、多层次、页缓存</p>
<h3 id="零拷贝">4.1 零拷贝*</h3>
<p>零拷贝：优化<strong>网络数据</strong>从本地到网卡发送的拷贝次数</p>
<p>操作：<strong>将数据直接从内核空间的磁盘文件直接拷贝到网卡中，不经过用户态</strong></p>
<p>优点：<strong>系统调用从2次变成1次、拷贝由4次变成2次</strong></p>
<p>原来的网卡数据发送流程：</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/copy.png" width="60%"></p>
<p>零拷贝的数据发送流程：</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/zeroCopy.png" width="60%"></p>
<h3 id="批量操作">4.2 批量操作*</h3>
<p>批量操作：一次性拉取多条消息进行消费</p>
<p>方法包括：累积到<strong>一定时间ms</strong>就操作、累积到<strong>一定batchSize数据量</strong>就操作、累积到<strong>一定缓存大小</strong>就操作</p>
<p>优点：节省宽带</p>
<p>缺点：造成延时</p>
<h3 id="顺序写">4.3 顺序写*</h3>
<p>顺序写：指磁盘的顺序写，<strong>使磁盘写性能更接近内存性能</strong></p>
<p>操作：Kafka写入数据其实就是添加到每个Partition的末端（也就是磁盘文件）</p>
<p>原因：非顺序写磁盘需要转动寻址、对齐扇区，速度慢</p>
<h3 id="数据压缩">4.4 数据压缩</h3>
<p>数据压缩：<strong>生产者/broken压缩-消费者解压数据</strong></p>
<p>优点：降低网络需求和存储压力</p>
<h3 id="多层次">4.5 多层次</h3>
<p>多层次：Kafka利用<strong>分治Partition主从思想</strong>，将顺序IO存储压力进行<strong>切分</strong></p>
<p><code>Topic=n*Partition=m*broken</code>，Kafka返回路由信息，使其按规则访问对应的Partition，每个Partition分为3个文件作为索引文件实现快速查找</p>
<p>分治思想：一个业务写入一个topic <strong>---&gt;</strong>
一个topic具有多个切片Partition <strong>---&gt;</strong>
一个Partition有多个Broken用作数据主从存储</p>
<p><img src="/2024/08/05/%E5%88%86%E5%B8%83%E5%BC%8FKafka%E5%AD%A6%E4%B9%A0/multiLevel.png" width="60%"></p>
<h3 id="页缓存">4.6 页缓存</h3>
<p>页缓存：消息进入Kafka后线写入<strong>内存缓存PageCache</strong>，<strong>后面再由操作系统刷入磁盘</strong>（肯定需要刷入磁盘防止电脑断电、重启导致数据丢失）</p>
<p>优点：当查询的数据打中PageCache时可以直接从PageCache中获取数据，提升效率（未完待续：需要了解什么情况下会去命中PageCache）</p>
<p><strong>从PageCache到磁盘同步固化机制：</strong></p>
<ul>
<li>1）内存空间&lt;=阈值后，PageCache输入磁盘并被释放</li>
<li>2）脏页在内存驻留一定时间后
<ul>
<li>脏页：当消息被写入PageCache后，由于不是及时更新到磁盘的，所以此时页缓存数据跟磁盘不一致，被称为脏页</li>
<li>主动调用刷脏方法：<strong>sync或fsync方法</strong>（系统调用）</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
  </entry>
  <entry>
    <title>动手学深度学习01</title>
    <url>/2022/04/17/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A001/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>本章内容为<strong>动手学深度学习-预备知识</strong>章节</p>
</blockquote>
<blockquote>
<p>本章内容源自d2l代码包中的<code>chapter_preliminaries</code>文件夹</p>
</blockquote>
<blockquote>
<p>课程源自 <a href="https://course.d2l.ai/zh-v2/">动手学深度学习在线课程</a></p>
</blockquote>
<blockquote>
<p>代码运行在Google的<a href="https://colab.research.google.com/">Colab</a>平台中</p>
</blockquote>
<h1 id="数据操作">数据操作</h1>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.arange(15)</span><br><span class="line">print(x)</span><br><span class="line">print(x.shape)</span><br><span class="line">print(x.numel())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = x.reshape(3,5)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(torch.ones((2,3,4)))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 二维数据</span><br><span class="line">y = torch.tensor([[2,1,4,3], [1,2,3,4], [4,3,2,1]])</span><br><span class="line">print(y)</span><br><span class="line">print(y.size())</span><br><span class="line"></span><br><span class="line"># 三维数据</span><br><span class="line">y = torch.tensor([[[2,1,4,3], [1,2,3,4], [4,3,2,1]]])</span><br><span class="line">print(y)</span><br><span class="line">print(y.size())</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.arange(12, dtype=torch.float32).reshape((3,4))  # 【3,4】</span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">y = torch.tensor([[2.0,1,4,3], [1,2,3,4], [4,3,2,1]]) # 【3,4】</span><br><span class="line">torch.cat((x, y), dim=0), torch.cat((x, y), dim=1) # dim=0,按行合并两个矩阵; dim=1, 按列合并两个矩阵</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.sum()</span><br></pre></td></tr></table></figure>
<h2 id="广播机制--同一纬度不同大小矩阵的相加机制">广播机制--同一纬度不同大小矩阵的相加机制</h2>
<p>如对于一个二维的（3,1）大小矩阵跟（1,2）大小矩阵</p>
<p>会把（3,1）扩展出相同的一列变为（3,2）</p>
<p>同理（1,2）扩展为（3,2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.arange(3).reshape((3,1))</span><br><span class="line">y = torch.arange(2).reshape((1,2))</span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(x+y)</span><br></pre></td></tr></table></figure>
<h2 id="python矩阵拆分">Python矩阵拆分</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.arange(12).reshape((3,4))</span><br><span class="line">print(x)</span><br><span class="line">print(x[-1]) # 取出倒数第一行数据</span><br><span class="line">print(x[:,-1]) # 取出倒数第一列数据</span><br><span class="line">print(x[0:2]) # 选取前两行</span><br><span class="line">print(x[2,3])</span><br></pre></td></tr></table></figure>
<h2 id="内存分配问题">内存分配问题</h2>
<p>id()相当于c语言的指针</p>
<p>元素赋值不改变地址，整个数组赋值会改变地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.arange(12).reshape((3,4))</span><br><span class="line">y = torch.arange(12).reshape((3,4))</span><br><span class="line"></span><br><span class="line">before = id(y)</span><br><span class="line">y[:] = y+x</span><br><span class="line">print(id(y)==before)</span><br><span class="line">y = y-x          # 对y进行操作会改变地址内容，产生了一个新的y</span><br><span class="line">print(id(y)==before)</span><br><span class="line"></span><br><span class="line">z = torch.zeros_like(y)</span><br><span class="line">print(&#x27;id(z):&#x27;, id(z))</span><br><span class="line">z[:]= x + y       # 对z进行操作不会改变地址内容，是对元素进行赋值</span><br><span class="line">print(&#x27;id(z):&#x27;, id(z))</span><br></pre></td></tr></table></figure>
<h2 id="更换张量">更换张量</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = x.numpy()     # 转换为Numpy的张量</span><br><span class="line">B = torch.tensor(A)  # 转换为torch的张量</span><br><span class="line">print(type(A), type(B))</span><br><span class="line"></span><br><span class="line">a = torch.tensor([3.5])</span><br><span class="line">print(a, a.item(), float(a), int(a)) # 转换为item标量</span><br></pre></td></tr></table></figure>
<h1 id="数据预处理">数据预处理</h1>
<h2 id="创建写入csv文件----os">创建、写入CSV文件 -- os</h2>
<ul>
<li><p>创建文件夹：<code>os.makedirs()</code></p></li>
<li><p>创建csv文件：<code>os.path.join()</code></p></li>
<li><p>写入内容：</p>
<p><code>with open() as f:</code></p>
<p><code>f.write()</code></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.makedirs(os.path.join(&#x27;..&#x27;, &#x27;data&#x27;), exist_ok=True)</span><br><span class="line">data_file = os.path.join(&#x27;..&#x27;, &#x27;data&#x27;, &#x27;house_tiny.csv&#x27;)</span><br><span class="line">with open(data_file, &#x27;w&#x27;) as f:</span><br><span class="line">  f.write(&#x27;NumRooma,Alley,Price\n&#x27;) # 列名</span><br><span class="line">  f.write(&#x27;NA,Pave,127500\n&#x27;)</span><br><span class="line">  f.write(&#x27;2,NA,106000\n&#x27;)</span><br><span class="line">  f.write(&#x27;4,NA,178100\n&#x27;)</span><br><span class="line">  f.write(&#x27;NA,NA,140000\n&#x27;)</span><br><span class="line"></span><br><span class="line">print(data_file)</span><br></pre></td></tr></table></figure>
<h2 id="加载csv原数据集----pandas">加载csv原数据集 -- pandas</h2>
<ul>
<li><p>read读入文件：</p>
<p><code>pd.read_csv()</code></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data = pd.read_csv(data_file)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>
<h2 id="处理缺失数据----.fillna插值">处理缺失数据 --
.fillna（插值）</h2>
<p>常用插值或删除处理缺失数据</p>
<ul>
<li><p>取csv表格的某一行或列：</p>
<p><code>.iloc[ ]</code></p></li>
<li><p>字符串缺失</p>
<p>字符串缺失的可以将字符串分为多个类别，用1-0表示</p>
<p><code>.get_dummies()</code></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input, output = data.iloc[:, 0:2], data.iloc[:, 2]</span><br><span class="line">input = input.fillna(input.mean()) # 用均值插值</span><br><span class="line">input</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">input = pd.get_dummies(input, dummy_na=True)</span><br><span class="line">input</span><br></pre></td></tr></table></figure>
<h2 id="将csv数值型表格转换成tensor格式">将csv数值型表格转换成tensor格式</h2>
<ul>
<li><p>需要在csv表格nan数据都被处理成数值后才可以转换</p>
<p><code>torch.tensor()</code></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x, y = torch.tensor(input.values), torch.tensor(output.values)</span><br><span class="line">print(x, y)</span><br><span class="line">print(x.dim()) # 查看tensor的维度</span><br></pre></td></tr></table></figure>
<h1 id="线性代数">线性代数</h1>
<h2 id="矩阵转置">矩阵转置</h2>
<ul>
<li><p>对称矩阵的转置等于本身</p>
<p><code>.T</code></p></li>
<li><p>克隆张量 -- 重新分配内存</p>
<p>B=A是建立view,改变B时A也会变</p>
<p><code>B=A.clone()</code>是重新分配内存，改变B时A不会改变</p></li>
<li><p>axis</p>
<p>axis=0是按行（第一维度）处理，axis=1是按列（第二维度）处理</p></li>
</ul>
<h2 id="范数计算">范数计算</h2>
<ul>
<li><p>向量的<span class="math inline">\(L_2\)</span>范式 --
求元素的平方和的平方根</p>
<p><code>torch.norm()</code></p></li>
<li><p>向量的<span class="math inline">\(L_1\)</span>范式 --
求元素的绝对值之和</p>
<p><code>torch.abs(u).sum()</code></p></li>
<li><p>矩阵的<span class="math inline">\(F\)</span>范数 --
矩阵元素的平方和的平方根</p>
<p><code>torch.norm(u)</code></p></li>
</ul>
<h2 id="计算和均值">计算和、均值</h2>
<ul>
<li><p>求和</p>
<p><code>.sum(axis=)</code></p></li>
<li><p>求均值</p>
<p><code>.mean(axis=)</code></p></li>
</ul>
<h2 id="矩阵乘法">矩阵乘法</h2>
<ul>
<li><p>矩阵×向量</p>
<p><code>torch.mv()</code></p></li>
<li><p>矩阵×矩阵</p>
<p><code>torch.mm()</code></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.arange(12).reshape(3,4)</span><br><span class="line">print(x)</span><br><span class="line">print(x.T)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = x.clone()</span><br><span class="line">y</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u = torch.tensor([3.0,4.0])</span><br><span class="line">torch.norm(u), torch.abs(u).sum()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = torch.arange(20*2).reshape(2,5,4)</span><br><span class="line">A, A.sum(axis=0), A.sum(axis=1), A.sum(axis=2), A.sum(axis=[0, 1])</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = torch.arange(20).reshape(5, 4) # 5*4的矩阵</span><br><span class="line">B = torch.arange(4) </span><br><span class="line"></span><br><span class="line">print(A)</span><br><span class="line">print(B)</span><br><span class="line">print(torch.mv(A, B))</span><br><span class="line"></span><br><span class="line">B = torch.arange(12).reshape(4,3)</span><br><span class="line">print(B)</span><br><span class="line">print(torch.mm(A, B))</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = torch.arange(20).reshape(5, 4) # 5*4的矩阵</span><br><span class="line">B = torch.arange(4) </span><br><span class="line">len(A), len(B), A.numel(), B.numel()</span><br></pre></td></tr></table></figure>
<h1 id="微积分">微积分</h1>
<p>标量对列向量求导：求解结果转置为行向量</p>
<p>列向量对标量求导：求解结果为列向量</p>
<p>由于loss通常是标量，因此深度学习中一般对标量进行求导，而不对矩阵或向量求导</p>
<h2 id="自动微分">自动微分</h2>
<ul>
<li><p>存储梯度</p>
<p><code>requires_grad_(True)</code></p></li>
<li><p>反向传播函数计算y关于x的每个分量的梯度</p>
<p><code>.backward()</code></p></li>
<li><p>清除x累积的梯度，将梯度清为0</p>
<p><code>.grad.zero_()</code></p></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x = torch.arange(4.0, requires_grad=True)</span><br><span class="line"># x.requires_grad_(True)</span><br><span class="line">x.grad</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = 2 * torch.dot(x, x) # y=x^2</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y.backward()</span><br><span class="line">x.grad == 4 * x</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()  # 清除累积的梯度记录</span><br><span class="line">y = x.sum()</span><br><span class="line">y.backward()</span><br><span class="line">x.grad == 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y = x * x</span><br><span class="line">y.sum().backward()</span><br><span class="line">x.grad == 2 * x</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x.grad.zero_()</span><br><span class="line">y = x * x</span><br><span class="line">u = y.detach() # 此时u的值=y，但是不与x建立传递关系，仅表示为普通常数</span><br><span class="line">z = u * x</span><br><span class="line">z.sum().backward()</span><br><span class="line">x.grad == u</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def f(a):</span><br><span class="line">  b = 2 * a</span><br><span class="line">  while b.norm()&lt;1000:</span><br><span class="line">    b = b * 2</span><br><span class="line">  if b.sum()&gt;0:</span><br><span class="line">    c = b</span><br><span class="line">  else:</span><br><span class="line">    c = 100 * b</span><br><span class="line">  return c</span><br><span class="line"></span><br><span class="line">a = torch.rand(size=(), requires_grad=True)</span><br><span class="line">d = f(a)</span><br><span class="line">d.backward()</span><br><span class="line">a.grad == d/a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划-背包问题</title>
    <url>/2024/04/26/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一0-1背包问题">一、0-1背包问题</h1>
<h2 id="适用场景">1.1 适用场景</h2>
<p>0-1背包问题属于背包问题中的一种，其特点是：<strong>每个物品只能被选择一次</strong>，两种状态即<strong>要么装入背包，要么不装入背包</strong>。</p>
<h2 id="问题描述">1.2 问题描述</h2>
<p>有一个<strong>背包</strong>，其容量为<code>m</code></p>
<p>现有<code>n</code>个<strong>物品</strong>，每个物品的重量为<code>w[i]</code>，价值为<code>v[i]</code></p>
<p>现在需要选择一些物品装入背包，使得背包中物品的总价值最大。</p>
<h2 id="通用代码思路">1.3 通用代码思路</h2>
<h3 id="二维数组方式">1.3.1 二维数组方式</h3>
<h4 id="数组含义">数组含义</h4>
<p><code>dp[i][j]</code>表示<strong>前i个物品</strong>在<strong>背包容量为j</strong>时的最大价值</p>
<h4 id="状态转移方程">状态转移方程</h4>
<ul>
<li>当<code>j&lt;w[i]</code>时，即当前物品的重量大于背包容量，此时无法装入背包，因此<code>dp[i][j]=dp[i-1][j]</code></li>
<li>当<code>j&gt;=w[i]</code>时，即当前物品的重量小于等于背包容量，此时可以选择<strong>装入或者不装入</strong>背包，因此<code>dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i])</code></li>
</ul>
<h4 id="通用代码">通用代码</h4>
<p><strong>1. 初始化</strong></p>
<p>通常初始化第一排</p>
<p><strong>2. 遍历顺序</strong></p>
<p>可以采用先<strong>物品</strong>后<strong>背包</strong></p>
<p>也可以采用先<strong>背包</strong>后<strong>物品</strong></p>
<p><strong>3. 背包的遍历顺序</strong></p>
<p><strong>正序</strong>就行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;<span class="comment">//物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++j)&#123;<span class="comment">//背包</span></span><br><span class="line">        <span class="keyword">if</span>(j &lt; w[i]) dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一维数组方式">1.3.2 一维数组方式</h3>
<h4 id="数组含义-1">数组含义</h4>
<p><code>dp[j]</code>表示<strong>背包容量为j</strong>时的最大价值</p>
<h4 id="状态转移方程-1">状态转移方程</h4>
<ul>
<li>当<code>j&gt;=w[i]</code>时，即当前物品的重量小于等于背包容量，此时可以选择<strong>装入或者不装入</strong>背包，因此<code>dp[j]=max(dp[j],dp[j-w[i]]+v[i])</code></li>
</ul>
<h4 id="通用代码-1">通用代码</h4>
<p><strong>1. 初始化</strong></p>
<p>可以不用初始化（全初始化为0）</p>
<p><strong>2. 遍历顺序</strong></p>
<p><strong>必须</strong>采用先<strong>物品</strong>后<strong>背包</strong>的遍历顺序</p>
<p><strong>3. 背包的遍历顺序</strong></p>
<p>由于要求每个物品只能被选择一次，且状态转移方程是由前面的状态推导出来的</p>
<p>因此背包的遍历顺序<strong>必须</strong>是<strong>逆序</strong>的，即从大到小遍历，否则会出现<strong>重复选择</strong>的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= w[i]; --j)&#123;<span class="comment">//背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二完全背包问题">二、完全背包问题</h1>
<h2 id="适用场景-1">2.1 适用场景</h2>
<p>完全背包问题的特点是：<strong>每个物品可以被选择多次</strong>，两种状态即<strong>装入背包或者不装入背包</strong></p>
<h2 id="问题描述-1">2.2 问题描述</h2>
<p>有一个<strong>背包</strong>，其容量为<code>m</code></p>
<p>现有<code>n</code>个<strong>物品</strong>，每个物品的重量为<code>w[i]</code>，价值为<code>v[i]</code></p>
<p>现在需要选择<strong>一些可重复的物品</strong>装入背包，使得背包中物品的总价值最大。</p>
<h2 id="通用代码思路-一维数组方式">2.3 通用代码思路-一维数组方式</h2>
<h3 id="数组含义-2">2.3.1 数组含义</h3>
<p><code>dp[j]</code>表示<strong>背包容量为j</strong>时的最大价值</p>
<h3 id="状态转移方程-2">2.3.2 状态转移方程</h3>
<ul>
<li>当<code>j&gt;=w[i]</code>时，即当前物品的重量小于等于背包容量，此时可以选择<strong>装入或者不装入</strong>背包，因此<code>dp[j]=max(dp[j],dp[j-w[i]]+v[i])</code></li>
</ul>
<h3 id="通用代码-2">2.3.3 通用代码</h3>
<p><strong>1. 初始化</strong></p>
<p>可以不用初始化（全初始化为0）</p>
<p><strong>2. 遍历顺序</strong></p>
<p>可以采用先<strong>物品</strong>后<strong>背包</strong></p>
<p>也可以采用先<strong>背包</strong>后<strong>物品</strong></p>
<p><strong>3. 背包的遍历顺序</strong></p>
<p>由于要求每个物品可以被选择多次，所以允许前面的状态中也包含该物品</p>
<p>因此背包的遍历顺序<strong>必须</strong>是<strong>正序</strong>的，即从小到大遍历</p>
<ul>
<li><p>先遍历<strong>物品</strong>，再遍历<strong>背包</strong>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= m; ++j)&#123;<span class="comment">//背包</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>先遍历<strong>背包</strong>，再遍历<strong>物品</strong>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = w[i]; j &lt;= m; ++j)&#123;<span class="comment">//背包</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;<span class="comment">//物品</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>快捷键方式整理</title>
    <url>/2022/11/24/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%96%B9%E5%BC%8F%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h1 id="一office快捷键">一、Office快捷键</h1>
<h2 id="word">1.1 word</h2>
<ul>
<li><p>公式等号对齐</p>
<p>在想对齐的等号左边按<code>Shift+Enter</code>实现换行</p>
<p><img src="/2022/11/24/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%96%B9%E5%BC%8F%E6%95%B4%E7%90%86/shift enter.png" width="50%" heigh="50%"></p>
<p>在上下两个等式左边均右键选择<code>在此字符处对齐</code></p>
<p><img src="/2022/11/24/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%96%B9%E5%BC%8F%E6%95%B4%E7%90%86/align according to equal mark.png" width="50%" heigh="50%"></p>
<p>完成，注意对齐方式选择<code>两端对齐</code></p>
<p><img src="/2022/11/24/%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%96%B9%E5%BC%8F%E6%95%B4%E7%90%86/align.png" width="50%" heigh="50%"></p></li>
</ul>
<h1 id="二vscode">二、vscode</h1>
<ul>
<li><p>python函数快速注释</p>
<p>输入<code>"""</code>后回车</p></li>
<li><p>选中区域整体左移</p>
<p><code>ctrl+[</code></p></li>
<li><p>公式编号</p>
<ul>
<li>在公式内末尾加上<code>#(编号)</code>再按回车即可</li>
</ul></li>
<li><p>切换.cpp和.h文件</p>
<p><code>alt+o</code></p></li>
</ul>
<h1 id="三visual-studio快捷键">三、Visual Studio快捷键</h1>
<ul>
<li><p>切换.cpp和.h文件</p>
<p><code>Ctrl+K</code>+<code>Ctrl+O</code></p></li>
<li><p>选中下一个相同的单词</p>
<p><code>alt+shift+.</code></p></li>
<li><p>选中所有相同的单词</p>
<p><code>Ctrl+Shift+;</code></p></li>
<li><p>格式化选中的代码</p>
<p><code>Ctrl+K</code>+<code>Ctrl+D</code></p></li>
</ul>
<h1 id="四windows快捷键">四、Windows快捷键</h1>
<ul>
<li>多窗口管理
<ul>
<li>参考：<a href="https://blog.csdn.net/lsllll44/article/details/110782643">拼接多个窗口，虚拟桌面等</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/269223525">虚拟桌面可以显示拼接窗口</a></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>重装-环境配置-计算机</category>
      </categories>
      <tags>
        <tag>杂货铺-休闲</tag>
      </tags>
  </entry>
  <entry>
    <title>排序实现</title>
    <url>/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="一选择排序">一、选择排序</h2>
<p>选择排序是一种简单直观的排序算法。它的工作原理如下：</p>
<ul>
<li>遍历数组以[i,end]作为未排序序列，找到最小值的下标minIndex。</li>
<li>不断重复：在当前轮次未排序序列中找到最小（大）元素，存放到当前轮次排序序列的起始位置。</li>
</ul>
<h3 id="代码实现">1.1 代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//选择排序</span></span><br><span class="line">	<span class="keyword">if</span> (vec.<span class="built_in">size</span>() == <span class="number">0</span> || vec.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> vec_size = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vec_size<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> k = i;<span class="comment">//记录当前轮次最小值的索引</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; vec_size; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vec[j] &lt; vec[k]) &#123;</span><br><span class="line">				<span class="comment">//找到新的最小点了</span></span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//一轮下来找到最小值后进行交换</span></span><br><span class="line">		<span class="built_in">swap</span>(vec[i], vec[k]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试">1.2 测试</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVec</span><span class="params">(vector&lt;T&gt;&amp; v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> x : v) &#123;</span><br><span class="line">		cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">23</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">selectSort</span>(vec);</span><br><span class="line">	<span class="built_in">printVec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">1.3 复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n^2)</p>
<p><strong>空间复杂度</strong>：O(1)，属于原地排序。</p>
<h2 id="二冒泡">二、冒泡</h2>
<p><strong>选择排序</strong>是记录最小值的下标，一轮下来后将最小值排在最前面；</p>
<p>而<strong>冒泡排序</strong>是一轮中不断地进行判断与两两交换，最后将<strong>最大值排在最后面</strong>。它的实现原理为：</p>
<ul>
<li>从头开始，两两比较相邻元素，如果逆序则交换。</li>
<li>重复上述步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/bubbleSort.png"></p>
<h3 id="代码实现-1">2.1 代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//冒泡排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> vec_size = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (vec_size == <span class="number">0</span> || vec_size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = vec_size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="comment">//从index为最末尾开始（也就是找到最大值）</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vec[j] &gt; vec[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(vec[j], vec[j + <span class="number">1</span>]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试-1">2.2 测试</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">23</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">13</span>,<span class="number">7</span>,<span class="number">1</span> &#125;;</span><br><span class="line">	<span class="built_in">bubbleSort</span>(vec);</span><br><span class="line">	<span class="built_in">printVec</span>(vec);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化">2.3 优化</h3>
<ul>
<li>如果某一轮下来<strong>没有发生交换</strong>，说明<strong>已经有序</strong>，可以提前结束排序。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//冒泡排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> vec_size = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (vec_size == <span class="number">0</span> || vec_size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = vec_size - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="comment">//从index为最末尾开始（也就是找到最大值）	</span></span><br><span class="line">		<span class="keyword">bool</span> swapFlag = <span class="literal">false</span>; <span class="comment">//记录当前轮有没有发生了交换</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (vec[j] &gt; vec[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(vec[j], vec[j + <span class="number">1</span>]);</span><br><span class="line">				swapFlag = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//优化：一轮下来没有发生交换，</span></span><br><span class="line">		<span class="keyword">if</span> (!swapFlag) &#123;</span><br><span class="line">			<span class="comment">//没发生交换，已经有序了</span></span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;轮次：&quot;</span> &lt;&lt; vec_size - i &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1">2.4 复杂度分析</h3>
<p>时间复杂度和空间复杂度跟选择排序一样。</p>
<p><strong>时间复杂度</strong>：O(n^2)，在优化下，若数组已经有序，时间复杂度为O(n)。</p>
<p><strong>空间复杂度</strong>：O(1)，属于原地排序。</p>
<h2 id="三插入排序">三、插入排序</h2>
<p>插入排序是一种简单直观的排序算法，其思想与扑克牌排序类似。它的工作原理如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素<code>j</code>，在已经排序的元素序列中从后向前扫描，扫描范围为<code>k=[j-1,0]</code>。</li>
<li>如果<code>vec[j] &lt; vec[k]</code>，则将<code>vec[k]</code>向后移动一个位置，直到找到前面已排序数组中第一个<code>vec[j] &gt;= vec[k]</code>。</li>
</ul>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/insertSort.png"></p>
<h3 id="代码实现-2">3.1 代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//插入排序</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> vec_size = vec.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">if</span> (vec_size == <span class="number">0</span> || vec_size == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vec_size; i++) &#123;<span class="comment">//默认第一个数已排序</span></span><br><span class="line">		<span class="comment">//保证前i个数是已排序的</span></span><br><span class="line">		<span class="comment">//循环直到找到前i个数中第一个比其小的数</span></span><br><span class="line">		<span class="keyword">int</span> val = vec[i];</span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; vec[j] &gt;= val) &#123;</span><br><span class="line">			<span class="comment">//vec[j]较大，需要后移一位</span></span><br><span class="line">			vec[j + <span class="number">1</span>] = vec[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		vec[j + <span class="number">1</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-2">3.2 复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(n^2)，在数组本身已经有序的情况下，时间复杂度为O(n)。</p>
<p><strong>空间复杂度</strong>：O(1)，属于原地排序。</p>
<h2 id="四快速排序">四、快速排序</h2>
<blockquote>
<p>快速排序是一种分治的排序算法。它通过将<strong>一个数组分成两个子数组</strong>，将左右两部分独立地不断<strong>递归</strong>实现排序。</p>
</blockquote>
<p>本文参考的是B站上的一个Up主的思路，但是代码是原创实现的。<a href="https://www.bilibili.com/video/BV1vP411g7J3/">全网最清晰快速排序，看完快排思想和代码全部通透，不通透你打我！</a></p>
<h3 id="思路">4.1 思路</h3>
<ul>
<li>选择一个基准值，将数组分成两部分，左边的值都小于基准值，右边的值都大于基准值。</li>
<li>递归地对左右两部分进行排序。</li>
</ul>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/quick1.png"></p>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/quick2.png"></p>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/quick3.png"></p>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/quick4.png"></p>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/quick5.png"></p>
<h3 id="代码实现-3">4.2 代码实现</h3>
<h4 id="根据视频实现">4.2.1 根据视频实现</h4>
<ul>
<li>先实现一个分区函数<code>quickSort_midpos</code>，将数组分成两部分，左边的值都小于基准值，右边的值都大于基准值。并返回基准值的位置用于下一轮左右两部分的递归排序。</li>
<li>递归函数<code>quickSort</code>不断调用<code>quickSort_midpos</code>对左右两部分进行排序。</li>
<li>设计静态函数<code>myQuickSortTest</code>用于测试。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myQuickSort</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printVect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">			cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序:递归实现</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">			<span class="comment">//递归方法实现对arr的原地排序</span></span><br><span class="line">			<span class="comment">//printVect(arr);</span></span><br><span class="line">			<span class="keyword">int</span> pos = <span class="built_in">quickSort_midpos</span>(arr, left, right);<span class="comment">//放回当前层归类左右两边后的中心点位置</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//继续对中心点位置的左右两边进行快排</span></span><br><span class="line">			<span class="built_in">quickSort</span>(arr, left, pos - <span class="number">1</span>);<span class="comment">//左边递归排序</span></span><br><span class="line">			<span class="built_in">quickSort</span>(arr, pos + <span class="number">1</span>, right);<span class="comment">//右边递归排序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序:分区函数</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">quickSort_midpos</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> pos_val = arr[left];<span class="comment">//取左边第一个点作为分界线（空点，等待比起小的点填补进去</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> empty_index = left;<span class="comment">//其实不是empty，该位上的值为pos_val</span></span><br><span class="line">		<span class="keyword">while</span> (left != right) &#123;</span><br><span class="line">			<span class="keyword">if</span> (empty_index == left) &#123;</span><br><span class="line">				<span class="comment">//空值在左边，需要移动右边的点，找到比分界线小的点进行交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[right] &lt;= pos_val) &#123;</span><br><span class="line">					<span class="comment">//右边的值是比分界线小的值，需要移到empty位置</span></span><br><span class="line">					<span class="built_in">swap</span>(arr[empty_index], arr[right]);</span><br><span class="line">					<span class="comment">//更新新的空值为right</span></span><br><span class="line">					empty_index = right;</span><br><span class="line">					left++;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">//右边的值比分界线大，继续移动右边的指针直到找到比分界线小的值</span></span><br><span class="line">					right--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (empty_index == right) &#123;</span><br><span class="line">				<span class="comment">//此时空值在右边，需要移动左指针，找到比分界线大的点进行交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[left] &gt;= pos_val) &#123;</span><br><span class="line">					<span class="built_in">swap</span>(arr[left], arr[empty_index]);</span><br><span class="line">					empty_index = left;</span><br><span class="line">					right--;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					left++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//将分界值传回数组中</span></span><br><span class="line">		arr[left] = pos_val;</span><br><span class="line">		<span class="keyword">return</span> right;<span class="comment">//也可传回right</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试函数</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myQuickSortTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please input some nums(int) and use exit to stop inputting numbers:&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">		vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> num;</span><br><span class="line">		string strIn;</span><br><span class="line">		<span class="keyword">while</span> (cin &gt;&gt; strIn) &#123;</span><br><span class="line">			<span class="keyword">if</span> (strIn == <span class="string">&quot;exit&quot;</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span></span><br><span class="line">			&#123;</span><br><span class="line">				num = <span class="built_in">stoi</span>(strIn);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//检查转成int后的数再转成string是否还跟原始输入的值一样，是的话则说明输入值是个整数，否则抛出一个错误</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">to_string</span>(num) != strIn) &#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;Error!! Please input a num(int) again!&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					arr.<span class="built_in">push_back</span>(num);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::exception&amp;)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;Invalid Input! Please input a num(int) again!&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//vector&lt;int&gt; arr = &#123; 13,435,1,54,7,23,7,2,76,12,0 &#125;;</span></span><br><span class="line"></span><br><span class="line">		myQuickSort QS;</span><br><span class="line">		QS.<span class="built_in">quickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">		QS.<span class="built_in">printVect</span>(arr);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;调试用&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>测试</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myQuickSort.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myQuickSort::<span class="built_in">myQuickSortTest</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据hello算法实现">4.2.2 根据Hello算法实现</h4>
<p><strong>Hello算法</strong>中的思想更为简单明了，在一个<code>[left,right]</code>范围内查找<code>pos</code>时的思路为：</p>
<ul>
<li>以第一个数<code>nums[left]</code>作为基准值<code>base</code>，将双指针分别赋值为<code>low = left</code>和<code>high = right</code></li>
<li>从右向左移动<code>high</code>，找到第一个小于<code>base</code>的数</li>
<li>从左向右移动<code>low</code>，找到第一个大于<code>base</code>的数</li>
<li>交换<code>nums[low]</code>和<code>nums[high]</code></li>
<li>重复上述步骤，直到<code>low</code>和<code>high</code>相遇，相遇后就剩最后一个位置需要交换，将<code>base</code>和<code>nums[low]</code>交换。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by MacBook pro on 24-9-21.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QUICKSORT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUICKSORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">quicksort</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//将区间[left, right]内的数据根据基准值nums[left]进行划分，左边全部小于等于基准值，右边全部大于等于基准值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">position</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前排序的范围是[left, right]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//选择基准值</span></span><br><span class="line">        <span class="keyword">int</span> baseNum = nums[left];</span><br><span class="line">        <span class="keyword">int</span> low = left;</span><br><span class="line">        <span class="keyword">int</span> high = right;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//以刚开始的left作为基准时：必须得先从右边找起，不然会出现最后baseNum跟比baseNum大的值交换，导致左边出现比baseNum大的值</span></span><br><span class="line">            <span class="comment">//从右边找到第一个比baseNum小的数</span></span><br><span class="line">            <span class="comment">//从左边找到第一个比baseNum大的数</span></span><br><span class="line">            <span class="comment">//将找到的两个数进行交换</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= baseNum) --high;</span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= baseNum) ++low;</span><br><span class="line">            <span class="built_in">swap</span>(nums[low], nums[high]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将基准值放至分区位置</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[low]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行地柜排序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doQuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前排序的范围是[left, right]</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前分区的基准值的位置</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="built_in">position</span>(nums, left, right);</span><br><span class="line">        <span class="comment">//继续排左边的</span></span><br><span class="line">        <span class="built_in">doQuickSort</span>(nums, left, pos - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//继续排右边的</span></span><br><span class="line">        <span class="built_in">doQuickSort</span>(nums, pos+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//QUICKSORT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码中的<code>position</code>函数是用来找到基准值的位置，<code>quickSort</code>函数是递归调用<code>position</code>函数对左右两部分进行排序。</p>
</blockquote>
<h3 id="复杂度分析-3">4.3 复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(nlogn)，最坏情况下为O(n^2)。</p>
<p><strong>空间复杂度</strong>：最坏情况是O(n)，在输入数组完全倒序的情况下，达到最差递归深度n，使用O(n)栈帧空间。</p>
<h3 id="快排为什么快">4.4 快排为什么快？</h3>
<ul>
<li>出现最坏情况的概率很低</li>
<li>快速排序快的主要原因是大大减少了<strong>比较和交换的次数</strong>，因为按基准数切分的两半数组，在一个数组里面的数据是绝对不会和第二个数组里面的数字产生比较的机会的，所以大幅度降低了做无用功的机会。</li>
</ul>
<h2 id="五归并排序">五、归并排序</h2>
<h3 id="思路-1">5.1 思路</h3>
<p>归并排序是一种<strong>分治</strong>的排序算法，思想是先按照<strong>左右中</strong>的顺序，具体步骤如下：</p>
<ul>
<li><strong>左右</strong>：先不断递归地将数组<strong>分</strong>成两半，直到每个子数组只有一个元素后return回溯，得到某一层的左右两个有序数组（默认一个元素是有序的）</li>
<li><strong>中</strong>：将左右两个有序数组<strong>合并</strong>成一个有序数组，期间需要用到<strong>临时数组</strong>来存放合并后的有序数组</li>
</ul>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/mergeSort.png"></p>
<h3 id="代码实现-4">5.2 代码实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> LR_size = right - left + <span class="number">1</span>;</span><br><span class="line">	<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmpVec</span><span class="params">(LR_size)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过临时数组&amp;&amp;比对数值合并左右子树</span></span><br><span class="line">	<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//[left,mid]是左边，[mid+1,right]是右边</span></span><br><span class="line">	<span class="keyword">int</span> left_p = left, right_p = mid+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left_p &lt;= mid &amp;&amp; right_p &lt;= right) &#123;<span class="comment">//以左树为基准进行数据填充，且两个子树都还没遍历到最后的点</span></span><br><span class="line">		<span class="keyword">if</span> (vec[left_p] &lt;= vec[right_p]) &#123;</span><br><span class="line">			<span class="comment">//左子树值更小，将左子树值放入</span></span><br><span class="line">			<span class="keyword">while</span> (left_p&lt;=mid &amp;&amp; vec[left_p] &lt;= vec[right_p]) &#123;</span><br><span class="line">				tmpVec[i++] = vec[left_p++];</span><br><span class="line">				<span class="comment">/*++i;</span></span><br><span class="line"><span class="comment">				++left_p;*/</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//右子树值更小，将右子树值放入</span></span><br><span class="line">			<span class="keyword">while</span> (right_p &lt;= right &amp;&amp; vec[left_p] &gt; vec[right_p]) &#123;</span><br><span class="line">				tmpVec[i++] = vec[right_p++];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将剩下的左/右子树添加到数组中</span></span><br><span class="line">	<span class="keyword">if</span> (left_p &lt;= mid) &#123;</span><br><span class="line">		<span class="comment">//右子树走完了，剩下的都填充给左子树</span></span><br><span class="line">		<span class="keyword">while</span> (left_p &lt;= mid) &#123;</span><br><span class="line">			tmpVec[i++] = vec[left_p++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (right_p &lt;= right) &#123;</span><br><span class="line">		<span class="comment">//左子树走完了，剩下的都填充给右子树</span></span><br><span class="line">		<span class="keyword">while</span> (right_p &lt;= right) &#123;</span><br><span class="line">			tmpVec[i++] = vec[right_p++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将临时数组赋值给原始数组</span></span><br><span class="line">	left_p = left;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> tmp : tmpVec) &#123;</span><br><span class="line">		vec[left_p++] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//递归分左右子树</span></span><br><span class="line">	<span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">mergeSort</span>(vec, left, mid);</span><br><span class="line">	<span class="built_in">mergeSort</span>(vec, mid+<span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//merge合并左右子树</span></span><br><span class="line">	<span class="comment">//左/右 子树是已经排序了的</span></span><br><span class="line">	<span class="built_in">merge</span>(vec, left, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-4">5.3 复杂度分析</h3>
<p><strong>时间复杂度</strong>：O(nlogn)，划分产生高度为<code>lg(n)</code>的递归树，每层合并的总操作数量为<code>O(n)</code></p>
<p><strong>空间复杂度</strong>：O(n)，合并操作需要一个临时数组来存放合并后的有序数组。</p>
<h2 id="六堆排序">六、堆排序</h2>
<h3 id="思路-2">6.1 思路</h3>
<p>未完待续......</p>
<h2 id="七总结">七、总结</h2>
<p>各种算法的复杂度总结：</p>
<p><img src="/2024/04/03/%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0/summary.png"></p>
<blockquote>
<p>参考：<a href="https://www.hello-algo.com/chapter_sorting/selection_sort/">Hello
算法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>推广搜1：基础知识及学习路线篇</title>
    <url>/2024/12/20/%E6%8E%A8%E5%B9%BF%E6%90%9C1%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E7%AF%87/</url>
    <content><![CDATA[<h1 id="一基础知识">一、基础知识</h1>
<h2 id="推广搜使用场景及特征类型">1.1 推广搜使用场景及特征类型</h2>
<p><strong>1）场景</strong></p>
<p>推搜常用场景有</p>
<ul>
<li>购物</li>
<li>新闻</li>
<li>视频</li>
<li>音乐...</li>
</ul>
<p>推荐目的是</p>
<ul>
<li>增加点击率</li>
<li>增加观看时长</li>
<li>增加购买转化率</li>
<li>增加用户粘性...</li>
</ul>
<p><strong>2）特征类型</strong></p>
<p>搜推模型的输入特征类型主要有三种：<strong>物品信息、用户信息、场景信息</strong>，这三类协同作用得到推荐结果</p>
<p>物品信息：</p>
<ul>
<li>价格</li>
<li>销量</li>
<li>评价...</li>
</ul>
<p>用户信息：</p>
<ul>
<li>历史行为（购买记录）</li>
<li>关系网</li>
<li>性别...</li>
</ul>
<p>场景信息：</p>
<ul>
<li>时间</li>
<li>地区</li>
<li>用户状态...</li>
</ul>
<h2 id="自然推荐和推荐广告">1.2 自然推荐和推荐广告</h2>
<ul>
<li>自然推荐：自然推荐是<strong>提升用户体验和信息分发效率</strong>的，属于<strong>免费</strong>流量，因此主要考虑<strong>用户和平台利益</strong>，基本不考虑商家
<ul>
<li>指标：<strong>CTR（点击率）</strong></li>
<li>主要排序：<strong>CTR</strong>，可能还会再结合销量、评价等指标</li>
<li>感知：自然推荐通常是无感的</li>
</ul></li>
<li>推荐广告：推荐广告是<strong>商家花钱投放</strong>的，因此主要考虑<strong>商家利益</strong>，同时<strong>兼顾用户和平台的利益</strong>
<ul>
<li>指标：<strong>CPM（千次展示成本）</strong></li>
<li>主要排序：<strong>eCPM</strong>，广告侧还需要去考虑广告商品的质量、历史销量、历史好评率等等各种因素，将这些因素综合考虑组成另外一个分数Q值，最终二者按照一定权重，形成一个复合公式：<code>Rank_Score = a×eCPM + b×Q</code></li>
<li>感知：推荐广告通常会有<strong>广告</strong>字样用于标识</li>
</ul></li>
</ul>
<h2 id="推荐算法基本流程">1.3 推荐算法基本流程</h2>
<p>整个推搜系统的运作流程图如下：</p>
<p><img src="/2024/12/20/%E6%8E%A8%E5%B9%BF%E6%90%9C1%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E7%AF%87/structure.png" width="100%" height="100%"></p>
<p>推荐算法最主要的流程是：</p>
<ul>
<li><p>数据处理：将<strong>数据数值化</strong>。其中数据可以分为<strong>连续特征</strong>和<strong>类别特征</strong>两种，连续特征如<strong>价值、销量</strong>等可以直接数值化；而类别特征如<strong>性别、等级、星期、城市等</strong>这些可选项、不具备数值化意义的需要用<strong>哈希散列、one-hot等进行编码向量化</strong>。</p></li>
<li><p>建模</p>
<ul>
<li><p><strong>召回</strong>：一般用<strong>召回规则（如用户的搜索关键词、历史行为）</strong>从海量的<strong>候选集</strong>中召回用户可能感兴趣的物品。</p>
<ul>
<li>举例：用户在搜索框中输入“跑步鞋”，系统会召回所有与“跑步鞋”相关的广告，包括直接相关的广告（如某品牌的跑步鞋）和间接相关的广告（如运动装备、健身课程等）。</li>
</ul></li>
<li><p><strong>过滤</strong>：过滤一般会进一步保证结果的<strong>实时性、相关性、物品相似性和用户相似度等</strong>，通常会考虑用户的地域限制、匹配度等因素。</p>
<ul>
<li>举例：对于用户输入“跑步鞋”的搜索，过滤系统可能会移除不相关的广告（如与“跑步”无关的时尚鞋类广告）或已经过期的广告。</li>
</ul></li>
<li><p><strong>精排</strong>：<strong>百量级的内容并按照顺序推送，精排也一直是推搜模型优化的重点</strong>，确保最优质、最相关的广告位于前列，提升广告的点击率和转化率。通常会使用<strong>CTR预测模型、双塔深度学习等模型</strong>来优化排序。
<img src="/2024/12/20/%E6%8E%A8%E5%B9%BF%E6%90%9C1%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E7%AF%87/Ranking.png" width="80%" height="80%"></p>
<ul>
<li>举例：在“跑步鞋”搜索结果中，精排阶段会确保广告中最相关的、用户最可能点击的跑步鞋广告排在前面，考虑到价格、品牌偏好等因素。</li>
</ul></li>
<li><p><strong>混排</strong>：为<strong>避免内容越推越窄</strong>，将精排后的推荐结果进行一定修改，<strong>例如控制某一类型的频次</strong>。</p></li>
<li><p><strong>强规则</strong>：强规则是一些行业规定的、无法修改的<strong>固定规则</strong>，如<strong>广告不能违法违规、广告不能虚假宣传恶意竞争等规则</strong>。通常需要<strong>确保广告展示符合法律、平台及广告主的要求</strong></p></li>
</ul>
<p><img src="/2024/12/20/%E6%8E%A8%E5%B9%BF%E6%90%9C1%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E7%AF%87/Modeling.png" width="60%" height="60%"></p></li>
<li><p>评估：评估模型在测试集上的效果，常用的评估指标包括<strong>准确率、召回率、F1值、AUC</strong>等</p></li>
</ul>
<h2 id="数据预处理算法原理">1.3 数据预处理算法原理</h2>
<p>数据预处理中的数据可以分为<strong>连续特征</strong>和<strong>类别特征</strong>两种</p>
<ul>
<li><strong>连续特征</strong>：如<strong>价值、销量</strong>等可以直接数值化</li>
<li><strong>类别特征</strong>：如<strong>性别、等级、星期、城市等</strong>这些可选项、不具备数值化意义的需要用<strong>哈希散列、one-hot等进行编码向量化</strong>。</li>
</ul>
<h3 id="哈希散列">1）哈希散列</h3>
<p>哈希散列是一种将特征值映射到<strong>固定长度为n的向量</strong>的方法</p>
<p>比如需要将<code>weekly</code>特征映射到长度为<code>n=3</code>的向量中，也就是通过二进制编码制定映射规则<code>Tuesday=[0,1,0]=十进制的2</code>，用长度为3的向量可以无哈希冲突地映射所有星期值。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>当映射空间不足时会导致<strong>哈希冲突</strong>，从而导致某些特征的信息丢失。（比如用n=2去映射weekly时会出现哈希碰撞）</li>
<li>使用了哈希函数增加了<strong>计算复杂度</strong></li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>内存占用较低，适合大规模数据集</li>
</ul>
<h3 id="one-hot">2）one-hot</h3>
<p>one-hot是一种将特征值映射到<strong>固定长度为n的向量</strong>的方法，<strong>其中n为可选类别的个数</strong></p>
<p>比如将<code>weekly</code>特征映射到长度为7的向量中，选中了星期几就把该位置置为1，比如<code>Tuesday=[0,1,0,0,0,0,0]</code>，用长度为7的向量可以无哈希冲突地映射所有星期值。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>会导致存在大量数量为0的值，导致输入的<strong>特征向量稀疏</strong>，导致<strong>维度爆炸和训练速度慢</strong>。</li>
<li>维度高，内存占用高</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>直观、容易理解</li>
</ul>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/395062194">广告和推荐算法论文梳理</a></p>
<p><a href="https://blog.csdn.net/weixin_43805551/article/details/123416478">自然推荐和推荐广告的区别：推荐算法（推广搜）</a></p>
<p><a href="https://blog.csdn.net/m0_59596990/article/details/122240815">超全推荐算法基础知识：超全，7种经典推荐算法模型及应用</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2220394">!!!详细推搜知识包含召回-排序：推荐系统[一]：超详细知识介绍，一份完整的入门指南，解答推荐系统相关算法流程、衡量指标和应用，以及如何使用jieba分词库进行相似推荐</a></p>
</blockquote>
<h1 id="二学习路线">二、学习路线</h1>
<blockquote>
<p>推荐算法学习博客&amp;github：https://datawhalechina.github.io/fun-rec/#/</p>
<p>学习路线参考文章：<a href="https://zhuanlan.zhihu.com/p/431446738">推荐算法&amp;广告算法学习路线</a>，其中重点关注文章中的<strong>三、推荐算法</strong>和<strong>四、广告算法</strong></p>
</blockquote>
<p>tmp记录文章：</p>
<blockquote>
<p><a href="https://blog.csdn.net/m0_48086806/article/details/136914225">【主要推荐算法概览，包括召回与排序】</a></p>
<p><a href="https://blog.csdn.net/u011863024/article/details/115721328">Elasticsearch学习笔记</a></p>
<p><a href="https://blog.csdn.net/aibo_yyds/article/details/120081333">Elasticsearch工具使用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>手写操作系统1：项目环境部署</title>
    <url>/2024/11/25/%E6%89%8B%E5%86%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1%EF%BC%9A%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="一安装docker下的archlinux">一、安装docker下的archlinux</h1>
<blockquote>
<p>docker的安装教程可以参考：<a href="https://akirazheng.github.io/2024/06/14/Asyncflow%E9%A1%B9%E7%9B%AE1%EF%BC%9A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/#/1-Docker">Asyncflow项目1：环境部署</a></p>
</blockquote>
<h2 id="下载archlinux镜像">1.1 下载archlinux镜像</h2>
<ul>
<li><p>方法一：直接通过docker pull命令下载（会有大概率pull不成功）
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull archlinux</span><br></pre></td></tr></table></figure></p></li>
<li><p>方法二：通过开源github项目的action流手动下载<code>archlinux:base</code>的<code>tar</code>镜像</p>
<ul>
<li>项目地址：<a href="https://github.com/AkiraZheng/DockerPull/actions/">DockerPull</a>，<code>Workflow</code>的使用参考：<a href="https://b23.tv/dxefZCE">如何使用docker离线包？从此告别头疼的docker
pull-哔哩哔哩</a></li>
<li>解压完成后通过<code>docker load</code>命令导入 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load -i ./xxx/archlinux.tar # 导入./xxx/archlinux:base-amd64.tar路径下的镜像</span><br><span class="line">docker images # 查看导入的镜像</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="运行archlinux容器">1.2 运行archlinux容器</h2>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>推广搜2：传统推荐模型之协同过滤算法</title>
    <url>/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一基础知识">一、基础知识</h1>
<h2 id="正则化">1.1 正则化</h2>
<p>正则化是通过给<strong>损失函数添加正则项</strong>来减少噪点的影响，防止<strong>过拟合</strong>的</p>
<p>作用：<strong>避免某些离奇数据影响训练，防止训练过拟合</strong>。也就是避免拟合离奇数据。</p>
<h2 id="过拟合">1.2 过拟合</h2>
<p>过拟合是指训练拟合结果虽然能拟合所有样本数据，但是由于离奇样本数据的存在，导致拟合结果与实际不符合</p>
<p>过拟合的可能原因：</p>
<ul>
<li>训练次数epoch过多</li>
<li>训练数据集过少</li>
<li>特征过多，未筛选</li>
<li>没有引入<strong>正则化约束</strong>，导致模型的鲁棒性和泛化能力差...</li>
</ul>
<p>过拟合的缺点：导致训练结果不稳定</p>
<p>过拟合的例子如下图所示，红色线为过拟合结果，把噪声点也拟合进去了；蓝色线是加入正则化后得到的正常拟合结果，噪声点没被拟合进去：</p>
<p><img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/overfitting.png" width="60%" height="60%"></p>
<h1 id="二协同过滤算法">二、协同过滤算法</h1>
<p>协同过滤算法可以分为<strong>userCF</strong>和<strong>itemCF</strong>两种，假设有m个用户，n种物品：</p>
<ul>
<li><p>userCF：基于<strong>用户相似</strong>，算法会为用户推荐<strong>与用户兴趣相似的用户喜欢的物品</strong></p>
<p>通过生成**m*m大小的用户相似性矩阵<strong>来进行推荐，考虑与用户兴趣相似的用户的意见。但是由于现实互联网中，</strong>用户数量远大于物品数量<strong>，因此会导致相似性矩阵的计算量过大，现实使用中通常选择</strong>itemCF方法**。</p></li>
<li><p>itemCF：基于<strong>物品相似</strong>，算法会为用户推荐<strong>与用户历史喜欢物品相似的物品</strong></p>
<p>通过生成**n*n大小的物品相似性矩阵**来进行推荐，通过用户历史喜欢的物品，结合物品相似性矩阵来推荐。</p></li>
</ul>
<p>协同过滤的缺点:</p>
<ul>
<li>当用户数量远大于物品数量时，用户相似性矩阵的计算量过大</li>
<li>在低频场景下，用户历史数据稀疏，找到相似用户困难</li>
</ul>
<p>可以考虑使用<strong>矩阵分解</strong>来优化计算量并缓解矩阵稀疏问题。</p>
<h2 id="usercf算法实现">2.1 userCF算法实现</h2>
<p>userCF协同过滤算法主要分为5个过程：</p>
<ul>
<li><p>1）物品库中有n个物品，用户有m个；</p></li>
<li><p>2）用户历史评价有向图；</p></li>
<li><p>3）协同过滤的共现矩阵；</p>
<p>通过将点赞值映射为1，踩值为-1，未点赞值为0，得到物品库中物品之间的共现矩阵</p></li>
<li><p>4）计算用户相似性矩阵并排出topk作为推荐目标；</p>
<p>计算用户i和用户j的相似度，其实就是计算用户向量<strong>i</strong>和用户向量<strong>j</strong>之间的相似度（也就是第i行跟第j行）。通常可以选择采用<strong>余弦相似度</strong>计算两向量的夹角来表示用户相似度。</p>
<p><img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/cosine.png" width="40%" height="40%"></p>
<ul>
<li>皮尔逊相关系数：添加<strong>用户平均分进行修正</strong>，减少用户评分偏置的影响
<img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/pearson.png" width="50%" height="50%"></li>
<li>基于皮尔逊相关系数引入<strong>物品平均分</strong>，减少物品评分偏置的影响</li>
</ul></li>
<li><p>5）利用相关系数topk的用户对目标物品的评价来最终预测是否推荐给用户
<img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/predict.png" width="50%" height="50%"></p></li>
</ul>
<p>userCF协同过滤流程图：</p>
<p><img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/userCF.png" width="100%" height="100%"></p>
<h2 id="itemcf算法实现">2.2 itemCF算法实现</h2>
<p>相比userCF，itemCF在构建<strong>相似性矩阵</strong>和<strong>预测结果函数</strong>上有所不同。</p>
<ul>
<li>相似性矩阵：通过物品i列向量和物品j列向量之间的相似度来计算物品相似度矩阵，得到n*n大小的物品相似矩阵。</li>
<li>预测结果函数：通过物品相似矩阵和用户历史物品评分的累和来预测用户对目标物品的评分。
<img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/itemCF.png" width="50%" height="50%"></li>
</ul>
<h1 id="三矩阵分解">三、矩阵分解</h1>
<h2 id="算法原理">3.1 算法原理</h2>
<p>矩阵分解<strong>为每个用户和物品生成隐向量</strong>并映射到<strong>多维坐标</strong>中，在坐标中离用户近的物品就是推荐目标。</p>
<p>也就是将<strong>m<em>n的共现矩阵<strong>分解为</strong>m</em>k的用户矩阵</strong>和**k*n的物品矩阵**，其中k为隐向量维度。</p>
<p>最后某个用户对某个物品的评价（也就是共现矩阵的值）可以通过<strong>用户矩阵和物品矩阵计算预测出来</strong>。</p>
<p><img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/matrix.png" width="70%" height="70%"></p>
<p><img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/matrix_decompose.png" width="70%" height="70%"></p>
<p>矩阵分解的优点：</p>
<ul>
<li><strong>泛化能力强</strong>，一定程度上解决矩阵稀疏问题</li>
<li><strong>空间复杂度低</strong>，从n^2降低到(n+m)*k</li>
<li>矩阵分解结果便于与其他特征<strong>拼接组合</strong></li>
<li>便于与深度学习网络无缝结合</li>
</ul>
<p>矩阵分解的缺点：</p>
<ul>
<li>与协同过滤矩阵一样，不方便加入<strong>用户、物品、场景等特征</strong></li>
</ul>
<p>可以通过<strong>逻辑回归模型</strong>通过因子分解融合多种特征。</p>
<h2 id="梯度下降">3.2 梯度下降</h2>
<p>如何分解共现矩阵呢？</p>
<p>通常采用的是<strong>梯度下降</strong>方法来获取物品向量矩阵<strong>q</strong>和用户向量矩阵<strong>p</strong>。</p>
<p>其中损失函数的制定是要让共现矩阵的值<strong>r</strong>与分解结果（p*q）的差值最小，对损失函数求导找到梯度方向，根据偏导更新权重。同时加上正则化，因此最终的损失函数为：</p>
<p><img src="/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/loss.png" width="50%" height="50%"></p>
<blockquote>
<p>参考</p>
<p>书籍: 《深度学习推荐系统》</p>
<p><a href="https://blog.csdn.net/m0_37531129/article/details/111461052">推荐系统--2--协同过滤与矩阵分解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>推广搜3：传统推荐模型之逻辑回归算法LR</title>
    <url>/2024/12/25/%E6%8E%A8%E5%B9%BF%E6%90%9C3%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95LR/</url>
    <content><![CDATA[<h1 id="一基础知识">一、基础知识</h1>
<h2 id="梯度下降">1.1 梯度下降</h2>
<p>梯度下降也称为最速下降法，其目的是<strong>找到一个函数的局部极小值</strong>。</p>
<p><strong>梯度下降法：</strong></p>
<p>假设需要根据已有的样本拟合一函数<span class="math inline">\(f_\theta(t_1, t_2, ..., t_n)= \theta_1t_1 +
\theta_2t_2 + ... + \theta_nt_n\)</span>，其中<span class="math inline">\(t_1, t_2, ..., t_n\)</span>为样本的特征值，<span class="math inline">\(\theta_1, \theta_2, ...,
\theta_n\)</span>为各个特征对应的权重。</p>
<p>那么我们需要做的就是根据已有样本集迭代找出各个<span class="math inline">\(\theta_i\)</span>的取值，使得能拟合出函数<span class="math inline">\(f\)</span>：</p>
<ul>
<li><p>找到令代价函数（损失函数）<span class="math inline">\(J(\theta_1,
\theta_2, ..., \theta_n)\)</span>
的最小点。其中代价函数通常是表示<strong>预测值与真实值之间的误差</strong>。</p></li>
<li><p>由于<span class="math inline">\(J(\theta_1, \theta_2, ...,
\theta_n)\)</span>是多维的，因此针对每个维度<span class="math inline">\(\theta_i\)</span>，其偏导数<span class="math inline">\(\frac{\partial J}{\partial
\theta_i}\)</span>，也称为梯度，在该维度下，变量<span class="math inline">\(\theta_i\)</span>沿梯度的反方向移动时，损失函数下降最快。基于此，令步长为<span class="math inline">\(\alpha\)</span>，则各个<span class="math inline">\(\theta_i\)</span>的更新公式为：</p>
<p><span class="math display">\[ \theta_i = \theta_i - \alpha
\frac{\partial J}{\partial \theta_i} \]</span></p></li>
</ul>
<p><strong>举例说明梯度下降法的运作：</strong></p>
<p>假设有一个函数<span class="math inline">\(y = f_w(x) = w_1x +
w_2\)</span>，针对该函数，有一些样本集：<span class="math inline">\(x_1,
x_2, ..., x_m\)</span>，其对应的标签值：<span class="math inline">\(y_1,
y_2, ..., y_m\)</span>。</p>
<p>需要通过梯度下降法不断更新<span class="math inline">\(w_1,
w_2\)</span>并找到最优的<span class="math inline">\(w_1,
w_2\)</span>，从而拟合函数<span class="math inline">\(f_w(x)\)</span>：</p>
<ul>
<li><p>首先找到<span class="math inline">\(f\)</span>函数的损失函数：</p>
<p><span class="math display">\[J(w_1, w_2) =
\frac{1}{2m}\sum_{i=1}^m(f_w(x_i) - y_i)^2\]</span></p></li>
<li><p>对<span class="math inline">\(w_1\)</span>的更新方向是对<span class="math inline">\(w_1\)</span>维度求它在<span class="math inline">\(j(w_1,w_2)\)</span>函数中的偏导（对<span class="math inline">\(w_2\)</span>的更新同理）：</p>
<p><span class="math display">\[\frac{\partial J}{\partial w_1} =
\frac{1}{m}\sum_{i=1}^m(f_w(x_i) - y_i)x_i\]</span></p></li>
<li><p>令更新步长为<span class="math inline">\(\alpha\)</span>，则<span class="math inline">\(w_1\)</span>的更新公式为：</p>
<p><span class="math display">\[w_1 = w_1 - \alpha \frac{\partial
J}{\partial w_1} \]</span></p></li>
</ul>
<p>在梯度下降法的一个epoch中，会先初始化<span class="math inline">\(w_1,
w_2\)</span>，然后不断重复上述步骤更新<span class="math inline">\(w_1,
w_2\)</span>，直到<span class="math inline">\(J(w_1,
w_2)\)</span>的值满足要求（最小化<span class="math inline">\(J(w_1,
w_2)\)</span>）。</p>
<h2 id="极大似然估计">1.2 极大似然估计</h2>
<p>假设上述提到要拟合的函数<span class="math inline">\(f\)</span>为<strong>概率密度函数</strong>，那么他的<strong>代价函数</strong>需要用<strong>极大似然估计</strong>来刻画拟合的匹配程度。</p>
<p><strong>似然函数：</strong></p>
<p><strong>1）离散型模型：</strong></p>
<p><span class="math display">\[L(\theta) = \prod_{i=1}^m
p_\theta(X_i=x_i)\]</span></p>
<p><strong>2）连续型模型：</strong></p>
<p><span class="math display">\[L(\theta) = \prod_{i=1}^m
f_\theta(x_i)\]</span></p>
<p><strong>举例说明极大似然估计：</strong></p>
<p>假设我们有一个要拟合的高斯概率密度函数：</p>
<p><span class="math display">\[f_{\mu,\sigma^2}=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}\]</span></p>
<p><img src="/2024/12/25/%E6%8E%A8%E5%B9%BF%E6%90%9C3%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95LR/Gaussian.png" width="80%" height="80%"></p>
<p>针对该函数，我们有样本集：<span class="math inline">\(x_1, x_2, ...,
x_m\)</span>，将所有样本集带入<strong>待拟合函数</strong>中并相乘可以获得对应的似然函数（也就是代价函数）:</p>
<p><span class="math display">\[L(\mu,\sigma^2)=\prod_{i=1}^m
f_{\mu,\sigma^2}(x_i)\]</span></p>
<p>其中由于似然函数就是概率的乘积，而样本点取出大概率时间的概率比较高，似然函数越大时说明这些点在某个模型中概率越大，那就说明这个模型就是最接近真实分布的，那对应的参数自然就是目标参数</p>
<p>因此越接近真实函数的<span class="math inline">\(\mu,\sigma^2\)</span>，其似然函数<span class="math inline">\(L(\mu,\sigma^2)\)</span>的值越大。所以我们的参数求解目标就是<span class="math inline">\((\mu^*,
\sigma^*)=argmaxL(\mu,\sigma^2)\)</span>。</p>
<p>由于是求最大值，因此可以给似然函数加上一个递增函数<span class="math inline">\(\ln\)</span>，使其由相乘变成相加：</p>
<p><span class="math display">\[L(\mu,\sigma^2)=\ln\prod_{i=1}^m
f_{\mu,\sigma^2}(x_i)=\sum_{i=1}^m \ln
f_{\mu,\sigma^2}(x_i)\]</span></p>
<p>似然函数的最大值点处的梯度是0，因此可以求出最大值点：</p>
<p><span class="math display">\[ \frac{\partial L}{\partial \mu} =
0\]</span></p>
<p><span class="math display">\[ \frac{\partial L}{\partial \sigma^2} =
0\]</span></p>
<p>以此来求得<span class="math inline">\((\mu^*,
\sigma^*)\)</span>的更新公式。</p>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/149788542">推荐系统玩家 之
逻辑回归（Logistic regression）</a></p>
<p><a href="https://blog.csdn.net/qq_41775769/article/details/113514294">一文彻底读懂【极大似然估计】</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/89074979">快速理解极大似然法</a></p>
</blockquote>
<h1 id="二逻辑回归算法">二、逻辑回归算法</h1>
<h2 id="区分两类推广搜模型">2.1 区分两类推广搜模型</h2>
<p>在推广搜的算法中，通常模型会分为<strong>以协同过滤为代表的相似性推荐模型</strong>和<strong>以逻辑回归为代表的分类模型</strong>：</p>
<p><img src="/2024/12/25/%E6%8E%A8%E5%B9%BF%E6%90%9C3%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95LR/Models.png" width="80%" height="80%"></p>
<ul>
<li><p>协同过滤模型：</p>
<p>是利用用户和物品的<strong>相互行为信息</strong>进行推荐的，只需要<strong>相互行为信息</strong>而不是<strong>特征信息</strong>；它是一种基于<strong>相似度</strong>的推荐算法。</p></li>
<li><p>逻辑回归模型：</p>
<p>是综合考虑了<strong>用户、物品、场景的特征信息</strong>，依赖<strong>特征提取、实现多特征融合</strong>；它是<strong>基于概率分类的推荐算法</strong>。</p></li>
</ul>
<h2 id="逻辑回归算法原理">2.2 逻辑回归算法原理</h2>
<p><strong>1）确定待拟合函数<span class="math inline">\(f\)</span></strong></p>
<p>由于实际情况中，我们并不能准确地先给定一个待拟合的函数<span class="math inline">\(f\)</span>，因此，在逻辑回归中我们<strong>将推荐问题转换成了CTR点击率预估问题</strong>，也就是预测一个样本的点击率，将样本映射到<span class="math inline">\([0,1]\)</span>之间</p>
<p>因此给定输入神经元是根据权重累和各个特征值，其中的<strong>权重和常数b就是待拟合的参数</strong>，同时通过激活函数<strong>sigmoid</strong>将输出映射到<span class="math inline">\([0,1]\)</span>之间：</p>
<p><span class="math display">\[f_\mathbf{w}(\mathbf{x_i}) = \frac{1}{1
+ e^{-\mathbf{w·x_i}+b}}\]</span></p>
<p>整个拟合函数如下所示：</p>
<p><img src="/2024/12/25/%E6%8E%A8%E5%B9%BF%E6%90%9C3%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95LR/LogisticRegression.png" width="80%" height="80%"></p>
<p>经过拟合后，最终输出结果为正样本（类别为1：推荐）和负样本（类别为0：不推荐），因此我们需要给输入的样本也添加一个类别标签<span class="math inline">\(y_i\)</span>，其值为0或1，0表示不推荐，1表示推荐。则该拟合函数的概率模型为：</p>
<p><span class="math display">\[p(y_i=1|\mathbf{x_i}) =
f_\mathbf{w}(\mathbf{x_i})\]</span> <span class="math display">\[p(y_i=0|\mathbf{x_i}) = 1 -
f_\mathbf{w}(\mathbf{x_i})\]</span></p>
<p>上述拟合函数的概率模型也可以合并起来表示：</p>
<p><span class="math display">\[p(y_i|\mathbf{x_i}) =
(f_w(\mathbf{x_i}))^y(1-f_w(\mathbf{x_i}))^{1-y}\]</span></p>
<p><strong>2）确定损失函数<span class="math inline">\(J\)</span></strong></p>
<p>由极大似然估计可知，<strong>拟合函数的拟合匹配程度是由似然函数刻画的</strong>，其似然函数为：</p>
<p><span class="math display">\[L(\mathbf{w}) = \prod_{i=1}^m
p(y_i|\mathbf{x_i})\]</span></p>
<p>由于代价函数一般是求最小值问题，而似然函数是求最大值问题，因此需要将似然函数转化为最小化问题，也就是乘上系数<span class="math inline">\(-\frac{1}{k}\)</span>，并取对数<span class="math inline">\(ln\)</span>转换成连加，最终得到代价函数为：</p>
<p><span class="math display">\[J(\mathbf{w}) = -\frac{1}{k}\sum_{i=1}^m
p(y_i|\mathbf{x_i})\]</span></p>
<p><strong>3）确定参数更新公式</strong></p>
<p>对代价函数<span class="math inline">\(J(\mathbf{w})\)</span>求偏导，并按步长<span class="math inline">\(\alpha\)</span>更新参数：</p>
<p><span class="math display">\[w_j = w_j - \alpha \frac{\partial
J(\mathbf{w})}{\partial w_j}\]</span></p>
<p>其中：</p>
<p><span class="math display">\[\frac{\partial J(\mathbf{w})}{\partial
w_j} = \frac{1}{k}\sum_{i=1}^m(f_w(\mathbf{x^i}) -
y^i)x^i_j\]</span></p>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>推广搜4：传统推荐模型之FM模型</title>
    <url>/2025/01/02/%E6%8E%A8%E5%B9%BF%E6%90%9C4%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8BFM%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>本文假设有n个特征</p>
</blockquote>
<h1 id="一poly2模型">一、POLY2模型</h1>
<p>前面学到的<strong>逻辑回归模型</strong>只对多维特征进行<strong>简单线性加权，没有多维特征的组合</strong>（逻辑回归模型只能通过工程师手动组合特征）。</p>
<p>而<strong>POLY2模型、FM模型、FFM模型具备特征交叉的能力，其表达能力更强</strong>。</p>
<p><img src="/2025/01/02/%E6%8E%A8%E5%B9%BF%E6%90%9C4%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8BFM%E6%A8%A1%E5%9E%8B/CombineChareters.png" width="80%" height="80%"></p>
<p>传统的<strong>逻辑回归</strong>模型的预测函数为：</p>
<p><span class="math display">\[y=w_0+\sum_{i}^n w_i x_i\]</span></p>
<p><strong>POLY2模型</strong>会为每个特征组合赋予一个权重，因此其n个特征需要<span class="math inline">\(n^2\)</span>个参数。其复杂度为<span class="math inline">\(O(n^2)\)</span>，预测结果在线性模型的基础上多了一个多项式：</p>
<p><span class="math display">\[y=\sum_{i=1}^{n-1}\sum_{j=i+1}^n w_{i,j}
x_i x_j\]</span></p>
<p><strong>缺点：</strong></p>
<p>这种属于暴力组合，由于互联网数据本身通过<strong>one-hot</strong>成的<strong>稀疏数据</strong>，因此通过暴力组合增加维度后会更加稀疏，导致模型<strong>计算量剧增、泛化能力差</strong>。</p>
<p><strong>解决办法：</strong>可以通过<strong>矩阵分解出隐向量</strong>的方式来降低计算量、提高模型泛化能力。<strong>FM模型</strong>就是通过这种方式构建的。</p>
<h1 id="二fm模型">二、FM模型</h1>
<p>关于<strong>特征分解隐向量</strong>的相关基础知识参考博客<a href="https://akirazheng.github.io/2024/12/24/%E6%8E%A8%E5%B9%BF%E6%90%9C2%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E7%AE%97%E6%B3%95/">推广搜2：传统推荐模型之协同过滤算法</a></p>
<p>POLY2为每个特征组合赋予一个权重，相当于每个特征都有一个对应其他所有特征的向量组合，也就是向量矩阵大小为<span class="math inline">\(n\times n\)</span>。</p>
<p>FM模型则通过<strong>矩阵分解</strong>的方式将特征向量分解为隐向量，其隐向量大小为<span class="math inline">\(n\times k\)</span>，每两个特征向量的权值<span class="math inline">\(w_ij\)</span>是由这两个向量的隐向量内积计算而得的：</p>
<p><span class="math display">\[w_{ij}=\mathbf{v_i}\mathbf{v_j^T}\]</span></p>
<p>因此带入到前面的POLY2模型中，FM的预测函数为：</p>
<p><span class="math display">\[y=\sum_{i=1}^{n-1}\sum_{j=i+1}^n
\mathbf{v_i}\mathbf{v_j^T} x_jx_j\]</span></p>
<h1 id="三ffm模型">三、FFM模型</h1>
<p>FM模型中，<strong>每个特征向量<span class="math inline">\(v_i\)</span>都只有一个隐向量</strong>，也就是说，当某个特征<span class="math inline">\(i\)</span>跟其他任意特征<span class="math inline">\(j\)</span>交互时，发挥的都是相同的作用（因为使用的是同一个隐向量<span class="math inline">\(\vec{v_i}\)</span>。</p>
<p>但是很多时候一个特征对不同特征发挥的作用效果是不同的，为了解决这个问题，FFM提出了<strong>域field</strong>的概念，也就是将每个特征从一个隐向量扩展为每个特征有<strong>一组隐向量</strong>，缺点是这也增加了计算复杂度，从<strong>FM模型</strong>到<strong>FFM模型</strong>复杂度由<span class="math inline">\(O(nk)\)</span>变为<span class="math inline">\(O(n^2k)\)</span>。</p>
<p><strong>FFM模型</strong>的预测函数为：</p>
<p><span class="math display">\[y=\sum_{i=1}^{n-1}\sum_{j=i+1}^n\mathbf{v_{i,f_j}}\mathbf{v_{j,f_i}^T}
x_jx_j\]</span></p>
<p>其中<span class="math inline">\(\mathbf{v_{i,f_j}}\)</span>表示在总共存在的<strong>n个隐向量矩阵</strong>中，特征<span class="math inline">\(i\)</span>作用于特征<span class="math inline">\(j\)</span>上对应的隐向量为第<span class="math inline">\(j\)</span>张矩阵的第<span class="math inline">\(i\)</span>行。</p>
<p><img src="/2025/01/02/%E6%8E%A8%E5%B9%BF%E6%90%9C4%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8BFM%E6%A8%A1%E5%9E%8B/POLY_FM_FFM.png" width="80%" height="80%"></p>
<p><strong>缺点：</strong>FM和FFM一般只能做到二阶特征交叉（也就是特征两两交叉），由FM的二阶变为三阶，其模型参数计算量剧增。</p>
<p><strong>解决办法：</strong>通过如<strong>GBDT+LR</strong>的<strong>组合模型</strong>来解决高阶特征交叉的问题。</p>
<blockquote>
<p>参考</p>
<p><a href="https://zhuanlan.zhihu.com/p/342803984">推荐算法(一)——FM因式分解(原理+代码)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/348596108">推荐算法(二)——FFM原理浅析及代码实战</a></p>
<p><a href="https://github.com/jc-LeeHub/Recommend-System-tf2.0">包括多种基础推搜算法的github代码仓库</a></p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>推广搜5：传统推荐模型之GBDT+LR模型</title>
    <url>/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C5%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8BGBDT-LR%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="gbdtlr模型">GBDT+LR模型</h1>
<p>CTR预估早期使用最多的方案是逻辑回归(LR)，LR
性能非常高，但是其效果十分依赖于大量的特征工程。但是手动构造许多有用特征费时费力，因此<strong>需要有更自动化的方法来发现有效特征并构造组合特征</strong>。</p>
<p>相比FM和FFM通过交互所有的二阶特征导致特征冗余问题，<strong>GBDT自动在特征传入LR模型前先对特征进行自动筛选和组合</strong>，筛选和组合后的包含各阶特征的向量再传入LR模型中进行线性训练。</p>
<p>这里就包含了两部分的独立训练：</p>
<ul>
<li>GBDT模型训练构建特征工程</li>
<li>LR模型训练预估CTR</li>
</ul>
<p><img src="/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C5%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8BGBDT-LR%E6%A8%A1%E5%9E%8B/GBDT+LR模型.png" width="80%" height="80%"></p>
<h2 id="gbdt">GBDT</h2>
<p>GBDT
基于集成学习中的boosting思想，每次迭代都在<strong>减少残差的梯度方向新建立一颗决策树</strong>，迭代多少次就会生成多少颗决策树，不断减少误差。</p>
<p>假设GBDT由两颗树构成，如下图中的 树1 和 树2 ：</p>
<p><img src="/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C5%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8BGBDT-LR%E6%A8%A1%E5%9E%8B/GBDT.png" width="80%" height="80%"></p>
<p>模型最终到达叶子节点形成一个<strong>one-hot编码</strong>，每个节点为1表示该特征被选择，0表示该特征未被选择。如上图形成的one-hot编码为[0,
1, 0, 1, 0]。</p>
<p>同时，决策树决定了特征的阶数，如果决策树深度为3，则说明是通过2次节点分裂得到的，最终叶节点是2阶特征组合的结果，其缺点是相比FFM会损失很多数值信息。</p>
<blockquote>
<p>参考</p>
<p><a href="https://github.com/zxxwin/GBDT_LR">广告点击率(CTR)预测经典模型
GBDT + LR 理解与实践（附数据 + 代码）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>搭建Conda虚拟环境</title>
    <url>/2022/04/12/%E6%90%AD%E5%BB%BAConda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<blockquote>
<p>编写这篇博客的目的是在学习李沐老师的《动手学深度学习》课程、或者自学其它python编程内容时，需要用到的python环境各不相同</p>
</blockquote>
<blockquote>
<p>为了方便学习，还是需要创建多个不同的Conda环境进行区分</p>
</blockquote>
<blockquote>
<p>本文的命令内容是基于Windows10系统的，Linux系统的后续有机会继续更新</p>
</blockquote>
<h1 id="conda中的常用指令">Conda中的常用指令</h1>
<p>一般有<strong>Conda前缀</strong>的指令都是针对<strong>所有环境</strong>进行操作的，或者说是在主环境中操作的</p>
<p>如果需要在当前的<strong>自定义Conda虚拟环境</strong>中执行安装或者查看指令时，<strong>不需要加Conda前缀</strong></p>
<h2 id="conda前缀的指令">Conda前缀的指令</h2>
<ul>
<li><p>查看安装包</p>
<p><code>conda list</code></p></li>
<li><p>查看当前存在的Conda虚拟环境</p>
<p><code>conda env list</code></p>
<p><code>conda info -e</code></p></li>
<li><p>更新当前Conda</p>
<p><code>conda update conda</code></p></li>
<li><p>创建Python虚拟环境</p>
<p><code>conda create -n your_env_name python=x.x</code></p>
<p>其中<strong>your_env_name</strong>为所起的环境名，<strong>x.x</strong>为python版本号，创建的环境可以在Anaconda安装目录的envs文件中找到。</p>
<p>如在创建Pytorch深度学习环境时可以输入：</p>
<p><code>conda create -n d2l_Pytorch python=3.8</code></p></li>
<li><p>激活、关闭、删除虚拟环境</p>
<p>激活或者切换虚拟环境：</p>
<p><code>activate your_env_name</code></p>
<p>关闭虚拟环境切回Root环境:</p>
<p><code>activate root</code></p>
<p>删除虚拟环境：</p>
<p><code>conda remove -n your_env_name --all</code></p></li>
</ul>
<h2 id="自定义虚拟环境内的指令">自定义虚拟环境内的指令</h2>
<p><strong>以下指令均在已经切换到对应环境的情况下</strong>进行输入，如下所示表示已经切换到<strong>d2l_Pytorch</strong>环境：</p>
<p><img src="/2022/04/12/%E6%90%AD%E5%BB%BAConda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/Conda-envs.png"></p>
<ul>
<li><p>检查Python版本（CMD中输入）</p>
<p><code>python --version</code></p></li>
<li><p>查看环境中已有的安装包</p>
<p><code>pip list</code></p></li>
<li><p>安装虚拟环境中对于版本的包</p>
<p><code>pip install package_name==x.x</code></p>
<p>其中<strong>x.x</strong>代表包对应的版本号，如下所示：</p></li>
</ul>
<p><img src="/2022/04/12/%E6%90%AD%E5%BB%BAConda%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/pip-install-package.png"></p>
<ul>
<li><p>删除环境中的某个包</p>
<p><code>pip uninstall  package_name</code></p></li>
</ul>
]]></content>
      <categories>
        <category>重装-环境配置-计算机</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统内存管理</title>
    <url>/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="一虚拟内存">一、虚拟内存</h1>
<h2 id="为什么要有虚拟内存">1.1 为什么要有虚拟内存？</h2>
<p>在单片机中是没有操作系统的，所以<strong>CPU</strong>会直接操作<strong>物理内存</strong>，而内存又是有限的，因此单片机中只能跑一个程序（因为内存地址直接暴露给应用程序，程序A本来给地址1xxx赋值后，程序B再给地址1xxx赋值，会导致数据被覆盖）</p>
<p>而为了能够同时运行多个程序，我们需要<strong>操作系统</strong>，操作系统会为每个程序分配一块<strong>虚拟内存（可以实现进程间的内存隔离、解决物理内存不够的问题）</strong>，这样每个程序都认为自己在独占物理内存，实际上是<strong>共享物理内存</strong></p>
<p>最终每个进程的<strong>虚拟内存</strong>落盘到<strong>物理内存</strong>会通过<strong>页表</strong>来映射实现</p>
<p>CPU中存的是程序对应的<strong>虚拟地址</strong>信息，然后通过<strong>CPU中的MMU（内存管理单元，负责把虚拟地址映射成物理地址）</strong>映射成<strong>物理地址</strong>，进而再通过地址总线去访问<strong>物理内存</strong></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/VirtualMemory.png" width="70%"></p>
<h2 id="虚拟内存">1.2 虚拟内存</h2>
<p>当一个程序运行时，会允许<strong>一部分加载到实际的物理内存</strong>，而暂时不用的部分则会存放在<strong>磁盘（外存，如硬盘的swap区域）</strong>上，因此允许程序虚拟内存大于物理内存大小</p>
<p>当执行到该进程的某部分代码出现<strong>缺页</strong>时，操作系统会产生一个<strong>缺页异常</strong>，并由用户态进入<strong>内核态</strong>将<strong>磁盘</strong>上的相关数据加载到<strong>物理内存</strong>中，然后再返回用户态继续执行</p>
<p>这种技术就是<strong>虚拟内存</strong>技术，可以根据<strong>页的大小</strong>（Linux下一般为<strong>4KB</strong>）将程序进行分割，然后不连续地加载到<strong>物理内存</strong>中</p>
<p><strong>虚拟内存的3个主要作用：</strong></p>
<ul>
<li>扩大内存大小：允许程序运行的内存超过物理内存大小</li>
<li>避免地址冲突：避免不同程序共同操作物理内存导致<strong>地址冲突</strong>（每个进程有自己的页表）</li>
<li>权限控制：内存访问根据页表隔离开不同进程</li>
</ul>
<h2 id="内存分页">1.3 内存分页</h2>
<p>在<strong>内存分页</strong>前还有<strong>内存分段</strong>，<strong>内存分段</strong>是将程序分为<strong>代码段、数据段、堆栈段</strong>等，它的好处是能产生连续的空间，但是<strong>内存分段</strong>会导致<strong>内存碎片</strong>问题，也就是大小不一的<strong>内存块</strong>会导致<strong>内存</strong>的<strong>利用率</strong>不高</p>
<p>因此衍生出了<strong>内存分页</strong>的方式，将程序<strong>按照固定大小的页</strong>进行分割，这种紧密的页表排列不会有<strong>外碎片</strong>的产生，很好地利用了宝贵的物理内存空间。但是由于最小单位是<strong>页</strong>，当不足一页时会补全一页，导致<strong>内部碎片</strong>的产生</p>
<p>在<strong>虚拟内存</strong>和<strong>物理内存</strong>之间通过存储在<strong>MMU</strong>中的<strong>页表</strong>进行映射</p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/MemoryPage.png" width="70%"></p>
<p>在单级分页中，会把<strong>虚拟地址</strong>分为</p>
<ul>
<li><strong>页号</strong>：用于索引<strong>页表</strong>中的<strong>页表项</strong>，用于查找<strong>物理内存</strong>中对应页的<strong>物理地址</strong></li>
<li><strong>页内偏移</strong>：用于定位<strong>页</strong>中的具体<strong>字节</strong>。偏移是相对量，所以在<strong>虚拟内存</strong>和<strong>物理内存</strong>中的偏移是一样的</li>
</ul>
<p>所以通过<strong>页表</strong>拿到<strong>物理地址</strong>后，再加上<strong>页内偏移</strong>就能得到具体的<strong>物理地址</strong></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/PageTable.png" width="70%"></p>
<p>在这种单级分页下</p>
<ul>
<li><strong>虚拟内存的页大小 == 物理内存的页大小</strong></li>
<li>而每个<strong>页表项</strong>有4byte(32位系统下)</li>
</ul>
<p>假设<strong>内存大小</strong>为<strong>2<sup>nbit<strong>，每个</strong>页表项<strong>的大小为</strong>2</sup>mbit</strong>，则表示总共有<strong>2<sup>n/2</sup>m
=
2<sup>(n-m)页数<strong>，因此需要有</strong>2</sup>(n-m)个页表项</strong>，也就是<strong>有(n-m)bit</strong>来记录对应的<strong>页号</strong></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/PageTableSize.png" width="70%"></p>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/AddrSwap.png" width="80%"></p>
<p>因此<strong>页表</strong>的大小是<strong>逻辑空间页数</strong>乘以<strong>页表项的大小(一个页表项占多少bits)</strong>，这种单级分页的方式会导致<strong>页表</strong>过大，因此在实际操作系统中会采用<strong>多级页表</strong>的方式</p>
<h2 id="多级页表">1.4 多级页表</h2>
<p>单级页表无法定位到某个<strong>进程</strong>，因此需要给整个逻辑空间的<strong>虚拟地址空间</strong>都分配<strong>页表（放在CPU中）</strong>，这样会导致<strong>页表</strong>过大(且每个进程都有自己的页表)，CPU无法放下，可以选择将<strong>页表</strong>放在<strong>内存</strong>中，而将经常访问的<strong>页表</strong>放在<strong>CPU的TLB中</strong>中</p>
<p>而<strong>二级页表</strong>的方式是通过将<strong>页号分为两部分</strong></p>
<ul>
<li>第一部分用于<strong>索引一级页表</strong>，通过<strong>一级页表</strong>找到<strong>二级页表</strong>的<strong>物理地址</strong></li>
<li>第二部分用于<strong>索引二级页表</strong>，通过<strong>二级页表</strong>找到<strong>实际物理地址</strong></li>
</ul>
<p>这样的话，<strong>页表</strong>的大小就变成了<strong>一级页表的大小 +
二级页表的大小</strong>，而<strong>一级页表中不存在的页</strong>则不会占用<strong>二级页表</strong>的空间，这样就减小了<strong>总页表</strong>的大小（页表还是放在<strong>内核态空间</strong>中）</p>
<p>在分级的机制下，假设只有 <code>20%</code>
的一级页表项被用到了，那么页表占用的内存空间就只有
<code>4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB</code>，这对比单级页表的
<code>4MB</code> 是不是一个巨大的节约？</p>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1ug411S7Da/?spm_id_from=333.337.search-card.all.click&amp;vd_source=fa61c94b4d0a0af186e3cb794e46eea9">二级页表的工作原理:为什么二级页表占用空间比一级页表小</a>
<a href="https://blog.csdn.net/weixin_43914604/article/details/105930570">3.1.9
OS之二级页表的原理和地址结构</a></p>
</blockquote>
<h2 id="页的换入换出">1.5 页的换入换出</h2>
<p>当程序运行时，<strong>内存空间不够</strong>时：</p>
<ul>
<li>操作系统会将<strong>正在运行的某个进程中不常用的页</strong>从<strong>物理内存</strong>中<strong>换出</strong>到<strong>磁盘(外存)</strong>上</li>
<li>然后将<strong>需要的页</strong>从<strong>磁盘</strong>上<strong>换入</strong>到<strong>物理内存</strong>中</li>
</ul>
<p><img src="/2024/05/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/PageSwap.png" width="70%"></p>
<p>页的置换算法通常包括</p>
<h1 id="二内存分配malloc">二、内存分配（malloc）</h1>
<p>在文章<a href="https://akirazheng.github.io/2024/04/20/C-%E5%BA%95%E5%B1%82%E5%AD%A6%E4%B9%A0/#/4-1-2-malloc%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6">内存池设计</a>中已经有详细的介绍，这里就不再赘述</p>
<h1 id="三mmap">三、mmap</h1>
<p><code>mmap</code>在文章<a href="https://akirazheng.github.io/2024/03/11/WebServer%E5%AD%A6%E4%B9%A06%EF%BC%9AHTTP%E8%BF%9E%E6%8E%A5%E5%A4%84%E7%90%86%E5%8F%8A%E6%8A%A5%E6%96%87%E6%9C%BA%E5%88%B6/#/%E5%85%AD%E3%80%81%E6%B5%85%E8%81%8A%E4%B8%80%E4%B8%8Bmmap%E5%BB%B6%E7%94%B3%E7%9A%84%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98">浅聊一下mmap延申的内存映射问题</a>中已经有详细的介绍，这里就不再赘述</p>
<blockquote>
<p>参考：<a href="https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">内存管理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统相关的Linux操作</title>
    <url>/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="一linux基础知识">一、Linux基础知识</h1>
<h2 id="linux下的目录结构">1.1 Linux下的目录结构</h2>
<p>Linux中可以用命令<code>df -h</code>查看磁盘的使用情况以及挂载点</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/disk_df.png" width="90%"></p>
<p>可以看到根节点<code>/</code>挂载在了虚拟机的磁盘<code>/dev/sda3</code>上，<code>/boot</code>挂载在了<code>/dev/sda1</code>上，然后通过命令<code>df -T</code>可以查看挂载点的文件系统类型</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/disk_df_T.png" width="90%"></p>
<p><code>/</code>的文件系统类型是<code>ext4</code>。这是一种常用的日志文件系统。</p>
<p>在根目录下，可以扩展出Linux的目录树状结构，如下：</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/linux_dir.png" width="90%"></p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/linux_dir2.png" width="90%"></p>
<h2 id="linux下的用户权限">1.2 Linux下的用户权限</h2>
<p>在Linux中可以有很多用户，但是只有<code>root</code>用户是<strong>超级用户</strong>，拥有最高权限，其它用户在各自的环境下文件放进自己的<strong>家目录</strong>下，其它用户不能访问，这样大大提高了Linux使用的安全性</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/userPrival.png" width="90%"></p>
<p><code>root</code>用户进入后，在<code>/home</code>目录下存放了所有用户的<strong>家目录</strong>信息</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/home_dir.png" width="90%"></p>
<h3 id="sudo切换用户">sudo：切换用户</h3>
<p><code>sudo</code>指令是Linux下的一个非常重要的指令，可以让普通用户在执行某些需要超级用户权限的指令时，临时提升权限，而不用切换到<code>root</code>用户</p>
<p>系统管理员可以在<code>/etc/sudoers</code>文件中配置哪些用户可以使用<code>sudo</code>指令</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/sudoUser.png" width="90%"></p>
<p><code>root</code>用户可以直接使用<code>sudo username</code>切换到其它用户，而不用输入密码</p>
<h3 id="su切换用户">su：切换用户</h3>
<p><code>su</code>指令是切换用户的指令，可以切换到其它用户，但是需要输入密码</p>
<p><code>su -</code>可以切换到<code>root</code>用户</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/su.png" width="90%"></p>
<h1 id="三linux下的指令集合">三、Linux下的指令集合</h1>
<p>Linux可以通过<strong>shell终端</strong>来执行操作指令</p>
<p>对于终端指令解析：</p>
<ul>
<li><code>root</code>：用户名</li>
<li><code>AkiraEdu01</code>：主机名</li>
<li><code>~</code>：当前目录
<ul>
<li><code>root</code>用户的<code>~</code>目录是<code>/root</code></li>
<li>普通用户的<code>~</code>目录是<code>/home</code></li>
</ul></li>
<li><code>$</code>：代表当前是普通用户</li>
<li><code>#</code>：代表当前是<code>root</code>用户</li>
</ul>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/shell.png" width="90%"></p>
<h2 id="软件安装压缩和解压">3.1 软件安装、压缩和解压</h2>
<h3 id="linux中的软件安装">Linux中的软件安装：</h3>
<ul>
<li><strong>CentOS</strong>：<code>yum</code>指令
<ul>
<li><code>sudo yum install 软件名</code></li>
</ul></li>
<li><strong>Ubuntu</strong>：<code>apt-get</code>指令
<ul>
<li><code>sudo apt-get install 软件名</code></li>
</ul></li>
</ul>
<p>通过HTTP或FTP地址直接从终端控制台下载文件，<code>wget</code>
非常稳定，如果是由于网络原因下载失败， <code>wget</code>
会不断尝试，直到整个文件下载完毕。：</p>
<ul>
<li><code>wget http://www.xxx.com/xxx.tar.gz</code>：下载文件
<ul>
<li><code>-c</code>：继续中断了的文件的下载</li>
</ul></li>
</ul>
<h3 id="tar压缩和解压">tar：压缩和解压</h3>
<p>压缩和解压都是用<code>tar</code>指令</p>
<ul>
<li><code>tar -cvf test.tar test</code>：将<code>test</code>目录压缩为<code>test.tar</code>
<ul>
<li><code>-c</code>：创建压缩文件</li>
<li><code>-v</code>：显示详细信息</li>
<li><code>-f</code>：指定压缩文件名</li>
</ul></li>
<li><code>tar -czvf test.tar.gz test</code>：将<code>test</code>目录压缩为<code>test.tar.gz</code>
<ul>
<li><code>-z</code>：使用<code>gzip</code>压缩</li>
</ul></li>
<li><code>tar -xvf test.tar</code>：解压<code>test.tar</code>文件
<ul>
<li><code>-x</code>：解压文件</li>
</ul></li>
</ul>
<h2 id="文件和目录增删改查">3.2 文件和目录增删改查</h2>
<h3 id="pwd查看当前目录">pwd：查看当前目录</h3>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/pwd.png" width="90%"></p>
<h3 id="ls列出当前目录下的文件">ls：列出当前目录下的文件</h3>
<p><strong>常用参数：</strong></p>
<ul>
<li><code>-a</code>：列出所有文件，包括隐藏文件</li>
<li><code>-l</code>：列出详细信息（包括文件权限、文件所有者、文件大小、文件创建时间等）</li>
<li><code>-h</code>：人性化显示文件大小</li>
<li><code>-t</code>：按照文件修改时间排序</li>
</ul>
<h3 id="cd切换目录">cd：切换目录</h3>
<p><strong>常用指令：</strong></p>
<ul>
<li><code>cd</code>：切换到当前用户的家目录</li>
<li><code>cd ~</code>：切换到当前用户的家目录</li>
<li><code>cd /</code>：切换到根目录</li>
<li><code>cd ..</code>：切换到上一级目录</li>
<li><code>cd ./test</code>：切换到当前目录下的<code>test</code>目录</li>
</ul>
<p><code>cd</code>指令可以使用补全功能，按<code>Tab</code>键可以自动补全路径：</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/cd_tab.png" width="90%"></p>
<h3 id="mkdir创建目录">mkdir：创建目录</h3>
<p><code>mkdir test</code>：在当前目录下创建<code>test</code>目录</p>
<h3 id="rmdir删除目录">rmdir：删除目录</h3>
<p><code>rmdir test</code>：删除当前目录下的<code>test</code>目录</p>
<h3 id="touch创建文件">touch：创建文件</h3>
<p><code>touch test.txt</code>：在当前目录下创建<code>test.txt</code>文件</p>
<h3 id="rm删除文件或目录">rm：删除文件或目录</h3>
<p>该指令是一个非常危险的指令，删除后无法恢复</p>
<p><code>rm test.txt</code>：删除当前目录下的<code>test.txt</code>文件</p>
<p><code>rm -rf test</code>：删除<code>test</code>目录(<code>-r</code>表示递归删除，<code>-f</code>表示强制删除)</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/make-remove.png" width="90%"></p>
<h3 id="cp复制文件或目录">cp：复制文件或目录</h3>
<p><code>cp test.txt test2.txt</code>：复制<code>test.txt</code>文件为<code>test2.txt</code></p>
<p><code>cp -r test test2</code>：复制<code>test</code>目录为<code>test2</code>目录</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/cp.png" width="90%"></p>
<h3 id="mv移动文件或目录">mv：移动文件或目录</h3>
<p><code>mv test.txt ./test</code>：将<code>test.txt</code>文件移动到<code>./test</code>目录下</p>
<p><code>mv test test2</code>：将<code>test</code>目录重命名为<code>test2</code></p>
<p><code>mv ./test ./test2</code>：将<code>./test</code>目录移动到<code>./test2</code>目录下</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/mv.png" width="90%"></p>
<h3 id="find查找文件完全符合">find：查找文件（完全符合）</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>&lt;何处&gt;</code>：查找的目录</li>
<li><code>&lt;何物&gt;</code>：查找的什么？（文件名<code>-name test.txt</code>、文件类型<code>-type</code>、文件大小<code>-size</code>）</li>
<li><code>&lt;做什么&gt;</code>：查找到后做什么？默认不写的话只会显示找到的文件（打印<code>-print</code>、删除<code>-delete</code>）</li>
</ul>
<p><code>find / -name test.txt</code>：在根目录下查找<code>test.txt</code>文件（这里就没有指定做什么）</p>
<p><code>find / -name test.txt -delete</code>：在根目录下查找<code>test.txt</code>文件并删除</p>
<p><code>find ./ -name *.txt</code>：在当前目录下查找所有的<code>.txt</code>文件</p>
<h3 id="locate查找文件模糊匹配">locate：查找文件（模糊匹配）</h3>
<p>按照文件数据库去匹配查找而不是全盘查找，因此数据库还未更新的话是找不到的</p>
<p>所以一般先执行<code>updatedb</code>命令更新数据库</p>
<p><code>locate test.txt</code>：查找文件名中包含<code>test.txt</code>的文件</p>
<p><code>locate *.txt</code>：查找所有的<code>.txt</code>文件</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/search.png" width="90%"></p>
<h2 id="文本操作">3.3 文本操作</h2>
<h3 id="cat查看小文件内容">cat：查看小文件内容</h3>
<p><code>cat</code>指令会一次性显示文件的<strong>全部内容</strong>，所以对于大文件不适用</p>
<p><code>cat test.txt</code>：查看<code>test.txt</code>文件的内容</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/cat.png" width="90%"></p>
<h3 id="less分页查看文件内容">less：分页查看文件内容</h3>
<p><code>less test.txt</code>：查看<code>test.txt</code>文件的内容，按<code>空格</code>键翻页，按<code>q</code>键退出</p>
<ul>
<li>回车键：向下翻一行</li>
<li><code>y</code>：向上翻一行</li>
<li>空格键：向下翻页</li>
<li><code>b</code>：向上翻页</li>
<li><code>q</code>：退出</li>
<li><code>=</code>：显示当前行号</li>
<li><code>/</code>：搜索(输入关键字后按<code>Enter</code>键)
<ul>
<li><code>/^the</code>：搜索以 "the" 开头的行</li>
<li><code>/pattern1|pattern2</code>：搜索包含 pattern1 或 pattern2
的行</li>
</ul></li>
</ul>
<h3 id="vim编辑器编辑文件">vim编辑器：编辑文件</h3>
<h1 id="四linux下的操作系统和网络操作">四、Linux下的操作系统和网络操作</h1>
<h2 id="系统操作">4.1 系统操作</h2>
<h3 id="查看进程pstopkill">查看进程：ps、top、kill</h3>
<ul>
<li><p><code>ps</code>：<strong>静态查看</strong>当前系统运行的进程（快照，不会实时更新）
<img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/ps.png" width="90%"></p>
<ul>
<li><code>ps -ef</code>：查看所有进程</li>
<li><code>ps -aux | less</code>：按CPU和内存使用率排序</li>
</ul></li>
<li><p><code>top</code>：<strong>动态</strong>查看当前系统运行的进程（每5s实时更新）
<img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/top.png" width="90%"></p>
<p>展示的这些进程是按照使用处理器 <strong>CPU</strong>
的使用率来排序的</p>
<p><code>q</code>：退出</p>
<p><strong>结果解析：</strong></p>
<ul>
<li><code>PID</code>：进程ID</li>
<li><code>USER</code>：进程所有者</li>
<li><code>PR</code>：进程优先级</li>
<li><code>VIRT</code>：使用的虚拟内存</li>
<li><code>RES</code>：使用的物理内存</li>
<li><code>SHR</code>：使用的共享内存</li>
<li><code>S</code>：进程状态(S=睡眠，R=运行，Z=僵尸进程)</li>
<li><code>%CPU</code>：CPU使用率</li>
<li><code>%MEM</code>：RAM使用率</li>
<li><code>TIME+</code>：进程运行时间</li>
<li><code>COMMAND</code>：进程名称</li>
</ul></li>
<li><p><code>kill</code>：杀死进程</p>
<ul>
<li><code>kill 进程号PID</code>：杀死进程</li>
<li><code>kill -9 进程号PID</code>：强制杀死进程</li>
</ul></li>
</ul>
<h3 id="管理进程systemctl">管理进程：systemctl</h3>
<h3 id="reboot重启系统">reboot：重启系统</h3>
<p>需要<code>root</code>权限</p>
<h3 id="shutdown关机">shutdown：关机</h3>
<p>需要<code>root</code>权限</p>
<ul>
<li><code>shutdown -h now</code>：立即关机</li>
<li><code>shutdown -h 10</code>：10分钟后关机</li>
</ul>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/shutdown.png" width="90%"></p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/shutdown2.png" width="90%"></p>
<h3 id="poweroff关机">poweroff：关机</h3>
<p>不需要<code>root</code>权限</p>
<h2 id="网络操作">4.2 网络操作</h2>
<h3 id="查看网络状态ifconfig">查看网络状态：ifconfig</h3>
<p>Windows下的<code>ipconfig</code>在Linux下是<code>ifconfig</code>，可以查看网络接口的信息，包括IP地址、MAC地址等</p>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/ifconfig.png" width="90%"></p>
<p>其中<code>lo</code>是本地回环接口，IP地址是<code>127。0.0.1</code>，每台电脑都应该有这个接口，它对应着<code>localhost</code>，用于本地测试，在某些需求下，我们要连接自己的服务器进行测试，而又不想让局域网或者外网的用户访问，就可以使用这个接口（比如对某个本地运行的项目，我们可以通过<code>localhost</code>或者<code>127.0.0.1:port</code>来访问自己的网站，且只能自己看到）</p>
<h3 id="连接远程服务器ssh">连接远程服务器：ssh</h3>
<p>我们其实在使用<strong>github</strong>或者<strong>gitee</strong>的时候，经常通过配置<code>ssh</code>来连接远程服务器，这样就不用每次都输入密码了，那么它的原理是什么呢？</p>
<p>我们发现<code>Github</code>项目都会提供两个网址，一个是<code>https</code>的，一个是<code>ssh</code>的，所以可以联想到，<code>ssh</code>是一种类似于HTTPS的<strong>安全网络协议</strong>，它可以在不安全的网络中为网络服务提供安全的传输环境</p>
<p>我们之前在配置<strong>hexo</strong>的时候，通过<code>ssh</code>连接到<code>github</code>，这样每次部署到<code>github</code>的时候就不用输入密码了，在实现时，我们在本机客户端会生成两个密钥文件：</p>
<ul>
<li><code>id_rsa</code>：私钥</li>
<li><code>id_rsa.pub</code>：公钥</li>
</ul>
<p>其中<strong>公钥</strong>会被传到服务器配置中，也就是我们在实际操作时将<strong>公钥</strong>添加到<code>github</code>的<code>SSH and GPG keys</code>中</p>
<h1 id="五linux下的进阶问题">五、Linux下的进阶问题</h1>
<h2 id="如何在linux中找到cpu占用高的进程">5.1
如何在Linux中找到CPU占用高的进程</h2>
<p>前面讲到Linux中的<code>top</code>和<code>ps</code>指令都可以查看进程列表中的CPU占用率，但是更倾向于用<strong>动态实时更新的top指令</strong></p>
<p>而用<code>ps</code>的话，虽然只能看静态信息，但是可以很方便地过滤掉一些不需要的列信息，比如只看PID、CPU占用率、运行时间和进程名称：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -eo pid,pcpu,time,comm | sort -k 2 -nr | head -n 10</span><br></pre></td></tr></table></figure>
<p>这个指令的意思是：</p>
<ul>
<li><code>-e</code>：显示所有进程</li>
<li><code>-o</code>：指定输出的列</li>
<li>只显示指定的列：<code>pid</code>、<code>pcpu</code>、<code>time</code>、<code>comm</code></li>
<li><code>sort -k 2 -nr</code>：按照第二列<code>pcpu</code>排序，<code>-n</code>表示按照数字排序，<code>-r</code>表示降序</li>
<li><code>head -n 10</code>：只显示前10行（top10）</li>
</ul>
<p><img src="/2024/05/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3%E7%9A%84Linux%E6%93%8D%E4%BD%9C/ps_sort.png" width="90%"></p>
<h2 id="如何在linux中排查占用率100的问题">5.2
如何在Linux中排查占用率100%的问题</h2>
<p><strong>1）top指令查看当前CPU占用率最高的进程PID</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure>
<p><strong>2）top查看该进程下各线程的CPU占用率</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -H -p 进程号PID</span><br></pre></td></tr></table></figure>
<p><strong>3）执行<code>pstack</code>脚本查看当前线程的堆栈信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pstack 进程号PID</span><br></pre></td></tr></table></figure>
<p><strong>4）分析原因</strong></p>
<p>一般从<strong>死锁</strong>、<strong>自旋(锁)时间过长</strong>、<strong>死循环</strong>、<strong>内存泄漏</strong>、<strong>I/O日志操作过于频繁（少打印DEBUG的信息）</strong>等方面排查</p>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/carsonzhu/p/17109893.html">Linux下C/C++程序CPU问题分析及优化心得</a>
参考：<a href="https://blog.csdn.net/weixin_38416696/article/details/125083718">c++程序
cpu占用过高排查方法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>文件描述符</title>
    <url>/2024/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="一内核缓冲区page-cache">一、内核缓冲区Page Cache</h1>
<p>进程在调用write函数写入文件描述符时，其实不是直接写入文件，而是</p>
<ul>
<li>先<strong>中段</strong>到内核空间</li>
<li>然后再由内核空间写入<strong>内核缓冲区Page
Cache</strong>(因为内核缓冲区相较于磁盘I/O速度更快)</li>
<li>最后内核会在适当的时机<strong>将内核缓冲区的内容写入磁盘</strong></li>
</ul>
<p>通过这种机制，可以<strong>减少操作磁盘I/O的次数</strong>，提高磁盘I/O效率（当然也可以通过<code>mmap</code>函数将文件映射到内存中，这样就可以直接操作内存，内存中的操作既快速，又不用经过内核态&lt;--&gt;用户态的切换，更加高效）</p>
<p>如果想立即将内核缓冲区的内容写入磁盘，可以调用<code>fsync</code>函数（调用<code>fflush</code>函数也会将缓冲区的内容强制写入磁盘，而不等待缓冲区满再刷新）</p>
<h1 id="二零拷贝技术mmap">二、零拷贝技术：mmap</h1>
<p>磁盘相对于计算机中的CPU、内存来说，属于慢速设备，因此针对磁盘的优化，有我们上述讲到的<strong>通过内核态中的缓冲区Page
Cache减少I/O访问次数</strong>，还有通过<strong>零拷贝技术</strong>来减少数据在内核态和用户态之间的拷贝次数</p>
<p>如果通过中断的方式，当我们发生系统调用<code>read</code>时，内核会将<strong>磁盘中的数据拷贝到内核缓冲区(第一次拷贝)</strong>，然后再将<strong>内核缓冲区的数据拷贝到用户缓冲区</strong>，这样就发生了两次拷贝</p>
<p><img src="/2024/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/two_copy.png" width="80%"></p>
<p>也就是说在大量数据拷贝过程都需要<strong>CPU</strong>参与搬运，这样会浪费CPU资源，降低效率</p>
<p>因此进一步可以通过<strong>DMA直接内存访问技术</strong>进行优化：</p>
<ul>
<li><p>在不占用CPU资源的情况下(此时CPU可以执行其它任务)，将数据从磁盘拷贝到内核缓冲区</p></li>
<li><p>当DMA读取了足够多的数据，再通知<strong>CPU</strong>将数据从内核缓冲区拷贝到用户缓冲区，这样就只发生了一次拷贝</p></li>
</ul>
<p><img src="/2024/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/one_copy.png" width="80%"></p>
<p>即使采用<strong>DMA</strong>技术，还是需要通过<strong>CPU</strong>进行一次拷贝，具体通过<code>read</code>和<code>write</code>的流程如下所示(<strong>各发生2次用户态&lt;--&gt;内核态的上下文切换</strong>，一次切换需要耗时几十纳秒到几微秒；以及<strong>各发生一次DMA拷贝+一次CPU拷贝</strong>)：</p>
<p>'''shell read(file, buffer, size) write(socketfd, buffer, size)
'''</p>
<p><img src="/2024/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/read_write.png" width="80%"></p>
<p>而实际上，多次拷贝是没必要的，我们可以通过<code>mmap</code>函数将文件映射到内存中，使<code>read</code>和<code>write</code>直接操作<strong>共享的内核缓冲区</strong>，这样就可以<strong>减少一次拷贝，但也不是完全的零拷贝</strong>，具体流程如下：</p>
<p>'''shell buf = mmap(file, size) write(socketfd, buf, size) '''</p>
<p><img src="/2024/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/mmap.png" width="80%"></p>
<p>真正的零拷贝是Linux上提供的<code>sendfile</code>函数，它可以直接将文件描述符之间的数据拷贝，而<strong>不需要经过用户态，完全存在内核态中，只经过2次拷贝</strong>，具体流程如下：</p>
<p>'''shell sendfile(out_fd, in_fd, offset, size) '''</p>
<p><img src="/2024/05/18/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/sendfile.png" width="80%"></p>
<blockquote>
<p>参考：<a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-dma-%E6%8A%80%E6%9C%AF">什么是零拷贝？</a></p>
</blockquote>
<h1 id="三io多路复用技术">三、I/O多路复用技术</h1>
<h2 id="linux中的五中io模型">3.1 Linux中的五中I/O模型</h2>
<ul>
<li><strong>阻塞I/O</strong>：调用<code>socket.read()</code>或<code>socket.write()</code>时，如果没有数据可读或写，会一直阻塞等待，直到有数据可读或写
<ul>
<li>适合计算密集型，因为计算密集型消耗的是CPU资源</li>
</ul></li>
<li><strong>非阻塞I/O</strong>：不断轮训查看数据是否准备好，所以非阻塞I/O也不会交出CPU
<ul>
<li>适合传视频，一直占用CPU减少线程切换的成本</li>
</ul></li>
<li><strong>I/O复用</strong>：通过<code>select</code>、<code>poll</code>、<code>epoll</code>等函数，可以同时监听多个文件描述符，当其中任何一个文件描述符就绪时，就可以进行读写操作（监听的文件描述符本身也是阻塞的）</li>
<li><strong>信号驱动I/O</strong>：通过信号来通知应用程序I/O已经完成</li>
<li><strong>异步I/O</strong>：通过<code>aio_read</code>、<code>aio_write</code>等函数，可以在I/O操作完成后通知应用程序（应用程序发起I/O后可以直接进行其它操作，不用等待I/O完成）</li>
</ul>
<p>在文章<a href="https://akirazheng.github.io/2024/03/04/WebServer%E5%AD%A6%E4%B9%A03%EF%BC%9Asocket%E7%BC%96%E7%A8%8B%E4%B8%8Eepoll%E5%AE%9E%E7%8E%B0I-O%E5%A4%8D%E7%94%A8/#/%E4%BA%8C%E3%80%81I-O%E5%A4%8D%E7%94%A8">WebServer学习3：socket编程与epoll实现I/O复用</a>中已经有详细介绍，这里不再赘述</p>
<h1 id="四事件驱动模型">四、事件驱动模型</h1>
<p>在文章<a href="https://akirazheng.github.io/2024/03/05/WebServer%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%B9%B6%E5%8F%91%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%BC%8FReactor%E5%92%8CProactor/">WebServer学习4：并发事件驱动模式Reactor和Proactor</a>中已经有详细介绍，这里不再赘述</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统结构及进程管理</title>
    <url>/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="一cpu执行过程">一、CPU执行过程</h1>
<h2 id="cpu基本硬件结构">1.1 CPU基本硬件结构</h2>
<p>我们直到，计算机主要是由<strong>CPU、内存、I/O设备</strong>组成的，操作速度<strong>CPU
Cache &gt; 内存 &gt; 硬盘</strong></p>
<ul>
<li>CPU Cache有三级缓存，分别是<strong>L1 &gt; L2 &gt;
L3</strong>，L1速度最快、容量最小、价格最昂贵</li>
</ul>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Computer_struct.png" width="80%"></p>
<p>而<strong>CPU</strong>是计算机的核心部件，它负责<strong>执行指令、控制操作</strong>等，其执行速度极快，且速度与时钟周期息息相关。CPU的基本硬件结构如下：</p>
<ul>
<li><strong>寄存器</strong>：CPU内部的高速存储器，用于缓存指令、数据等。
<ul>
<li><strong>通用寄存器</strong>：存放<strong>数据</strong></li>
<li><strong>程序计数器</strong>：存放下一条指令的<strong>地址</strong></li>
<li><strong>指令寄存器</strong>：存放当前<strong>指令</strong></li>
</ul></li>
<li><strong>逻辑单元ALU</strong>：负责<strong>执行算术运算、逻辑运算、数据传输、条件分支等</strong></li>
<li><strong>控制单元</strong>：负责<strong>控制指令的执行</strong>
<ul>
<li>负责按照地址从内存中<strong>取出指令</strong></li>
<li>负责<strong>跳转</strong>操作</li>
</ul></li>
</ul>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/CPU_Struct.png"></p>
<h2 id="cpu寻址与位宽的关系">1.2 CPU寻址与位宽的关系</h2>
<h3 id="位宽">1.2.1 位宽</h3>
<p><strong>位宽</strong>是指CPU<strong>一个时间周期</strong>能处理的<strong>数据位数</strong>，例如<strong>32位</strong>或<strong>64位</strong>，位宽越大，CPU处理数据的能力越强，但同时也会增加成本。</p>
<h3 id="寻址">1.2.2 寻址</h3>
<p><strong>寻址</strong>是指CPU访问内存的方式，是由<strong>地址总线</strong>决定的，因此<strong>寻址</strong>能力与<strong>位宽</strong>是无关的，因为位宽管的是<strong>数据</strong>。</p>
<h3 id="位宽与寻址的关系">1.2.3 位宽与寻址的关系</h3>
<p>场景：</p>
<ul>
<li>当CPU需要从<strong>内存</strong>中读取数据到<strong>寄存器</strong>
或者 <strong>写入数据</strong>到物理内存时</li>
</ul>
<p>流程：</p>
<ul>
<li>CPU会先通过<strong>地址总线</strong>指定需要访问的<strong>物理内存地址</strong></li>
<li>在指定的<strong>物理内存地址</strong>通过<strong>数据总线</strong>进行<strong>读取</strong>或<strong>写入</strong>操作</li>
</ul>
<h2 id="cpu执行指令过程">1.3 CPU执行指令过程</h2>
<p>CPU执行指令的<strong>一个指令周期</strong>过程如下：</p>
<ul>
<li>step1：CPU读取<strong>程序计数器</strong>中的<strong>指令地址</strong>（内存地址）</li>
<li>step2：CPU根据指令地址，交由<strong>控制单元</strong>操作<strong>地址总线</strong>去访问指定内存地址，读取指令</li>
<li>step3：CPU将读取到的指令存放到<strong>指令寄存器</strong>中</li>
<li>step4：<strong>程序计数器</strong>完成上述操作后，自增指向下一条指令，其中自增的步长（字节）取决于<strong>CPU位宽</strong>，一般为<strong>32位</strong>或<strong>64位</strong></li>
<li>step5：CPU根据<strong>指令寄存器</strong>中的指令，解析指令类型和参数，对于<strong>计算指令</strong>，将参数从<strong>通用寄存器</strong>中取出，交由<strong>逻辑运算单元ALU</strong>执行计算</li>
</ul>
<h1 id="二用户态与内核态">二、用户态与内核态</h1>
<h2 id="用户态与内核态">2.1 用户态与内核态</h2>
<p>OS中的<strong>内存</strong>根据<strong>权限</strong>划分为两个空间：</p>
<ul>
<li><strong>用户空间（User
Space）</strong>：用户程序运行的空间（权限小，执行普通操作）</li>
<li><strong>内核空间（Kernel
Space）</strong>：操作系统运行的空间（权限大，执行访问磁盘、内存分配、网卡、声卡等敏感操作需要进行安全校验）
-<strong>内核态是用于应用程序跟操作系统、硬件连接的桥梁</strong>，进行<strong>系统调用</strong>、<strong>中断处理</strong>等操作。拥有最高级别的操作权限，可以直接访问如<strong>网卡、硬盘、内存</strong>等资源</li>
</ul>
<p>一个运行中的<strong>进程/程序</strong>，在执行中有可能处于<strong>用户态</strong>或者<strong>内核态</strong>，因此这里就涉及了两个空间之间的切换：</p>
<ul>
<li><strong>用户态---&gt;内核态</strong>：当用户程序需要进行<strong>外部资源申请</strong>时，需要切换到<strong>内核态</strong>，一般有以下几种情况：
<ul>
<li><strong>系统调用</strong>：用户程序通过<strong>系统调用</strong>请求操作系统提供服务（<strong>软中断</strong>）</li>
<li><strong>异常</strong>：用户程序执行过程中出现<strong>异常</strong>，如<strong>除零操作</strong></li>
<li><strong>中断</strong>：外部设备发生<strong>中断</strong>，需要CPU处理</li>
</ul></li>
</ul>
<h3 id="系统调用">2.1.1 系统调用</h3>
<p>一次系统调用一般会触发<strong>两次CPU上下文切换</strong>：</p>
<ul>
<li>第一次是<strong>用户态-&gt;内核态</strong>，要将<strong>寄存器、堆栈信息等</strong>保存到<strong>内核栈</strong>中，用于切回来时程序的恢复</li>
<li>第二次是<strong>内核态-&gt;用户态</strong>，要将<strong>内核栈</strong>中的信息恢复到<strong>用户栈</strong>中，用于程序的继续执行</li>
</ul>
<p><strong>1）系统调用的类型</strong></p>
<p><strong>系统调用</strong>一般有以下几种：</p>
<ul>
<li><strong>进程控制</strong>：如创建进程(<code>fork</code>)、终止进程(<code>exit</code>)</li>
<li><strong>文件操作</strong>：如打开文件(<code>open</code>)、读写文件(<code>read/write</code>)、关闭文件(<code>close</code>)</li>
<li><strong>设备（外设）操作</strong>：如读写设备(<code>read/write</code>)</li>
<li><strong>通信</strong>：如创建管道(<code>pipe</code>)、消息队列(<code>msgget</code>)、<code>mmap</code></li>
</ul>
<p>以<strong>申请内存（malloc）</strong>为例，当<code>C++</code>中调用<code>malloc</code>函数时，实际上会执行<strong>系统调用</strong>：</p>
<ul>
<li><strong>brk</strong>：对于较小的内存申请，会调用<code>brk</code>系统调用</li>
<li><strong>mmap</strong>：对于较大的内存申请，会调用<code>mmap</code>，<code>mmap</code>申请的是<strong>虚拟内存</strong>而不是<strong>物理内存</strong>，当出现<strong>第一次访问</strong>时，会发现该处的<strong>虚拟内存</strong>没有映射到<strong>物理内存</strong>，此时会发生<strong>缺页中断</strong>，操作系统才会将<strong>虚拟内存</strong>映射到<strong>物理内存</strong>中</li>
</ul>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/user_kernal_state.png" width="80%"></p>
<p><strong>2）系统调用的过程</strong></p>
<p>正常情况下，程序是运行在<strong>用户态</strong>内存空间中的</p>
<p>当程序需要执行<strong>系统调用</strong>时，会发现其<strong>权限</strong>不够，此时会产生<strong>中断Trap</strong>（切换到内核态是通过<strong>中断</strong>实现的）</p>
<p>然后CPU跳转到<strong>内核空间</strong>执行<strong>系统调用</strong></p>
<p>在内核态处理完后，再次产生<strong>中断Trap</strong>，并将<strong>系统调用</strong>的结果返回给<strong>用户空间</strong></p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/User_Kernel.png" width="80%"></p>
<h3 id="中断">2.1.2 中断</h3>
<p><strong>1）中断的概念</strong></p>
<p><strong>中断</strong>是指CPU在执行程序时，由于<strong>外部事件</strong>的发生（通常由IO设备触发），当CPU收到<strong>中断号</strong>时，<strong>CPU暂停当前程序的执行</strong>，转而去执行相应的<strong>中断处理程序</strong>，处理完后再返回原来的程序继续执行。</p>
<p>操作系统会注册<strong>中断号</strong>以及其对应的<strong>中断处理程序</strong>（也就是注册后存在中断向量表中），当中断发生时，CPU会根据<strong>中断号</strong>找到对应的<strong>中断处理程序</strong>，并执行。</p>
<p>其中中断向量表的一个节点如下：</p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/CruptTable.png" width="50%"></p>
<p>具体执行中断的步骤如下（以键盘按下为例）：</p>
<ul>
<li><strong>硬件</strong>：键盘按下，会通过<strong>中断控制器</strong>发送<strong>中断信号
n</strong>给<strong>CPU</strong></li>
<li><strong>CPU</strong>：收到<strong>中断信号
n</strong>后，会去<strong>中断向量表</strong>中寻找第 n
个<strong>中断描述符</strong>，从中断描述符中找到<strong>中断处理程序的地址</strong></li>
<li><strong>CPU</strong>：通过<strong>压栈操作</strong>保存当前程序的<strong>状态（原来的程序地址、原来的程序堆栈、原来的标志位）</strong>，然后跳转到<strong>中断处理程序</strong>的地址执行</li>
<li>中断处理程序执行完后，再通过<strong>出栈操作</strong>恢复原来的程序状态，继续执行原来的程序</li>
</ul>
<p><strong>2）操作系统需要中断的原因</strong></p>
<ul>
<li>针对硬件中断：设想一下，如果没有中断机制，那么CPU在执行程序时，还要不断的去<strong>轮询外设</strong>是否有数据到来，导致CPU的<strong>利用率</strong>非常低。</li>
<li>针对软件中断：如果一个应用程序触发了某个操作，需要从<strong>用户态</strong>切换到<strong>内核态</strong>，如果没有<strong>中断机制</strong>，那么CPU会进入<strong>盲等待</strong>状态（等待寄存器空闲）。(<strong>中断机制</strong>可以让CPU在等待时，去执行其他程序)</li>
</ul>
<p><strong>3）CPU触发中断的三种方式</strong></p>
<ul>
<li>通过<strong>中断控制器（外设）</strong>给 CPU 的 <code>INTR</code>
引脚发送信号，CPU 从中断控制器的一个端口上读取中断号。
<ul>
<li>比如按下键盘的一个按键，最终会给到 CPU 一个 0x21 中断号。</li>
</ul></li>
<li>CPU
执行某条指令发现了<strong>异常</strong>，会<strong>自己触发并给自己一个中断号</strong>
<ul>
<li>比如执行到了无效指令，CPU 会给自己一个 0x06 的中断号。</li>
</ul></li>
<li><strong>系统调用</strong>执行 <code>INT n</code> 指令，会直接给 CPU
一个中断号 n
<ul>
<li>比如触发了 Linux 的<strong>系统调用</strong>，实际上就是执行了
<strong>INT 0x80</strong> 指令，那么 CPU 收到的就是一个 0x80
中断号。</li>
</ul></li>
</ul>
<p><strong>4）硬件中断和软件中断</strong></p>
<p>硬件中断和软件中断都属于<strong>硬中断</strong>，只是触发方式不同。</p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Currpt.png" width="80%"></p>
<p><strong>5）硬中断和软中断</strong></p>
<p>由于中断会打断内核中进程的正常调度运行，所以要求中断服务程序尽可能的短小精悍；但是在实际系统中，当中断到来时，要完成工作往往进行大量的耗时处理。</p>
<p>所以一般 Linux
会把中断分成上下两半部分执行，<strong>上半部分处理最简单的逻辑（硬中断）</strong>，下半部分直接丢给一个<strong>软中断</strong>异步处理。</p>
<p>比如我们进行<strong>网卡</strong>的<strong>数据包</strong>处理时：</p>
<ul>
<li>当网卡收到一个数据包时，将<strong>数据包</strong>放到<strong>内核</strong>的<strong>缓冲区</strong>中，然后会触发一个<strong>硬中断</strong></li>
<li>硬件中断告诉 CPU 有数据包到来并触发一个<strong>软中断</strong></li>
<li><strong>软中断</strong>会在<strong>内核态</strong>异步处理<strong>数据包</strong>的<strong>解析</strong>（如完整性、校验等）</li>
</ul>
<p><strong>硬中断</strong></p>
<p>上述<strong>3）</strong>中提到的三种方式全是<strong>硬中断</strong>（包括中断、异常以及
INT
指令这种软件中断）。整个中断机制是<strong>纯硬件实现的逻辑</strong>，不管触发它的是谁，所以通通叫硬中断。</p>
<p>微观上来说，CPU 在每一个指令周期的最后，都会<strong>留一个 CPU
周期去查看是否有中断</strong>，<strong>硬中断</strong>处理耗时短的操作</p>
<p><strong>软中断</strong></p>
<p><strong>软中断</strong>是处理<strong>硬中断</strong>后，延时处理具体的<strong>耗时</strong>的工作。</p>
<p><strong>主要区别</strong></p>
<ul>
<li><strong>硬中断</strong>是由硬件设备直接触发，通常是即时的，需要<strong>快速响应</strong>。</li>
<li><strong>软中断</strong>是由<strong>内核代码</strong>触发，可以是<strong>延迟的</strong>，用于处理那些不需要立即响应的任务。</li>
</ul>
<h3 id="异常">2.1.3 异常</h3>
<p><strong>异常</strong>是指程序在执行过程中，由于<strong>程序错误</strong>或<strong>CPU故障</strong>等原因，导致<strong>程序无法继续执行</strong>，<strong>CPU</strong>根据异常类型查找<strong>异常向量表</strong>，找到对应的异常处理程序，进行处理。</p>
<h2 id="用户态与内核态的切换的具体实现">2.2
用户态与内核态的切换的具体实现</h2>
<p>以<strong>Linux系统</strong>系统为例，操作系统会为每个进程分配出<strong>内核空间</strong>和<strong>用户空间</strong></p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/memory_type.png" width="30%"></p>
<p>当发生切换时：</p>
<ul>
<li><p><strong>CPU</strong>会涉及<strong>上下文切换</strong>，将<strong>用户态</strong>原来在<strong>CPU中</strong>的<strong>程序计数器</strong>和<strong>栈指针</strong>等寄存器的值保存到<strong>内核态</strong>的<strong>内核栈</strong>中，以便最后<strong>内核态</strong>执行完逐步出栈后，能够恢复到<strong>用户态</strong>的执行状态</p></li>
<li><p>保存完后再更新<strong>CPU</strong>的<strong>程序计数器</strong>和<strong>栈指针</strong>等寄存器的值，将其变为<strong>内核态</strong>的值</p></li>
<li><p>然后才<strong>跳转</strong>到<strong>内核态</strong>执行<strong>系统调用</strong></p></li>
<li><p><strong>系统调用</strong>结束后再次进行<strong>上下文切换</strong>，恢复<strong>CPU的寄存器</strong>的值，将其变为<strong>用户态</strong>的值</p></li>
</ul>
<p>系统调用过程中，并<strong>不会涉及</strong>到<strong>虚拟内存</strong>等进程用户态的资源，也<strong>不会切换进程</strong>。</p>
<p>系统调用过程通常称为<strong>特权模式切换</strong>，而不是进程上下文切换。</p>
<h2 id="用户态与内核态下的线程问题">2.3 用户态与内核态下的线程问题</h2>
<p>实际系统中会存在<strong>用户态线程</strong>和<strong>内核态线程</strong>的问题，关于这部分的<strong>线程</strong>问题将在下面的<strong>进程管理</strong>中详细介绍。</p>
<blockquote>
<p>参考资料：</p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/Luckiers/article/details/123868625">Linux下软中断过程（详细）源码总结</a></p>
</blockquote>
<blockquote>
<p><a href="https://liuyehcf.github.io/2017/08/20/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/">系统调用</a></p>
</blockquote>
<h1 id="三进程管理">三、进程管理</h1>
<h2 id="进程与线程">3.1 进程与线程</h2>
<h3 id="进程与线程的基本区别">3.1.1 进程与线程的基本区别</h3>
<ul>
<li><strong>进程</strong>：<strong>资源分配</strong>的基本单位</li>
<li><strong>线程</strong>：<strong>CPU调度</strong>的基本单位</li>
</ul>
<p>我们执行一个程序时，实际上是<strong>操作系统</strong>为我们创建了一个<strong>进程</strong>，一个进程中可以有多个线程存在</p>
<ul>
<li><strong>操作系统的三大资源</strong>
<ul>
<li><strong>CPU</strong></li>
<li><strong>内存</strong></li>
<li><strong>文件描述符</strong></li>
</ul></li>
<li><strong>进程分配的资源</strong>
<ul>
<li><strong>内存空间</strong>：代码段、数据段、堆、栈等</li>
<li><strong>文件描述符</strong>：打开的文件、网络连接等</li>
<li><strong>CPU时间片</strong></li>
</ul></li>
<li><strong>线程分配的资源</strong>
<ul>
<li><strong>寄存器</strong>：通用寄存器、程序计数器等</li>
<li><strong>栈</strong>：线程独有的栈空间（从进程的<strong>用户态堆</strong>中分配出来的）</li>
<li><strong>CPU时间片</strong></li>
</ul></li>
</ul>
<p>从最基本的关系来说，<strong>多线程</strong>可以共享其<strong>进程</strong>的<strong>资源（虚拟内存空间、文件描述符资源、信号处理器...）</strong>，各个线程之间<strong>独立</strong>地拥有自己的<strong>栈空间</strong>和<strong>寄存器</strong></p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/process_thread.png" width="80%"></p>
<p><strong>1）线程的优缺点</strong></p>
<ul>
<li><strong>优点</strong>：开销小、通信方便
<ul>
<li><strong>创建快</strong></li>
<li><strong>终止快</strong></li>
<li><strong>切换快</strong>：同一进程的线程切换不需要切换<strong>资源</strong>，只切换独有的<strong>栈空间</strong>和<strong>寄存器</strong></li>
<li>不用重新加载<strong>CPU页表缓存TLB</strong>：进程切换需要改变虚拟地址空间重新加载页表，会导致<strong>TLB（CPU中的页表缓存）失效</strong></li>
<li><strong>通信方便</strong>：同一进程的线程共享<strong>内存空间</strong>，数据传输<strong>不经过内核</strong></li>
</ul></li>
<li><strong>缺点</strong>：单个线程出错会导致整个进程崩溃</li>
</ul>
<p><strong>2）进程的优缺点</strong></p>
<ul>
<li><strong>优点</strong>：<strong>稳定性</strong>高
<ul>
<li><strong>独立性</strong>：进程之间<strong>独立</strong>，一个进程出错不会影响其他进程</li>
<li><strong>资源独立</strong>：进程之间<strong>资源独立</strong>，一个进程的资源不会被其他进程访问</li>
</ul></li>
<li><strong>缺点</strong>：开销大、通信复杂</li>
</ul>
<h3 id="进程与线程的结构描述">3.1.2 进程与线程的结构描述</h3>
<p>进程和线程的结构称为<strong>进程表</strong>和<strong>线程表</strong>，其中包含了进程和线程的<strong>基本信息</strong>，存储于<strong>内核空间</strong>中。</p>
<p><strong>1）进程控制块的结构：PCB</strong></p>
<p>在操作系统中，每个进程具有唯一标识<strong>PCB</strong>（Process
Control
Block）来描述一个进程的基本信息，进程的PCB是系统感知进程的唯一实体，包括：</p>
<ul>
<li><strong>PID</strong>：进程的唯一标识</li>
<li><strong>Name</strong>：进程的名字</li>
<li><strong>State</strong>：进程的状态（运行、就绪、阻塞等）</li>
<li><strong>Priority</strong>：进程的CPU抢占优先级</li>
<li><strong>资源I/O分配</strong>：内存地址、虚拟空间地址、打开和使用的文件描述符等（进程间是通过页表的方式隔离地址空间的）</li>
<li><strong>CPU信息</strong>：主要是记录切片中断保存现场的信息，但是其实<strong>PCB</strong>不够大存不下，所以会有<strong>内核栈</strong>来配合存放这些信息</li>
<li>...... 要频繁转换 <img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/PCB.png" width="80%"></li>
</ul>
<p><strong>2）线程控制块的结构：TCB</strong></p>
<p>线程表中存放的信息与进程类似，包括：</p>
<ul>
<li><strong>Thread ID</strong>：线程的唯一标识</li>
<li><strong>State</strong>：进程的状态（运行、就绪、阻塞等）</li>
<li><strong>Priority</strong>：进程的CPU抢占优先级</li>
<li><strong>CPU信息</strong>：程序计数器等寄存器的值</li>
</ul>
<h3 id="进程与线程的状态类型">3.1.4 进程与线程的状态类型</h3>
<p>我们知道，CPU调度采用的是<strong>时间切片</strong>的方式，所以需要有多个状态来描述进程和线程的状态：</p>
<ul>
<li><strong>创建状态</strong></li>
<li><strong>就绪状态</strong>：维护一个<strong>就绪队列</strong>，等待CPU调度</li>
<li><strong>运行状态</strong>：该时刻正在占用CPU</li>
<li><strong>阻塞状态</strong>：等待某个事件的发生，如I/O磁盘操作读取数据、打印机响应等，避免<strong>占用CPU</strong></li>
<li><strong>挂起状态</strong>：当进程/线程<strong>内存空间</strong>搬至<strong>外存</strong>、<code>sleep</code>、<strong>Ctrl+Z主动挂起</strong>时会进入挂起状态
<ul>
<li><strong>就绪挂起</strong>：内存空间搬至<strong>外存（硬盘）</strong>，但只要重新进入内存就立刻执行</li>
<li><strong>阻塞挂起</strong>：等待某个事件的发生，但只要事件发生就立刻执行w</li>
</ul></li>
<li><strong>终止状态</strong>：进程或线程执行完毕</li>
</ul>
<p>各状态之间具有相互转换的关系：</p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/process_state.png" width="80%"></p>
<p><strong>1）创建状态</strong></p>
<ul>
<li>申请<strong>PCB/TCB</strong>，并初始化</li>
<li>分配内存资源如<strong>内存空间</strong>，并将<strong>代码段</strong>、<strong>数据段</strong>、<strong>堆</strong>、<strong>栈</strong>等加载到内存中</li>
<li>将<strong>PCB/TCB</strong>插入<strong>就绪队列</strong>中</li>
</ul>
<p><strong>2）阻塞状态</strong></p>
<p>当<strong>运行状态</strong>中的进程出现某些系统调用时，如<strong>I/O操作</strong>，会进入<strong>阻塞状态</strong>，等待<strong>事件</strong>的发生</p>
<ul>
<li>找对应的<strong>PCB/TCB</strong>，将其从<strong>就绪队列</strong>中移除</li>
<li>经历<strong>运行状态---&gt;保护现场---&gt;阻塞状态</strong>的过程</li>
<li>将<strong>PCB/TCB</strong>插入<strong>阻塞队列</strong>中</li>
</ul>
<p><strong>3）从阻塞状态唤醒到就绪状态</strong></p>
<p>当<strong>阻塞状态</strong>的进程等待的<strong>事件</strong>发生后，会进入<strong>就绪状态</strong>（信号触发）</p>
<ul>
<li>查找PCB/TCB，将其从<strong>阻塞队列</strong>中移除</li>
<li>将其插入<strong>就绪队列</strong>中等待调度</li>
</ul>
<p><strong>4）终止状态</strong></p>
<ul>
<li>查找PCB</li>
<li>从<strong>运行状态</strong>停止，也就是归还CPU</li>
<li>子进程变成<strong>孤儿进程</strong>交给<strong>init</strong>
<strong>1号</strong>进程接管</li>
<li>归还资源给操作系统</li>
<li>从<strong>PCB/TCB队列</strong>中移除</li>
</ul>
<h3 id="cpu调度算法">3.1.4 CPU调度算法</h3>
<p>调度关系着CPU的<strong>利用率</strong>和<strong>响应时间</strong>，当进程/线程进入<strong>运行状态</strong>就是占用了CPU，而什么时候占用就与调度算法有很大关系了</p>
<p><strong>什么时候触发调度？</strong></p>
<p>总的来说，在上面那张状态图中，跟<strong>运行状态</strong>相关联的<strong>就绪状态</strong>、<strong>阻塞状态</strong>、<strong>终止状态</strong>的出现都会触发调度</p>
<ul>
<li><strong>时间片用完</strong>：出现<strong>就绪态---运行态</strong>的转换</li>
<li><strong>发生阻塞</strong>：当出现阻塞事件时，正在运行的进程会进入阻塞状态，此时会触发调度重新选一个进程执行</li>
<li><strong>进程终止</strong></li>
</ul>
<p><strong>调度算法</strong></p>
<p>调度算法是为了<strong>提高CPU的利用率</strong>和<strong>响应时间</strong>，调度算法有<strong>抢占式</strong>和<strong>非抢占式</strong>之分：</p>
<ul>
<li><strong>非抢占式</strong>：进程一旦进入<strong>运行状态</strong>，就一直运行，直到进程<strong>终止</strong>或<strong>阻塞</strong>，才会调度其他进程</li>
<li><strong>抢占式</strong>：进程在<strong>运行状态</strong>时，会根据<strong>时间片</strong>或<strong>优先级</strong>等因素，被其他进程抢占，从而调度其他进程（到时就换）</li>
</ul>
<p>常见的调度算法有：</p>
<ul>
<li><strong>先来先服务（FCFS）</strong>：按照进程到达的先后顺序进行调度
<ul>
<li>每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</li>
</ul></li>
<li><strong>短作业优先（SJF）</strong>：按照进程的<strong>运行时间</strong>进行入队列
<ul>
<li>每次从就绪队列选择<strong>运行时间最短</strong>的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择<strong>运行时间最短</strong>的进程接着运行。</li>
</ul></li>
<li><strong>时间片轮转（RR）</strong>：按照<strong>时间片</strong>进行调度
<ul>
<li>按照公平原则，每个进程都有一个<strong>时间片</strong>，当时间片用完后，会重新进入<strong>就绪队列</strong>，等待下一次调度</li>
</ul></li>
<li><strong>优先级调度</strong>：按照<strong>优先级</strong>进行调度
<ul>
<li>每次从就绪队列选择<strong>优先级最高</strong>的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择<strong>优先级最高</strong>的进程接着运行。</li>
</ul></li>
<li><strong>多级反馈队列调度</strong>：结合<strong>时间片轮转</strong>和<strong>优先级调度</strong>的调度算法
<ul>
<li>将<strong>就绪队列</strong>分为<strong>多个队列</strong>，每个队列有一个<strong>时间片</strong>，<strong>优先级</strong>逐渐降低，当一个进程<strong>时间片</strong>用完后，会进入<strong>下一个队列</strong>等待调度</li>
</ul></li>
</ul>
<h2 id="上下文切换">3.2 上下文切换</h2>
<p>当CPU出现<strong>调度</strong>，需要切换到其他进程时，会涉及到<strong>上下文切换</strong>，需要经过<strong>当前进程</strong>的<strong>保存现场</strong>和<strong>下一个进程</strong>的<strong>加载恢复现场</strong></p>
<p>在切换前程序会先停止运行，然后<strong>触发中断保护现场</strong>，之后操作系统会将<strong>寄存器信息</strong>压栈到<strong>PCB+内核栈</strong>中</p>
<p>现代操作系统都是直接调度<strong>线程</strong>，而不是<strong>进程</strong>，因为<strong>线程</strong>的<strong>切换</strong>比<strong>进程</strong>的<strong>切换</strong>要快</p>
<ul>
<li><strong>线程</strong>的<strong>上下文切换</strong>只需要<strong>切换栈</strong>和<strong>寄存器</strong>即可</li>
<li><strong>进程</strong>的<strong>上下文切换</strong>需要<strong>切换页表</strong>、<strong>切换内存空间</strong>等操作</li>
</ul>
<h3 id="触发上下文切换的场景">3.2.1 触发上下文切换的场景</h3>
<p>当出现<strong>CPU当前运行状态的进程/线程需要转换为另一个进程/线程的场景时（也就是发生调度）</strong>，就会触发<strong>上下文切换</strong>，主要有以下几种情况：</p>
<ul>
<li><strong>运行状态&lt;---&gt;就绪状态</strong>
<ul>
<li><strong>时间片用完，剥夺CPU，通过时间中断实现切换</strong></li>
</ul></li>
<li><strong>运行状态&lt;---&gt;挂起状态</strong>
<ul>
<li><strong>资源不足挂起</strong></li>
<li><strong>sleep主动挂起</strong></li>
</ul></li>
<li><strong>运行状态&lt;---&gt;阻塞状态</strong>
<ul>
<li><strong>硬件中断</strong>：如<strong>I/O操作</strong>等</li>
</ul></li>
</ul>
<h3 id="线程和进程上下文切换比较">3.2.2 线程和进程上下文切换比较</h3>
<p>要比较两者的上下文切换区别，首先要分别了解<strong>进程</strong>和<strong>线程</strong>的<strong>上下文切换</strong>具体切换了什么内容？</p>
<p><strong>1）上下文指什么？</strong></p>
<p>上下文可以分为<strong>用户上下文</strong>、<strong>系统上下文</strong>和<strong>硬件上下文</strong>：</p>
<ul>
<li><strong>用户上下文</strong>：用户态的地址空间（用户空间）、页表等信息</li>
<li><strong>系统上下文</strong>：PCB+内核栈等信息</li>
<li><strong>硬件上下文</strong>：寄存器、程序计数器等信息</li>
</ul>
<p><strong>2）进程、线程、协程上下文切换的内容</strong></p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/context_switch.png" width="60%"></p>
<h3 id="上下文切换的过程">3.2.3 上下文切换的过程</h3>
<p>进程<strong>状态的切换</strong>会触发进程的<strong>上下文切换</strong>，而切换是由<strong>中断驱动实现的</strong></p>
<p>以进程为例，首先要了解进程的组成，进程的切换中<strong>保护线程</strong>就是围绕进程的组成来进行的：</p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/process_struct.png" width="80%"></p>
<p>具体过程主要为</p>
<ul>
<li><strong>硬件中断</strong>：CPU收到<strong>中断信号</strong>后，会<strong>暂停当前进程</strong>的执行</li>
<li><strong>保存当前进程的上下文</strong>：先将<strong>SP</strong>、<strong>PC</strong>保存至<strong>内核栈</strong>中</li>
<li><strong>切换到内核态</strong>：<strong>程序计数器PC</strong>重新指向<strong>内核态</strong>的<strong>中断处理程序</strong></li>
<li><strong>中断处理程序</strong>：执行<strong>中断处理程序</strong>，将通用寄存器保存下来</li>
<li><strong>调度新进程</strong>：根据<strong>调度算法</strong>选择新的进程，将其<strong>PCB、内核栈</strong>中的<strong>寄存器</strong>信息恢复到<strong>CPU</strong>中</li>
</ul>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/process_switch.png" width="80%"></p>
<blockquote>
<p>参考资料：</p>
<p><a href="https://www.bilibili.com/video/BV1PK411w75b/?vd_source=fa61c94b4d0a0af186e3cb794e46eea9">用户级thread_内核级thread_内核thread之区别</a></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/14%20%20%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F.md">用户态和内核态：用户态线程和内核态线程有什么区别？</a></p>
<p><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E9%87%8D%E5%AD%A6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%AE%8C/17%20%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%BC%80%E9%94%80%E6%AF%94%E7%BA%BF%E7%A8%8B%E5%A4%A7%E5%9C%A8%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%9F.md">17
进程和线程：进程的开销比线程大在了哪里？</a></p>
<p><a href="https://xiaolincoding.com/os/4_process/process_base.html#%E8%BF%9B%E7%A8%8B">5.1
进程、线程基础知识</a></p>
</blockquote>
<h2 id="协程">3.3 协程</h2>
<p>相比于进程和线程<strong>，</strong>协程<strong>是一种</strong>用户态<strong>的</strong>轻量级线程**</p>
<p><strong>协程 VS 线程</strong></p>
<ul>
<li><p><strong>协程</strong>的<strong>切换</strong>是<strong>用户态</strong>的<strong>切换</strong>，由<strong>内核态</strong>调度的（纯软实现），而<strong>线程</strong>需要频繁转换<strong>用户态&lt;---&gt;内核态</strong>，因此<strong>协程</strong>的<strong>切换</strong>速度比<strong>线程</strong>的<strong>切换</strong>速度更快</p></li>
<li><p>相比于<strong>线程</strong>上下文切换需要<strong>内核态+寄存器</strong>，<strong>协程</strong>的<strong>上下文内容</strong>只有硬件上下文，也就是<strong>寄存器（SP、PC、DX）</strong>的内容</p></li>
</ul>
<p><strong>进程 VS 线程 VS 协程</strong></p>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr>
<th style="text-align: center;"></th>
<th style="text-align: center;">进程</th>
<th style="text-align: center;">线程</th>
<th style="text-align: center;">协程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>切换内容</strong></td>
<td style="text-align: center;">用户态（页表）+内核态+硬件上下文</td>
<td style="text-align: center;">用户态+内核态+硬件上下文</td>
<td style="text-align: center;">硬件上下文</td>
</tr>
<tr>
<td style="text-align: center;"><strong>切换位置</strong></td>
<td style="text-align: center;">内核态</td>
<td style="text-align: center;">内核态</td>
<td style="text-align: center;">用户态</td>
</tr>
<tr>
<td style="text-align: center;"><strong>切换速度</strong></td>
<td style="text-align: center;">低</td>
<td style="text-align: center;">中</td>
<td style="text-align: center;">高</td>
</tr>
</tbody>
</table>
<p><strong>协程的实现</strong></p>
<p>协程属于<strong>用户态</strong>的<strong>线程</strong>，因此其实现是在用户态的<strong>堆</strong>中malloc出来的<strong>栈空间</strong>，并在<strong>用户态</strong>中进行<strong>切换</strong>，<strong>切换</strong>时只需要<strong>保存寄存器</strong>的信息即可</p>
<p>根据堆中开辟空间的方式，<strong>有栈协程</strong>可以分为<strong>独立栈</strong>和<strong>共享栈</strong>两种：</p>
<ul>
<li><strong>独立栈</strong>：每个协程都有自己的<strong>栈空间</strong>
<ul>
<li><strong>优点</strong>：<strong>切换</strong>时只需要<strong>切换栈指针</strong>即可，无需再次拷贝，因此比较快</li>
<li><strong>缺点</strong>：独占内存资源，<strong>栈空间</strong>较大时会占用较多内存</li>
</ul></li>
<li><strong>共享栈</strong>：所有协程共享一个<strong>栈空间</strong>
<ul>
<li><strong>优点</strong>：节省内存资源</li>
<li><strong>缺点</strong>：<strong>切换</strong>时需要<strong>拷贝栈空间</strong>，因此<strong>切换</strong>速度较慢</li>
</ul></li>
</ul>
<p>在堆区中，协程的空间通过<strong>esp</strong>和<strong>ebp</strong>来控制</p>
<ul>
<li><strong>esp</strong>表示<strong>栈顶</strong></li>
<li><strong>ebp</strong>表示<strong>栈底</strong></li>
</ul>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/coroutine.png" width="20%"></p>
<h2 id="进程间通信">3.4 进程间通信</h2>
<p>进程间通信主要有<strong>管道</strong>、<strong>消息队列</strong>、<strong>共享内存</strong>、<strong>信号量</strong>、<strong>信号</strong>、<strong>套接字</strong>等方式</p>
<h3 id="管道pipe">3.4.1 管道Pipe</h3>
<p>管道是一种<strong>半双工</strong>的<strong>通信方式</strong>，由<strong>读端</strong>和<strong>写端</strong>组成的<strong>单向</strong>通信方式</p>
<p>我们最常见的Linux中的指令<code>|</code>其实就代表了<strong>管道</strong>的使用，如<code>ps aux | grep mysql</code></p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/pipe.png" width="50%"></p>
<p>管道可以分为<strong>匿名管道</strong>和<strong>有名管道</strong>：</p>
<ul>
<li><strong>匿名管道</strong>：无文件实体，只能用于<strong>父子进程</strong>或<strong>兄弟进程</strong>之间的通信</li>
<li><strong>有名管道</strong>：存在文件实体，可以用于<strong>任意进程</strong>之间的通信</li>
</ul>
<p><strong>1）存储方式</strong></p>
<ul>
<li>管道属于<strong>内核里的一块缓冲区</strong></li>
<li>数据无格式</li>
<li><strong>读端</strong>读取数据后，<strong>缓冲区</strong>中的数据就会被清空</li>
<li>大小有限，<strong>满了</strong>会<strong>阻塞写端</strong>，<strong>空了</strong>会<strong>阻塞读端</strong></li>
</ul>
<p><strong>2）缺点</strong></p>
<p>通信效率低，不适合<strong>大量数据、频繁通信</strong>的场景</p>
<h3 id="消息队列mq">3.4.2 消息队列MQ</h3>
<p><strong>1）存储方式</strong></p>
<ul>
<li><strong>消息队列</strong>是以<strong>消息链表</strong>的形式存储的</li>
<li><strong>消息队列</strong>中的<strong>消息</strong>是有<strong>格式</strong>的，可以是<strong>结构体</strong>等</li>
<li>有固定大小的存储块</li>
</ul>
<p><strong>2）优点</strong></p>
<ul>
<li>适用于频繁的数据交流</li>
</ul>
<p><strong>3）缺点</strong></p>
<ul>
<li>通信不及时：<strong>消息队列</strong>是<strong>异步</strong>的，<strong>发送</strong>和<strong>接收</strong>消息的时间不一定是同步的</li>
<li>存储块有限，不适合<strong>大量数据</strong>的通信</li>
<li>存在用户态和内核态的<strong>数据拷贝</strong>开销：<strong>发送</strong>和<strong>接收</strong>消息时，需要<strong>数据拷贝</strong>，效率较低</li>
</ul>
<h3 id="共享内存">3.4.3 共享内存</h3>
<p><strong>1）存储方式</strong></p>
<p>通过拿出一块<strong>虚拟内存</strong>，然后<strong>映射</strong>到<strong>物理内存</strong>中，实现<strong>共享内存</strong>的通信</p>
<p><strong>2）优点</strong></p>
<p>通过<strong>映射</strong>的方式不需要<strong>数据拷贝</strong>，效率较高</p>
<h3 id="信号量">3.4.4 信号量</h3>
<p>信号量只是一个<strong>计数值</strong>，通常用于进程or线程的<strong>数据同步</strong>、防止多进程竞争共享资源</p>
<p>信号量有两个关键操作（P&amp;V操作）：</p>
<ul>
<li><strong>P操作：请求资源，对应C++的.wait()</strong>
<ul>
<li>信号量减1</li>
<li><code>sem&lt;0</code>：阻塞，表示无资源可用</li>
<li><code>sem&gt;0</code>：继续执行</li>
</ul></li>
<li><strong>V操作：释放资源，对应C++中的.signal()</strong>
<ul>
<li>信号量加1</li>
<li><code>sem&lt;=0</code>：唤醒一个等待的进程</li>
</ul></li>
</ul>
<h2 id="其它进程类型">3.5 其它进程类型</h2>
<p>进程有多种类型，主要有<strong>孤儿进程</strong>、<strong>僵尸进程</strong>、<strong>守护进程</strong>等，通过Linux的<code>ps</code>命令可以查看，进程间通过pid号来区分</p>
<h3 id="孤儿进程无害会自动回收">3.5.1 孤儿进程：无害（会自动回收）</h3>
<p><strong>孤儿进程</strong>是指<strong>父进程退出</strong>后，<strong>子进程</strong>还在运行</p>
<p>此时<strong>子进程</strong>的<strong>父进程</strong>会被进程号为1的<strong>init</strong>进程接管，操作系统会定期清理<strong>孤儿进程</strong></p>
<h3 id="僵尸进程有危害">3.5.2 僵尸进程：有危害</h3>
<p>进程<strong>exit()</strong>退出内核后会<strong>释放该进程的所有资源</strong>（打开的文件、占用内存等），但是不会主动<strong>回收</strong>该进程的<strong>PCB</strong>，也就是该<strong>进程号</strong>还一直被占用</p>
<p><strong>僵尸进程</strong>是指一个<strong>子进程</strong>已经<strong>exit()</strong>，但是<strong>父进程</strong>还没有<strong>回收</strong>它的<strong>PCB</strong>，导致<strong>子进程</strong>的<strong>PCB</strong>一直保存在<strong>内核</strong>中，这种进程就是<strong>僵尸进程</strong></p>
<p><strong>僵尸进程</strong>会占用<strong>系统资源（进程号有限）</strong>，因此需要<strong>回收</strong>它，回收有两种方式：</p>
<ul>
<li><strong>父进程主动回收</strong>
<ul>
<li>子进程退出时发送<strong>SIGCHLD</strong>信号给父进程，父进程通过<strong>wait()或waitpid()方法</strong>回收子进程</li>
</ul></li>
<li><strong>Kill父进程:向父进程对应的pid发送SIGKILL(9)，<code>kil -9 ppid</code></strong>
<ul>
<li>当父进程退出时，子进程会变为<strong>孤儿进程</strong>，被<strong>init</strong>进程接管并定期清理</li>
</ul></li>
</ul>
<h3 id="守护进程">3.5.3 守护进程</h3>
<p><strong>守护进程</strong>是一种在<strong>挂在后台</strong>运行的进程，通常用于<strong>系统服务</strong>的启动和管理</p>
<p>它会定期执行一些<strong>系统任务</strong>，如<strong>日志清理</strong>、<strong>定时任务</strong>等；其父进程是<strong>init</strong>进程，因此不会成为<strong>僵尸进程</strong>，同时操作系统结束它才会结束</p>
<h2 id="多线程同步问题">3.6 多线程同步问题</h2>
<p>多线程之间会存在<strong>资源竞争</strong>的问题，因此有<strong>互斥</strong>和<strong>同步</strong>的问题</p>
<ul>
<li><strong>互斥</strong>：某段代码同一时间只能被一个线程访问，其它线程需要阻塞等待进入</li>
<li><strong>同步</strong>：多个线程之间的<strong>数据互通</strong>需要协调工作，如<strong>生产者-消费者模型</strong>、<strong>读写锁</strong>等</li>
</ul>
<h3 id="为什么多线程需要同步">3.6.1 为什么多线程需要同步？</h3>
<p>假设有多线程共享的变量<code>i</code>，当执行<code>i=i+1</code>时，实际上在汇编层面上不是一个原子操作，而是分为<strong>读取</strong>、<strong>计算</strong>、<strong>写入</strong>三个步骤：</p>
<ul>
<li><strong>读取</strong>：内存中<code>i</code>的值--&gt;寄存器中</li>
<li><strong>计算</strong>：寄存器中的值+1</li>
<li><strong>写入</strong>：寄存器中的值--&gt;内存中<code>i</code></li>
</ul>
<p>因此多线程很有可能在其中某个步骤被<strong>抢占</strong>，导致<strong>数据不一致</strong>的问题</p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/crrupt.png" width="60%"></p>
<p>在文章<a href="https://akirazheng.github.io/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/#/%E4%BA%8C%E3%80%81C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0">从0开始实现线程池(C++)</a>中有介绍<strong>互斥锁解决多线程数据共享问题</strong>以及<strong>死锁</strong>问题的代码模拟，这里不再赘述</p>
<h3 id="实现同步的方式">3.6.2 实现同步的方式</h3>
<p>实现同步有<strong>加锁</strong>和<strong>不加锁</strong>两种方式：</p>
<ul>
<li><strong>不加锁</strong>：通过原子操作来保证数据的一致性，如<strong>CAS、TAS</strong>等</li>
<li><strong>加锁</strong>：通过<strong>互斥锁</strong>、<strong>读写锁</strong>、<strong>条件变量</strong>等方式来保证数据的一致性</li>
</ul>
<p>也可以将锁分为<strong>乐观锁（通常也是无锁编程）</strong>和<strong>悲观锁</strong>：</p>
<ul>
<li><strong>乐观锁</strong>：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作
<ul>
<li>重写成本高，不适合冲突频繁场景</li>
<li>通常加入<strong>版本号/时间戳</strong>等字段作为<strong>乐观锁</strong>的判断依据</li>
</ul></li>
<li><strong>悲观锁</strong>：认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁
<ul>
<li>适合冲突频繁场景</li>
<li>锁住等待的成本高</li>
</ul></li>
</ul>
<p>各种锁如下所示：</p>
<p><img src="/2024/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/lock.png" width="100%"></p>
<h3 id="死锁问题">3.6.3 死锁问题</h3>
<p>在文章<a href="https://akirazheng.github.io/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/#/%E4%BA%8C%E3%80%81C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0">从0开始实现线程池(C++)</a>中有介绍<strong>互斥锁解决多线程数据共享问题</strong>以及<strong>死锁</strong>问题的代码模拟，这里不再赘述</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫实现QQ群作业的批量下载</title>
    <url>/2024/12/18/%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0QQ%E7%BE%A4%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<blockquote>
<p>前提：使用者需要有该群聊的管理者权利，才可以下所有人的作业</p>
</blockquote>
<blockquote>
<p>下载结果：该博文可以实现将群内所有作业全部下载下来放在<code>downloaded</code>，并按照每个实验单独一个文件夹、每个实验内按照n个群成员生成n个对应文件夹（作业放在该文件夹中）</p>
</blockquote>
<h1 id="一qq群抓包">一、qq群抓包</h1>
<p>由于批量下载的爬虫代码中需要获取QQ群聊相关的<code>QQ群号</code>、<code>cookie</code>、<code>bkn</code>信息，因此需要从网页中获取相关值</p>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/qq_35834501/article/details/106539199">解密之QQ的bkn值，获取QQ群成员信息，获取QQ好友列表信息</a></p>
</blockquote>
<ul>
<li>先进入<em>https://qun.qq.com/member.html</em>
，其中的<code>cookie</code>和<code>bkn</code>都可以在打开<code>fn+12</code>后切换群聊可以在控制台的网络中获取该值</li>
</ul>
<p><img src="/2024/12/18/%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0QQ%E7%BE%A4%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD/cookie.png" width="80%" height="80%"></p>
<p><img src="/2024/12/18/%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0QQ%E7%BE%A4%E4%BD%9C%E4%B8%9A%E7%9A%84%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD/bkn.png" width="80%" height="80%"></p>
<ul>
<li>拿到后再运行<strong>二</strong>中的代码，即可实现批量下载</li>
</ul>
<h1 id="二批量下载">二、批量下载</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> wait <span class="keyword">as</span> pool_wait</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm  <span class="comment"># 进度条库</span></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">group = <span class="built_in">input</span>(<span class="string">&quot;Group: &quot;</span>)</span><br><span class="line">cookie = <span class="built_in">input</span>(<span class="string">&quot;Cookie: &quot;</span>)</span><br><span class="line">bkn = <span class="built_in">input</span>(<span class="string">&quot;bkn: &quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all_homework = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9999</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;get homework list... page &quot;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">    r = requests.post(<span class="string">&quot;https://qun.qq.com/cgi-bin/homework/hw/get_hw_list.fcg&quot;</span>, data=&#123;</span><br><span class="line">        <span class="string">&quot;num&quot;</span>: i,</span><br><span class="line">        <span class="string">&quot;group_id&quot;</span>: group,</span><br><span class="line">        <span class="string">&quot;cmd&quot;</span>: <span class="number">21</span>,</span><br><span class="line">        <span class="string">&quot;page_size&quot;</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="string">&quot;client_type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&quot;bkn&quot;</span>: bkn</span><br><span class="line">    &#125;, headers=&#123;</span><br><span class="line">        <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://qun.qq.com/homework/p/features/index.html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;https://qun.qq.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) QQ/9.2.3.26683 Chrome/43.0.2357.134 Safari/537.36 QBCore/3.43.1297.400 QQBrowser/9.0.2524.400&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Cookie&quot;</span>: cookie</span><br><span class="line">    &#125;, verify=<span class="literal">False</span>)</span><br><span class="line">    r = r.json()</span><br><span class="line">    <span class="built_in">print</span>(r)</span><br><span class="line">    <span class="keyword">if</span> r[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;end_flag&#x27;</span>] == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> entry <span class="keyword">in</span> r[<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;homework&#x27;</span>]:</span><br><span class="line">        all_homework.append(entry)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total: &quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(all_homework)))</span><br><span class="line"><span class="built_in">print</span>(all_homework)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get all students&#x27; homework status</span></span><br><span class="line">details_notyet = <span class="built_in">dict</span>()</span><br><span class="line">details_finish = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> all_homework:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;get detail...&quot;</span> + <span class="built_in">str</span>(entry[<span class="string">&#x27;hw_id&#x27;</span>]))</span><br><span class="line">            r = requests.post(<span class="string">&quot;https://qun.qq.com/cgi-bin/homework/fb/get_hw_feedback.fcg&quot;</span>,</span><br><span class="line">                              data=&#123;</span><br><span class="line">                                  <span class="string">&quot;group_id&quot;</span>: group,</span><br><span class="line">                                  <span class="string">&quot;hw_id&quot;</span>: entry[<span class="string">&#x27;hw_id&#x27;</span>],</span><br><span class="line">                                  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;[0,1]&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                  <span class="string">&quot;page_size&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">                                  <span class="string">&quot;need_userinfo&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;notyet&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;client_type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                  <span class="string">&quot;bkn&quot;</span>: bkn</span><br><span class="line">                              &#125;,</span><br><span class="line">                              headers=&#123;</span><br><span class="line">                                  <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://qun.qq.com/homework/p/features/index.html&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;https://qun.qq.com&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) QQ/9.2.3.26683 Chrome/43.0.2357.134 Safari/537.36 QBCore/3.43.1297.400 QQBrowser/9.0.2524.400&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;Cookie&quot;</span>: cookie</span><br><span class="line">                              &#125;, verify=<span class="literal">False</span>)</span><br><span class="line">            r = r.json()</span><br><span class="line">            <span class="built_in">print</span>(r)</span><br><span class="line">            details_notyet[entry[<span class="string">&#x27;hw_id&#x27;</span>]] = r</span><br><span class="line"></span><br><span class="line">            r = requests.post(<span class="string">&quot;https://qun.qq.com/cgi-bin/homework/fb/get_hw_feedback.fcg&quot;</span>,</span><br><span class="line">                              data=&#123;</span><br><span class="line">                                  <span class="string">&quot;group_id&quot;</span>: group,</span><br><span class="line">                                  <span class="string">&quot;hw_id&quot;</span>: entry[<span class="string">&#x27;hw_id&#x27;</span>],</span><br><span class="line">                                  <span class="string">&quot;status&quot;</span>: <span class="string">&quot;[2,3]&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;page&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                  <span class="string">&quot;page_size&quot;</span>: <span class="number">2000</span>,</span><br><span class="line">                                  <span class="string">&quot;need_userinfo&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;finish&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;client_type&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                                  <span class="string">&quot;bkn&quot;</span>: bkn</span><br><span class="line">                              &#125;,</span><br><span class="line">                              headers=&#123;</span><br><span class="line">                                  <span class="string">&quot;Referer&quot;</span>: <span class="string">&quot;https://qun.qq.com/homework/p/features/index.html&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;Origin&quot;</span>: <span class="string">&quot;https://qun.qq.com&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) QQ/9.2.3.26683 Chrome/43.0.2357.134 Safari/537.36 QBCore/3.43.1297.400 QQBrowser/9.0.2524.400&quot;</span>,</span><br><span class="line">                                  <span class="string">&quot;Cookie&quot;</span>: cookie</span><br><span class="line">                              &#125;, verify=<span class="literal">False</span>)</span><br><span class="line">            r = r.json()</span><br><span class="line">            <span class="built_in">print</span>(r)</span><br><span class="line">            details_finish[entry[<span class="string">&#x27;hw_id&#x27;</span>]] = r</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># write to db</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;write to db...&quot;</span>)</span><br><span class="line"></span><br><span class="line">db = sqlite3.connect(<span class="string">&quot;homework.db&quot;</span>)</span><br><span class="line">c = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> homework_id <span class="keyword">in</span> details_notyet:</span><br><span class="line">    c.execute(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    CREATE TABLE HOMEWORK_&quot;&quot;&quot;</span> + <span class="built_in">str</span>(homework_id) + <span class="string">&quot;&quot;&quot;(</span></span><br><span class="line"><span class="string">       NAME VARCHAR(30) PRIMARY KEY NOT NULL,</span></span><br><span class="line"><span class="string">       FINISHED INTEGER,</span></span><br><span class="line"><span class="string">       CONTENT VARCHAR NOT NULL</span></span><br><span class="line"><span class="string">    );</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line">    db.commit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> homework_id <span class="keyword">in</span> details_notyet:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> stu <span class="keyword">in</span> details_notyet[homework_id][<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;feedback&#x27;</span>]:</span><br><span class="line">            c.execute(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            INSERT INTO HOMEWORK_&quot;&quot;&quot;</span> + <span class="built_in">str</span>(homework_id) + <span class="string">&quot;&quot;&quot; VALUES (?, 0, ?);</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>, (stu[<span class="string">&#x27;nick&#x27;</span>], <span class="built_in">str</span>(stu)))</span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no notyet &quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> stu <span class="keyword">in</span> details_finish[homework_id][<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;feedback&#x27;</span>]:</span><br><span class="line">            c.execute(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            INSERT INTO HOMEWORK_&quot;&quot;&quot;</span> + <span class="built_in">str</span>(homework_id) + <span class="string">&quot;&quot;&quot; VALUES (?, 1, ?);</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>, (stu[<span class="string">&#x27;nick&#x27;</span>], <span class="built_in">str</span>(stu)))</span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no finish &quot;</span> + <span class="built_in">str</span>(e))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># find urls</span></span><br><span class="line">all_urls = <span class="built_in">set</span>()</span><br><span class="line">regex = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(https?|ftp|file)://[-A-Za-z0-9+&amp;@#/%?=~_|!:,.;]+[-A-Za-z0-9+&amp;@#/%=~_|]&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> details_notyet:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i2 <span class="keyword">in</span> regex.finditer(<span class="built_in">str</span>(details_notyet[i])):</span><br><span class="line">        all_urls.add(i2.group())</span><br><span class="line">    <span class="keyword">for</span> i2 <span class="keyword">in</span> regex.finditer(<span class="built_in">str</span>(details_finish[i])):</span><br><span class="line">        all_urls.add(i2.group())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;total urls: &quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(all_urls)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## download files</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_and_save</span>(<span class="params">homework_id, student_folder, file_info, max_retries=<span class="number">3</span></span>):</span></span><br><span class="line">    file_name = file_info[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    target_url = file_info[<span class="string">&#x27;url&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建学生文件夹</span></span><br><span class="line">    student_path = os.path.join(<span class="string">&quot;downloaded&quot;</span>, homework_id, student_folder)</span><br><span class="line">    os.makedirs(student_path, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    file_path = os.path.join(student_path, file_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果文件已经存在，则跳过下载</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;file_name&#125;</span> already exists, skipping.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(max_retries + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> requests.get(target_url, stream=<span class="literal">True</span>, verify=<span class="literal">False</span>, timeout=(<span class="number">5</span>, <span class="literal">None</span>)) <span class="keyword">as</span> r:  <span class="comment"># 增加连接和读取超时</span></span><br><span class="line">                r.raise_for_status()  <span class="comment"># 检查请求是否成功</span></span><br><span class="line"></span><br><span class="line">                total_size = <span class="built_in">int</span>(r.headers.get(<span class="string">&#x27;content-length&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">                progress_bar = tqdm(total=total_size, unit=<span class="string">&#x27;iB&#x27;</span>, unit_scale=<span class="literal">True</span>, desc=file_name)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">for</span> chunk <span class="keyword">in</span> r.iter_content(chunk_size=<span class="number">8192</span>):  <span class="comment"># 使用合适的块大小进行迭代</span></span><br><span class="line">                        <span class="keyword">if</span> chunk:  <span class="comment"># 过滤掉保持活动的空chunk</span></span><br><span class="line">                            f.write(chunk)</span><br><span class="line">                            progress_bar.update(<span class="built_in">len</span>(chunk))</span><br><span class="line">                progress_bar.close()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> total_size != <span class="number">0</span> <span class="keyword">and</span> progress_bar.n != total_size:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&quot;Download of <span class="subst">&#123;file_name&#125;</span> did not complete.&quot;</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;saved to <span class="subst">&#123;file_path&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Attempt <span class="subst">&#123;attempt + <span class="number">1</span>&#125;</span>/<span class="subst">&#123;max_retries&#125;</span> failed to download <span class="subst">&#123;file_name&#125;</span>: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> attempt == max_retries:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Failed to download <span class="subst">&#123;file_name&#125;</span> after <span class="subst">&#123;max_retries&#125;</span> attempts.&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池执行器</span></span><br><span class="line">pool = ThreadPoolExecutor(max_workers=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改数据库内容以适应新的下载逻辑</span></span><br><span class="line">all_tasks = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> homework_id <span class="keyword">in</span> details_finish:</span><br><span class="line">    <span class="keyword">for</span> stu <span class="keyword">in</span> details_finish[homework_id][<span class="string">&#x27;data&#x27;</span>][<span class="string">&#x27;feedback&#x27;</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;content&#x27;</span> <span class="keyword">in</span> stu <span class="keyword">and</span> <span class="string">&#x27;main&#x27;</span> <span class="keyword">in</span> stu[<span class="string">&#x27;content&#x27;</span>]:</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> stu[<span class="string">&#x27;content&#x27;</span>][<span class="string">&#x27;main&#x27;</span>]:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&#x27;text&#x27;</span> <span class="keyword">in</span> item <span class="keyword">and</span> <span class="string">&#x27;c&#x27;</span> <span class="keyword">in</span> item[<span class="string">&#x27;text&#x27;</span>] <span class="keyword">and</span> <span class="built_in">isinstance</span>(item[<span class="string">&#x27;text&#x27;</span>][<span class="string">&#x27;c&#x27;</span>], <span class="built_in">list</span>):</span><br><span class="line">                    <span class="keyword">for</span> file_info <span class="keyword">in</span> item[<span class="string">&#x27;text&#x27;</span>][<span class="string">&#x27;c&#x27;</span>]:</span><br><span class="line">                        <span class="keyword">if</span> <span class="string">&#x27;type&#x27;</span> <span class="keyword">in</span> file_info <span class="keyword">and</span> file_info[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                            student_folder = <span class="string">f&quot;<span class="subst">&#123;stu[<span class="string">&#x27;nick&#x27;</span>]&#125;</span>_<span class="subst">&#123;stu[<span class="string">&#x27;uin&#x27;</span>]&#125;</span>&quot;</span></span><br><span class="line">                            all_tasks.append(</span><br><span class="line">                                pool.submit(download_and_save, <span class="built_in">str</span>(homework_id), student_folder, file_info)</span><br><span class="line">                            )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待所有下载任务完成</span></span><br><span class="line">pool_wait(all_tasks)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All downloads completed.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭线程池执行器</span></span><br><span class="line">pool.shutdown(wait=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Thread pool executor has been shut down.&quot;</span>)</span><br><span class="line">db.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All done!&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代码仓库：https://github.com/AkiraZheng/QQHomeworkBatchTool.git</p>
</blockquote>
<blockquote>
<p>参考：<a href="https://blog.lyc8503.net/post/qq-homework-crawler/">Time Machine -
QQ作业爬虫</a></p>
</blockquote>
]]></content>
      <categories>
        <category>重装-环境配置-计算机</category>
      </categories>
  </entry>
  <entry>
    <title>推广搜6：传统推荐模型之阿里LS-PLM模型</title>
    <url>/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C6%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%98%BF%E9%87%8CLS-PLM%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="ls-plm">LS-PLM</h1>
<h2 id="非线性化分割">非线性化分割</h2>
<p>LS-PLM模型也称为MLR(混合逻辑回归)，它的结构类似于<strong>三层神经网络（三层神经网络包含的隐藏层具有非线性变换的能力，通常通过激活函数实现）</strong>，他的输入层是样本的特征向量，中间层是由m个神经元组成的隐层（m是模型的分片数量，通过控制m来控制分片数，防止过拟合）</p>
<p>传统的LR线性模型只能对样本进行线性分割，而LS-PLM在深度学习到来之前，已经将<strong>线性模型提升为非线性模型</strong>，实现了模型端到端的非线性学习能力。</p>
<p>其中的非线性化主要是通过softmax函数（也就是<span class="math inline">\(\pi_i(x)\)</span>）将特征切分到m个不同的空间，并由LR部分（也就是<span class="math inline">\(\eta_i(x)\)</span>）对m个空间的特征进行线性学习来实现的。</p>
<p>其中随着m的增长，需要的样本数也增加，阿里推荐的值为<span class="math inline">\(m=12\)</span>。</p>
<p>最终的预估函数<span class="math inline">\(f(x)\)</span>为：</p>
<p><span class="math display">\[f(x) = \sum_{i=1}^{m} \pi_i(x) \cdot
\eta_i(x)=\sum_{i=1}^{m}
\frac{e^{\eta_i(x)}}{\sum_{j=1}^{m} e^{\eta_j(x)}}\cdot
\frac{1}{1+e^{-w_i\cdot x}}\]</span></p>
<p><img src="/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C6%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%98%BF%E9%87%8CLS-PLM%E6%A8%A1%E5%9E%8B/function.png" width="60%" height="60%"></p>
<p>所以实际上，<strong>LS-PLM模型也可以看做是一个三层的神经网络模型</strong>：</p>
<ul>
<li>第一层：输入层，也指样本的特征向量</li>
<li>第二层：隐层，通过两个激活函数相乘实现非线性化，实现了Embedding操作
<ul>
<li>其中第一个激活函数实现聚类，包含m个神经元
<ul>
<li>聚类的原因：不同的人群具有聚类特性，同一类人群具有类似的广告点击偏好</li>
</ul></li>
<li>第二个激活函数实现LR分类，包含m个神经元</li>
<li>隐藏层输出为m维切片</li>
</ul></li>
<li>第三层：输出层，包含单一神经元</li>
</ul>
<p><img src="/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C6%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%98%BF%E9%87%8CLS-PLM%E6%A8%A1%E5%9E%8B/LS-PLM.png" width="60%" height="60%"></p>
<p>如下图所示，LR不能拟合非线性数据，MLR可以拟合非线性数据（m=4，实现4切片）</p>
<p><img src="/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C6%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%98%BF%E9%87%8CLS-PLM%E6%A8%A1%E5%9E%8B/nonlinear.png" width="80%" height="80%"></p>
<h2 id="解决稀疏性问题代价函数加入正则化">解决稀疏性问题：代价函数加入正则化</h2>
<p>LS-PLM主要是通过<span class="math inline">\(L_1\)</span>和<span class="math inline">\(L_{2,1}\)</span>正则化来做到这件事情。其中 <span class="math inline">\(L_{2,1}\)</span>用于实现特征筛选，<span class="math inline">\(L_1\)</span>则用于得到尽可能多的稀疏解。</p>
<p>目标损失函数为：</p>
<p><img src="/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C6%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%98%BF%E9%87%8CLS-PLM%E6%A8%A1%E5%9E%8B/loss.png" width="70%" height="70%"></p>
<p>此时由于<span class="math inline">\(L_1\)</span>和<span class="math inline">\(L_2\)</span>正则化函数都是非平滑的，所以损失函数是非凸函数（不止一个极值点），所以可能求得的结果是局部最优解而非全局最优解。</p>
<p><img src="/2025/01/03/%E6%8E%A8%E5%B9%BF%E6%90%9C6%EF%BC%9A%E4%BC%A0%E7%BB%9F%E6%8E%A8%E8%8D%90%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%98%BF%E9%87%8CLS-PLM%E6%A8%A1%E5%9E%8B/loss2.png" width="70%" height="70%"></p>
<blockquote>
<p>参考：</p>
<p><a href="https://zhuanlan.zhihu.com/p/406615820">经典推荐算法学习（四）|
阿里LS-PLM（MLR）模型原理解析</a></p>
<p><a href="https://jesse-csj.github.io/2019/08/12/MLR/">（读论文）推荐系统之ctr预估-MLR(LS-PLM)模型解析</a></p>
</blockquote>
]]></content>
      <categories>
        <category>深度学习算法</category>
      </categories>
  </entry>
  <entry>
    <title>大顶堆/小顶堆（CPP）</title>
    <url>/2024/05/15/%E5%A4%A7%E9%A1%B6%E5%A0%86-%E5%B0%8F%E9%A1%B6%E5%A0%86%EF%BC%88CPP%EF%BC%89/</url>
    <content><![CDATA[<h1 id="一priority_queue">一、priority_queue</h1>
<p>C++中实现大/小顶堆的数据结构是<code>priority_queue</code>，其<strong>默认是大顶堆</strong>，如果要实现小顶堆，需要传入第三个参数<code>greater&lt;int&gt;</code>。</p>
<p><code>priority_queue</code>结构有三个传参：</p>
<ul>
<li>第一个参数<strong>type</strong>：进行排序的数据类型</li>
<li>第二个参数<strong>container</strong>：底层存储根堆的容器类型，默认是<code>vector</code>，且只能是<strong>数组类型</strong>，所以不能是<code>list</code>等</li>
<li>第三个参数<strong>compare</strong>：比较函数，用于实现大顶堆或小顶堆</li>
</ul>
<p>函数原型： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// priority_queue&lt;type, container, container&gt;;</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;<span class="comment">//小顶堆</span></span><br></pre></td></tr></table></figure></p>
<h1 id="二比较函数的设计">二、比较函数的设计</h1>
<p><code>priority_queue</code>如果要自定义比较逻辑，也是通过传入第三个参数(比较函数)来实现的。</p>
<p><code>sort</code>的比较函数中</p>
<ul>
<li>如果要实现<strong>升序</strong>，比较函数<code>return a &lt; b</code></li>
<li>如果要实现<strong>降序</strong>，比较函数<code>return a &gt; b</code></li>
</ul>
<p>而<code>priority_queue</code>中</p>
<ul>
<li>如果要实现<strong>大根堆（类似升序）</strong>，比较函数<code>return a[0] &lt; b[0]</code></li>
<li>如果要实现<strong>小根堆（类似降序）</strong>，比较函数<code>return a[0] &gt; b[0]</code></li>
</ul>
<h2 id="大根堆less与小根堆greater">2.1 大根堆less与小根堆greater</h2>
<p>通过两个比较函数<code>less</code>和<code>greater</code>实现大/小根堆，分别用于实现大根堆和小根堆。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec = &#123; &#123;<span class="number">11</span>, <span class="number">13</span>&#125;, &#123;<span class="number">12</span>, <span class="number">14</span>&#125;, &#123;<span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">15</span>, <span class="number">16</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大根堆less：先按照第一个元素排序，再按照第二个元素排序</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;, less&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; big_heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        big_heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小根堆greater：先按照第一个元素排序，再按照第二个元素排序</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;, greater&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&gt; small_heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        small_heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大根堆：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (!big_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = big_heap.<span class="built_in">top</span>();</span><br><span class="line">        big_heap.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; x[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; x[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小根堆：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (!small_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = small_heap.<span class="built_in">top</span>();</span><br><span class="line">        small_heap.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; x[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; x[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义比较函数">2.2 自定义比较函数</h2>
<p>如果要实现自定义比较函数，可以通过<strong>重写仿函数</strong>来实现。</p>
<ul>
<li>大根堆：<code>return a[0] &lt; b[0]</code></li>
<li>小根堆：<code>return a[0] &gt; b[0]</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//大根堆</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmpBig</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小根堆</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmpSmall</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>] &gt; b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec = &#123; &#123;<span class="number">11</span>, <span class="number">13</span>&#125;, &#123;<span class="number">12</span>, <span class="number">14</span>&#125;, &#123;<span class="number">11</span>, <span class="number">12</span>&#125;, &#123;<span class="number">15</span>, <span class="number">16</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大根堆</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;, cmpBig&gt; big_heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        big_heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小根堆</span></span><br><span class="line">    priority_queue&lt;vector&lt;<span class="keyword">int</span>&gt;, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;, cmpSmall&gt; small_heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : vec) &#123;</span><br><span class="line">        small_heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;大根堆：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (!big_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = big_heap.<span class="built_in">top</span>();</span><br><span class="line">        big_heap.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; x[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; x[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;小根堆：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (!small_heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> x = small_heap.<span class="built_in">top</span>();</span><br><span class="line">        small_heap.<span class="built_in">pop</span>();</span><br><span class="line">        cout &lt;&lt; x[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; x[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三真题">三、真题</h1>
<p>leetcode 347 <a href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">前
K 个高频元素</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123;</span></span><br><span class="line">    <span class="comment">//     unordered_map&lt;int, int&gt; m_map;</span></span><br><span class="line">    <span class="comment">//     map&lt;int, vector&lt;int&gt;&gt; topK_map;//模拟单调递减栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //构建频率map</span></span><br><span class="line">    <span class="comment">//     for(int i:nums)&#123;</span></span><br><span class="line">    <span class="comment">//         m_map[i]++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //构建以频率为key的map</span></span><br><span class="line">    <span class="comment">//     for(auto it = m_map.begin(); it != m_map.end(); it++)&#123;</span></span><br><span class="line">    <span class="comment">//         auto kv = *it;</span></span><br><span class="line">    <span class="comment">//         topK_map[kv.second].push_back(kv.first);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //输出topk:从低到高入队列的</span></span><br><span class="line">    <span class="comment">//     queue&lt;int&gt; topK_que;</span></span><br><span class="line">    <span class="comment">//     for(auto it = topK_map.begin(); it != topK_map.end(); ++it)&#123;</span></span><br><span class="line">    <span class="comment">//         auto kv = *it;</span></span><br><span class="line">    <span class="comment">//         vector&lt;int&gt; vec = kv.second;</span></span><br><span class="line">    <span class="comment">//         for(int tmp:vec)&#123;</span></span><br><span class="line">    <span class="comment">//             if(topK_que.size() &lt; k) topK_que.push(tmp);</span></span><br><span class="line">    <span class="comment">//             else&#123;//放不下了，需要弹出数据</span></span><br><span class="line">    <span class="comment">//                 topK_que.pop();</span></span><br><span class="line">    <span class="comment">//                 topK_que.push(tmp);</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     //存入vec中</span></span><br><span class="line">    <span class="comment">//     vector&lt;int&gt; res;</span></span><br><span class="line">    <span class="comment">//     while(!topK_que.empty())&#123;</span></span><br><span class="line">    <span class="comment">//         res.push_back(topK_que.front());</span></span><br><span class="line">    <span class="comment">//         topK_que.pop();</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*解法2：通过小根堆的方式实现*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m_map;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, cmp&gt; small_heap;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建频率map</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            m_map[i]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = m_map.<span class="built_in">begin</span>(); it != m_map.<span class="built_in">end</span>(); ++it)&#123;</span><br><span class="line">            small_heap.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span>(small_heap.<span class="built_in">size</span>() &gt; k)&#123;</span><br><span class="line">                small_heap.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存入vec中</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!small_heap.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> kv = small_heap.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(kv.first);</span><br><span class="line">            small_heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>从0开始实现线程池(C++)</title>
    <url>/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一线程池概述">一、线程池概述</h2>
<h3 id="线程池的设计初衷">1. 线程池的设计初衷</h3>
<p>线程池是一种<strong>池式结构</strong>(内存池、消息队列也属于池式结构)，主要解决<strong>缓存问题</strong>，起缓冲作用</p>
<p>C++在进行多线程的创建和销毁时，会有比较大的开销，特别是在进行比快的线程操作时，会把很大的时间消耗在线程的创建和销毁上</p>
<p>为了减少在程序中反复创建和销毁线程，就引入了线程池的概念</p>
<p>线程池是在程序启动时，就创建一定数量的线程，放入一个<strong>线程队列</strong>中，当需要使用线程时，就从线程队列中取出一个线程，使用完毕后，再放回线程队列中</p>
<h3 id="线程池的主要作用">2. 线程池的主要作用</h3>
<p>线程池可以实现<strong>异步解耦</strong>，将任务分解为多个子任务，然后将子任务分配给线程池中的线程执行，从而提高程序的执行效率</p>
<p>线程池的使用举例：</p>
<p><strong>a. 服务器端处理客户端请求</strong></p>
<p>当有客户端请求时，服务器端就会创建一个线程来处理客户端的请求，但是如果客户端的请求量很大，服务器端就会创建很多线程，这样会导致服务器端的性能下降</p>
<p>因此可以使用线程池来解决这个问题，将客户端的请求放入线程池中，线程池中的线程来处理客户端的请求。具体实现如下：
1. 创建一个线程池，设置线程池的大小为n 2.
当有客户端请求时，就将客户端的请求放入线程池中 3.
线程池中的线程来处理客户端的请求 4.
处理完客户端的请求后，将线程归还给线程池</p>
<p><strong>b. 保存日志文件</strong></p>
<p>在日志保存时，需要进行文件的读写操作，性能会压在磁盘上，可以采用线程池实现异步解耦来解决这个问题</p>
<h2 id="二c多线程基础学习">二、C++多线程基础学习</h2>
<h3 id="互斥锁解决多线程数据共享问题">1.
互斥锁解决多线程数据共享问题</h3>
<p>多线程操作中，经常会需要在多个线程任务中同时使用同一资源（变量、文件等），如果不加锁往往会出现<strong>数据竞争</strong>问题</p>
<p>数据竞争问题会导致<strong>数据不一致性</strong>，比如对于同一个变量<code>a</code>，线程1对<code>a</code>进行修改，但是还没结束单条指令的时候，线程2就开始对<code>a</code>进行修改，那么最终<code>a</code>的值就会出现混乱</p>
<p>下面举一个例子（Windows下），我们开启两个线程对同一个<code>a</code>变量分别进行5000次的自增操作，然后打印<code>a</code>的值，我们会发现<code>a</code>的值并不是10000，而是一个小于10000的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">		a++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;final a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testMultiThread</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们对两个线程共享的数据<code>a</code>进行加锁，就可以保证当一个线程拿到<code>a</code>变量的锁之后，另一个线程就无法对<code>a</code>进行修改，直到第一个线程释放锁unlock，下一个线程才可以执行对应的操作，保证了共享数据的安全性</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">mutex mtx;<span class="comment">//定义一个互斥锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">		mtx.<span class="built_in">lock</span>();<span class="comment">//加锁</span></span><br><span class="line">		a++;</span><br><span class="line">		mtx.<span class="built_in">unlock</span>();<span class="comment">//解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">thread <span class="title">t1</span><span class="params">(func)</span></span>;</span><br><span class="line">	<span class="function">thread <span class="title">t2</span><span class="params">(func)</span></span>;</span><br><span class="line">	t1.<span class="built_in">join</span>();</span><br><span class="line">	t2.<span class="built_in">join</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;final a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testMultiThread</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，此时经过两个线程各自进行5000次的自增操作后，<code>a</code>的值变为了10000，也就是实现了多线程对共享变量<code>a</code>的安全操作</p>
<h3 id="死锁问题的出现">2. 死锁问题的出现</h3>
<p><strong>1）造成死锁的条件</strong></p>
<p>造成死锁有四个<strong>必要条件</strong>：</p>
<ul>
<li><strong>互斥</strong>：一个资源每次只能被一个进程使用</li>
<li><strong>持有和等待</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li><strong>不可剥夺</strong>：进程已获得的资源，在未使用完之前，不能被其他进程强行剥夺<strong>（用定时释放解决）</strong></li>
<li><strong>循环等待</strong>：若干进程之间形成头尾相接的循环等待资源关系<strong>（通过顺序加锁减少出现概率）</strong></li>
</ul>
<p><strong>2）造成死锁的情况及对应解决方法</strong></p>
<p>造成死锁的情况可能有：</p>
<ul>
<li>忘记释放锁</li>
<li>重复加锁</li>
<li>循环等待：两个线程分别在等待对方释放锁</li>
</ul>
<p>对应的解决方法：</p>
<ul>
<li>检查锁的释放</li>
<li>多把锁按<strong>顺序加锁</strong></li>
<li>引入死锁检查模块</li>
<li>通过定时释放资源解决不可剥夺问题（设置<strong>过期时间</strong>）</li>
<li>通过死锁检查工具检查：
<ul>
<li>CPP用<code>gdb</code>+<code>pstack</code>等工具
<ul>
<li>用<code>pstack 进程pid</code>查看进程的堆栈信息，发现threadA和threadB一直在lock_wait</li>
<li>用<code>gdb -p 进程pid</code>进入进程，然后用<code>info thread</code>查看有多少个线程，最后用<code>thread 线程id</code>切换线程并查看发生死锁的线程的堆栈信息</li>
</ul></li>
<li>Go用<code>pprof</code>工具</li>
</ul></li>
</ul>
<p><strong>3）死锁中循环等待问题的例子</strong></p>
<p>死锁问题是指两个或多个线程互相等待对方释放资源，导致程序无法继续执行的问题</p>
<ul>
<li>举个例子，线程1和线程2分别都有两把锁<code>mtx1</code>和<code>mtx2</code>，线程1先对<code>mtx1</code>加锁，线程2先对<code>mtx2</code>加锁</li>
<li>然后线程1下一条指令是对<code>mtx2</code>加锁，但是此时<code>mtx2</code>已经被线程2加锁了，线程1就会等待线程2释放<code>mtx2</code>的锁</li>
<li>同时线程2下一条指令是对<code>mtx1</code>加锁，但是此时<code>mtx1</code>已经被线程1加锁了，线程2就会等待线程1释放<code>mtx1</code>的锁</li>
<li>这样就会导致线程1和线程2互相等待对方释放锁，导致程序一直卡着无法继续执行</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::mutex mtx1, mtx2;<span class="comment">//定义两把锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();<span class="comment">//step1</span></span><br><span class="line">        mtx2.<span class="built_in">lock</span>();<span class="comment">//step3:等待不到mxt2被释放，卡死</span></span><br><span class="line">        mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        mtx2.<span class="built_in">lock</span>();<span class="comment">//step2</span></span><br><span class="line">        mtx1.<span class="built_in">lock</span>();<span class="comment">//step4:等待不到mxt1被释放，卡死</span></span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">        mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testMultiThread</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们在使用多线程的时候，需要注意避免死锁问题的出现：在多个线程中，尽量不要同时对多个锁进行加锁，如果需要同时对多个锁进行加锁，需要保持<strong>多个线程中对锁的加锁顺序一致</strong></p>
<p>同样采用上面的例子，我们可以将<code>func1</code>和<code>func2</code>中对锁的加锁顺序保持一致：</p>
<ul>
<li><code>func1</code>中先对<code>mtx1</code>加锁，此时由于<code>mtx1</code>被加锁了，第二个线程拿不到<code>mtx1</code>的锁，就会先等待<code>mtx1</code>被释放，此时<code>func1</code>就可以接着直接对<code>mtx2</code>加锁</li>
<li>等到<code>func1</code>释放<code>mtx1</code>的锁后，<code>func2</code>就可以开始对<code>mtx1</code>加锁，然后等待<code>func2</code>释放<code>mtx2</code>的锁</li>
<li>通过两个线程<strong>对锁的加锁顺序保持一致</strong>，就可以避免死锁问题的出现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">std::mutex mtx1, mtx2;<span class="comment">//定义两把锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();<span class="comment">//step1</span></span><br><span class="line">        mtx2.<span class="built_in">lock</span>();<span class="comment">//step2</span></span><br><span class="line">        mtx2.<span class="built_in">unlock</span>();<span class="comment">//step3</span></span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();<span class="comment">//maybe step5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        mtx1.<span class="built_in">lock</span>();<span class="comment">//maybe step4</span></span><br><span class="line">        mtx2.<span class="built_in">lock</span>();<span class="comment">//maybe step6</span></span><br><span class="line">        mtx2.<span class="built_in">unlock</span>();</span><br><span class="line">        mtx1.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testMultiThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(func1)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(func2)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testMultiThread</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="linux下互斥锁和条件变量的使用">3.
Linux下互斥锁和条件变量的使用</h3>
<p>Linux下c++互斥锁和条件变量的使用，需要引入<code>&lt;pthread.h&gt;</code>头文件，使用<code>pthread_mutex_t</code>和<code>pthread_cond_t</code>来定义互斥锁和条件变量</p>
<ul>
<li><strong>互斥锁</strong>是对多线程共享资源的保护</li>
<li><strong>条件变量</strong>是当多个线程需要<strong>等待某个条件满足时</strong>，就可以使用条件变量来<strong>进行线程的等待（进入阻塞）和唤醒</strong>。如果采用互车锁进行阻塞会造成死锁，所以加入条件变量来实现线程的等待和唤醒</li>
</ul>
<h4 id="pthread_mutex_t的简单使用">pthread_mutex_t的简单使用</h4>
<ul>
<li><code>pthread_mutex_t</code>定义一个互斥锁</li>
<li><code>pthread_mutex_init</code>初始化互斥锁，传入两个参数：第一个参数是互斥锁的地址，第二个参数是互斥锁的属性，一般传入<code>NULL</code></li>
<li><code>pthread_mutex_lock</code>实现加锁，传入一个参数：互斥锁的地址</li>
<li><code>pthread_mutex_unlock</code>实现解锁，传入一个参数：互斥锁的地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;<span class="comment">//定义一个互斥锁</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">NULL</span>);<span class="comment">//初始化互斥锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="comment">//加锁</span></span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="comment">//解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="pthread_cond_t的简单使用">pthread_cond_t的简单使用</h4>
<ul>
<li><code>pthread_cond_t</code>定义一个条件变量</li>
<li><code>pthread_cond_init</code>初始化条件变量，传入两个参数：第一个参数是条件变量的地址，第二个参数是条件变量的属性，一般传入<code>NULL</code></li>
<li><code>pthread_cond_wait</code>实现线程的等待（阻塞），传入两个参数：第一个参数是条件变量的地址，第二个参数是互斥锁的地址
<ul>
<li>该函数执行后，获得信号（signal函数）之前，将一直被阻塞。</li>
<li>该函数会在<strong>被阻塞之前</strong>以原子方式<strong>释放相关的互斥锁</strong></li>
<li>并在<strong>被唤醒时</strong>以原子方式<strong>再次获取该互斥锁</strong></li>
<li>所以我们在下面的线程池中，虽然被阻塞的时候会被释放互斥锁，但是在被唤醒时会再次获取互斥锁，所以<strong>唤醒后需要进行解锁</strong>操作</li>
</ul></li>
<li><code>pthread_cond_signal</code>实现线程的唤醒，传入一个参数：条件变量的地址</li>
<li><code>pthread_cond_destroy</code>销毁条件变量，传入一个参数：条件变量的地址</li>
<li><code>pthread_cond_broadcast</code>唤醒所有等待在条件变量上的线程</li>
</ul>
<p><strong>线程A等待条件的伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 拿到互斥锁，进入临界区</span></span><br><span class="line"><span class="keyword">while</span>( **条件为假**)</span><br><span class="line"><span class="comment">//如果不满足条件 就让线程A进入休眠 释放互斥锁，当有信号触发时，该线程重新获得锁 并继续往下执行。</span></span><br><span class="line">	<span class="built_in">pthread_cond_wait</span>(cond, mutex); <span class="comment">// 令进程等待在条件变量上</span></span><br><span class="line">**修改条件**</span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 释放互斥锁</span></span><br></pre></td></tr></table></figure>
<p><strong>线程B通知线程A的伪代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;mutex); <span class="comment">// 拿到互斥锁，进入临界区</span></span><br><span class="line">设置条件为真</span><br><span class="line"><span class="built_in">pthread_cond_signal</span>(cond); <span class="comment">// 通知等待在条件变量上的消费者</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;mutex); <span class="comment">// 释放互斥锁</span></span><br></pre></td></tr></table></figure>
<p>至于条件变量的实际应用将在后面线程池的实现中进行详细讲解</p>
<h2 id="三线程池的实现源码及解析c">三、线程池的实现源码及解析(C++)</h2>
<h3 id="明确目标剖析线程池需要实现的模块框架">1.
明确目标：剖析线程池需要实现的模块(框架)</h3>
<ul>
<li>工作队列：控制线程池中的线程状态</li>
<li>任务队列：线程中的任务函数（任务对应的执行函数）</li>
<li>线程池控制管理：两把锁（一把控制操作的<strong>互斥锁</strong>，一把用于新任务加入时唤醒线程的<strong>条件锁</strong>）</li>
<li>管理者线程：用于自动管理线程池中线程数量</li>
<li>pthread_create的回调函数：回调函数是每个线程创建之后就开始执行的函数，该函数作为<strong>pthread_create的第三个参数传入</strong>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pthread_create函数原型：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *tidp,<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span>*),<span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>pthread_create</code>函数的陷阱：函数原型中第三个参数为函数指针，指向处理线程函数的地址，该函数要求为静态函数，所以如果回调函数(worker)是类成员函数时，需要将<strong>worker函数设置为静态成员函数</strong></p>
<p>第四个参数<code>this</code>指针的陷阱：静态成员函数中没有<code>this</code>指针，所以如果需要在静态成员函数中调用类的成员函数，需要<strong>将代表当前实例化类对象的<code>this</code>指针作为参数传入</strong></p>
<p><img src="/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/structure_threadPooling.png" width="80%" height="80%"></p>
<p>线程池中的<strong>生产者和消费者模型</strong>：</p>
<p><img src="/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/thread_poll_model.png" width="80%" height="80%"></p>
<p>线程池中关于线程创建、销毁等的操作：</p>
<ul>
<li><code>pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);</code>：创建线程
<ul>
<li>thread：指向线程标识符的指针</li>
<li>attr：指向线程属性的指针,一般为传递NULL作为默认属性</li>
<li>start_routine：线程运行函数的起始地址。线程函数的返回类型必须为void<em>，且接受一个void</em>类型的参数。</li>
<li>arg：传递给线程函数的参数，通过void*进行传递</li>
</ul></li>
<li><code>pthread_join(pthread_t thread, void **retval);</code>：等待线程结束
<ul>
<li>thread：线程标识符</li>
<li>retval：用户定义的指针，用来存储被等待线程的返回值</li>
</ul></li>
<li><code>pthread_exit(void *retval);</code>：终止线程
<ul>
<li>retval：线程的返回值</li>
</ul></li>
<li><code>pthread_detach(pthread_t thread);</code>：分离线程
<ul>
<li>thread：线程标识符</li>
<li>该函数的作用是将参数thread标识的线程的状态设置为分离状态，这样线程在终止时会自动释放所有资源，而不用在其他线程中对其进行回收</li>
</ul></li>
</ul>
<p>下面进行线程池的实现讲解，其中在Linux下编译运行使用<code>Makefile</code>自动化脚本进行编译</p>
<p>对<code>Makefile</code>基础使用的讲解可参考我的博客：<a href="https://akirazheng.github.io/2024/03/03/WebServer%E5%AD%A6%E4%B9%A02%EF%BC%9A%E4%BB%8EConfig%E6%96%87%E4%BB%B6%E4%BA%86%E8%A7%A3Makefile%E7%BC%96%E8%AF%91/#/1-int-main-int-argc-char-argv4">WebServer学习2：从Config文件了解Makefile编译</a></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">TARGET = test</span><br><span class="line"><span class="comment"># 自动实现把当前目录下的所有.cpp文件转换成.o文件</span></span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line"><span class="comment"># SRC += $(wildcard timer/*.cpp)# 添加timer文件夹里的文件</span></span><br><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(SRC)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译选项 -c 表示编译链接分开进行 -Wall 表示显示所有警告信息</span></span><br><span class="line">CXXFLAGS = -c -Wall</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化所有的.o文件的生成规则</span></span><br><span class="line"><span class="section">%.o: %.cpp</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(CXXFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure>
<h3 id="线程池中任务队列类的实现">2. 线程池中任务队列类的实现</h3>
<h4 id="单任务结构体的设计">2.1 单任务结构体的设计</h4>
<p>首先设计一个单任务结构体，用于封装任务的回调（执行）函数指针和回调函数对应的参数</p>
<p>在C++中，函数指针的声明方式为：<code>返回类型(*函数指针名)(参数类型1, 参数类型2, ...);</code></p>
<ul>
<li>这里我们的线程池任务结构体中，函数指针类型声明：<code>void(*)(void*)</code>
<ul>
<li>void: 表示函数的返回类型为 void，即不返回任何值。</li>
<li>(*): 表示这是一个指针。</li>
<li>(void<em>): 表示指针所指向的函数将接受一个 void</em>
类型的参数。</li>
</ul></li>
</ul>
<p>采用<code>using</code>的方式创建函数指针类型别名，方便后续使用（这里我们将别名定位<code>callback</code>代表回调函数）</p>
<p>采用别名后使用函数的方式：<code>callback func = &amp;func_name;</code>，<code>func(*args)</code>实现函数的调用</p>
<ul>
<li>TaskQueue.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义任务队列中单个任务的结构体:</span></span><br><span class="line"><span class="comment">* 包含回调函数指针和回调函数所要传递的参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">using</span> callback = <span class="built_in"><span class="keyword">void</span></span>(*)(<span class="keyword">void</span>*);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span>&#123;</span></span><br><span class="line">    callback function;<span class="comment">//回调函数指针</span></span><br><span class="line">    <span class="keyword">void</span> *arg;<span class="comment">//回调函数所要传递的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>()&#123;</span><br><span class="line">        function = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传参构造函数</span></span><br><span class="line">    <span class="built_in">Task</span>(callback f, <span class="keyword">void</span> *a)&#123;</span><br><span class="line">        function = f;</span><br><span class="line">        arg = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="任务队列类的设计">2.2 任务队列类的设计</h4>
<p>设计一个任务队列类，用于存储任务队列中的任务</p>
<p><strong>任务队列</strong>是一种需要<strong>先进先出</strong>的数据结构，C++中有标准库中的<code>queue</code>容器可以方便地实现队列的功能</p>
<p>其中任务队列对于线程池来说一般只有一个，所以我们需要在多线程消费者使用任务队列的时候，对共享的数据进行加锁保护</p>
<p>这里共享的数据就是TaskQueue类中的<code>queue</code>容器，所以我们需要对<code>queue</code>容器进行加锁保护，以保证多线程对<code>queue</code>容器的安全操作</p>
<ul>
<li>TaskQueue.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义任务队列类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskQueue</span>&#123;</span></span><br><span class="line"><span class="comment">//共有接口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者（主程序中的用户）添加新任务到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Task &amp;task)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTask</span><span class="params">(callback function, <span class="keyword">void</span> *arg)</span></span>;<span class="comment">//重载，不使用封装好的Task结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者（线程池中的线程）从队列中取任务</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前队列中的总等待任务数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTaskCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//私有变量</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;Task&gt; m_queue;<span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex;<span class="comment">//互斥锁保护共享数据（任务队列）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>TaskQueue.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">TaskQueue::<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁为NULL</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskQueue::~<span class="built_in">TaskQueue</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//销毁互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(Task &amp;task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="comment">//将生产者给的任务加入就绪队列中</span></span><br><span class="line">    m_queue.<span class="built_in">push</span>(task);</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TaskQueue::addTask</span><span class="params">(callback function, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="comment">//封装成Task结构再传入队列中</span></span><br><span class="line">    m_queue.<span class="built_in">push</span>(<span class="built_in">Task</span>(function, arg));</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">TaskQueue::takeTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//任务队列中不为空才可以返回任务</span></span><br><span class="line">    Task task;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">getTaskCount</span>() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        task = m_queue.<span class="built_in">front</span>();</span><br><span class="line">        m_queue.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对当前的任务队列类进行测试">2.3 对当前的任务队列类进行测试</h4>
<ul>
<li>test.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">taskFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = *(<span class="keyword">int</span>*)arg;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working, num = &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testTaskQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TaskQueue taskQ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> *num = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(i);</span><br><span class="line">        <span class="function">Task <span class="title">task</span><span class="params">(taskFunc, num)</span></span>;</span><br><span class="line">        taskQ.<span class="built_in">addTask</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Task task = taskQ.<span class="built_in">takeTask</span>();</span><br><span class="line">        task.<span class="built_in">function</span>(task.arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">testTaskQueue</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/TaskQueueTest.png"></p>
<h3 id="线程池的实现">3. 线程池的实现</h3>
<p>首先需要设计线程池类的<code>.h</code>声明文件，具体包括</p>
<ul>
<li>线程池的基本参数(私有变量)
<ul>
<li><strong>唯一的任务队列对象</strong></li>
<li>线程池中的线程对象（工作线程和管理者线程）、以及关于线程安全的<strong>共享互斥锁和条件变量</strong></li>
<li>线程池中的参数：线程池的大小、线程池中<strong>忙线程</strong>与<strong>存活线程</strong>的数量、管理者<strong>每次控制线程销毁/创建</strong>的数量、线程池是否关闭</li>
</ul></li>
<li>线程池的私有接口
<ul>
<li>静态函数：包括所有<strong>工作线程的回调函数worker</strong>、唯一<strong>管理者线程的回调函数manager</strong></li>
<li>成员函数:<strong>线程销毁</strong></li>
</ul></li>
<li>线程池的公有接口
<ul>
<li>类构造函数和析构函数</li>
<li>功能函数：添加任务、获取忙线程数、获取存活线程数</li>
</ul></li>
<li>ThreadPool.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span><span class="comment">//memset</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span><span class="comment">//sleep</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ThreadPool</span>(<span class="keyword">int</span> min, <span class="keyword">int</span> max);</span><br><span class="line">    ~<span class="built_in">ThreadPool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池提供共用接口</span></span><br><span class="line">    <span class="comment">//1. 添加任务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="comment">//2. 获取线程池中忙线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getBusyNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//3. 获取线程池中存活线程数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAliveNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//工作线程函数：从任务队列中取任务（回调函数）并执行</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line">    <span class="comment">//管理者线程函数：管理线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">manger</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line">    <span class="comment">//销毁线程函数：销毁线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">threadExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex;<span class="comment">//互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> m_cond;<span class="comment">//条件变量锁</span></span><br><span class="line">    <span class="keyword">pthread_t</span> *m_threadIds;<span class="comment">//线程池数组：如果线程是存活的，那么数组中对应的位置就是对应线程的ID，否则应为0</span></span><br><span class="line">    <span class="keyword">pthread_t</span> m_mangerID;<span class="comment">//管理者线程ID</span></span><br><span class="line">    TaskQueue *m_taskQ;<span class="comment">//任务队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池参数设置：</span></span><br><span class="line">    <span class="comment">//线程池中线程数量、任务队列大小、管理者可控制的最大和最少线程数、线程池是否销毁、线程池中忙线程数以及存活线程数</span></span><br><span class="line">    <span class="keyword">int</span> m_minThreads;</span><br><span class="line">    <span class="keyword">int</span> m_maxThreads;</span><br><span class="line">    <span class="keyword">int</span> m_busyThreads;<span class="comment">//在工作线程中更新的</span></span><br><span class="line">    <span class="keyword">int</span> m_aliveThreads;<span class="comment">//在管理者线程中更新的</span></span><br><span class="line">    <span class="keyword">int</span> m_exitThreads;<span class="comment">//管理者通知需要销毁的线程数</span></span><br><span class="line">    <span class="keyword">bool</span> m_shutDown;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MangerCtlThreadNum = <span class="number">2</span>;<span class="comment">//管理者线程每次销毁或创建的线程数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="线程池的构造函数和析构函数">3.1 线程池的构造函数和析构函数</h4>
<ul>
<li><p>构造函数负责初始化线程池<code>.h</code>中的基础参数，包括任务队列、锁、创建线程等</p></li>
<li><p>析构函数对应地<code>delete</code>线程池中的资源、并销毁线程（设置<code>m_shutDown</code>参数为1，使线程启动自杀销毁）</p></li>
<li><p>ThreadPool.cpp</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">ThreadPool::<span class="built_in">ThreadPool</span>(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">/*初始化&amp;实例化线程池参数*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化当前线程池的唯一任务队列</span></span><br><span class="line">        m_taskQ = <span class="keyword">new</span> TaskQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化线程池中的线程管理参数</span></span><br><span class="line">        m_minThreads = min;</span><br><span class="line">        m_maxThreads = max;</span><br><span class="line">        m_busyThreads = <span class="number">0</span>;</span><br><span class="line">        m_aliveThreads = m_minThreads;</span><br><span class="line">        m_shutDown = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化线程池中的线程数组:按照最大线程数创建数组（只是创建数组，并不创建线程）</span></span><br><span class="line">        m_threadIds = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[m_maxThreads];</span><br><span class="line">        <span class="keyword">if</span>(m_threadIds == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="comment">//创建线程数组失败</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;new pthread_t[] failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//创建失败，直接跳出并销毁资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(m_threadIds, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">pthread_t</span>)*m_maxThreads);<span class="comment">//数组内的线程ID初始化为0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化互斥锁和条件变量</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">pthread_mutex_init</span>(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span> ||</span><br><span class="line">        <span class="built_in">pthread_cond_init</span>(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//初始化失败</span></span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;init mutex or cond failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//初始化失败，直接跳出并销毁资源</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程池中的线程：只创建最小线程数m_minThreads个alive线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_minThreads; i++)&#123;</span><br><span class="line">            <span class="comment">//线程的回调函数为worker，参数为当前线程池对象</span></span><br><span class="line">            <span class="comment">//由于回调函数是静态函数，所以如果回调函数想取任务队列中的任务，必须将当前线程池对象传入才能访问任务队列</span></span><br><span class="line">            <span class="built_in">pthread_create</span>(&amp;m_threadIds[i], <span class="literal">NULL</span>, worker, <span class="keyword">this</span>);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;create thread ID: &quot;</span> &lt;&lt; m_threadIds[i] &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建管理者线程：1个</span></span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;m_mangerID, <span class="literal">NULL</span>, manger, <span class="keyword">this</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;create manger thread ID: &quot;</span> &lt;&lt; m_mangerID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化失败，释放资源</span></span><br><span class="line">    <span class="keyword">if</span>(m_taskQ) <span class="keyword">delete</span> m_taskQ;</span><br><span class="line">    <span class="keyword">if</span>(m_threadIds) <span class="keyword">delete</span>[] m_threadIds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::~<span class="built_in">ThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//关掉线程池工作</span></span><br><span class="line">    m_shutDown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁管理者线程</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;manger thread ID: &quot;</span> &lt;&lt; m_mangerID &lt;&lt; <span class="string">&quot; is exiting&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">pthread_join</span>(m_mangerID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//唤醒被阻塞的线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_aliveThreads; i++)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;m_cond);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放new的堆内存</span></span><br><span class="line">    <span class="comment">// if(m_taskQ) delete m_taskQ;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;delete m_taskQ&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">// if(m_threadIds) delete[] m_threadIds;</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;delete m_threadIds&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁互斥锁和条件变量</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;m_mutex);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;destroy m_mutex&quot; &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;m_cond);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; &quot;destroy m_cond&quot; &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池的添加任务以及获取忙线程数和存活线程数">3.2
线程池的添加任务以及获取忙线程数和存活线程数</h4>
<p>注意这三个函数中涉及的关键参数都是pool中多线程的<strong>共享数据</strong>，所以记得进行<strong>加锁保护</strong></p>
<p>记得在添加任务后需要<strong>唤醒线程</strong>，让线程去取任务</p>
<ul>
<li>ThreadPool.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::addTask</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_shutDown)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务加入队列中</span></span><br><span class="line">    m_taskQ-&gt;<span class="built_in">addTask</span>(task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒线程，让线程去取任务</span></span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;m_cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThreadPool::getBusyNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> busyNum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    busyNum = m_busyThreads;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ThreadPool::getAliveNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> aliveNum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;m_mutex);</span><br><span class="line">    aliveNum = m_aliveThreads;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;m_mutex);</span><br><span class="line">    <span class="keyword">return</span> aliveNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池中线程自我销毁的实现">3.3 线程池中线程自我销毁的实现</h4>
<p>线程自我销毁函数<code>threadExit</code>，是在某个具体工作线程<code>worker</code>中被调用的。</p>
<ul>
<li><p>当<code>threadExit</code>函数被调用时<strong>获取当前worker线程的ID</strong></p></li>
<li><p>然后<strong><em>找到线程池数组中对应的位置</em>置为0</strong>，表示线程处于被销毁（不存活）状态</p></li>
<li><p>最后再调用<code>pthread_exit(NULL)</code>函数实现<strong>执行当前程序的线程的自杀销毁</strong></p></li>
<li><p>ThreadPool.cpp</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程自杀</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadPool::threadExit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程ID</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid = <span class="built_in">pthread_self</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从线程池数组中找到当前线程的ID，将其置为0，表示线程处于被销毁（不存活）状态</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_maxThreads; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_threadIds[i] == tid)&#123;</span><br><span class="line">            m_threadIds[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程退出</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池的工作线程">3.4 线程池的工作线程</h4>
<p>线程池中所有工作线程的工作机制都是一样的，所以我们直接将工作线程的回调函数同一为<code>worker</code>，并在<code>worker</code>中实现工作线程的工作机制：</p>
<ul>
<li><code>worker</code>接受的参数是当前线程池对象，因为<code>worker</code>本身是静态函数，又需要访问线程池类中的共享参数，所以需要将线程池对象传入</li>
<li>当当前线程中，判断出任务队列中没有任务时，就会<strong>阻塞等待</strong>，直到有新任务加入队列，就会被唤醒
<ul>
<li>其中阻塞的时候会<strong>释放互斥锁</strong>，唤醒后会<strong>再次获取互斥锁</strong>，所以唤醒后记得需要进行<strong>解锁操作</strong></li>
</ul></li>
<li>一般有两种情况会唤醒线程：1. 有新任务加入队列 2.
线程池销毁，需要唤醒线程自杀（包括管理者控制）
<ul>
<li>当出现第1种情况时，<code>worker</code>被唤醒后会<strong>获取任务</strong>并<strong>执行任务</strong>，然后再次<strong>阻塞等待</strong></li>
<li>当出现第2种情况时，<code>worker</code>被唤醒后会<strong>判断标志销毁线程的参数是否被设置了</strong>，如果是就会<strong>自杀销毁</strong>（通过<code>threadExit</code>函数自杀）</li>
</ul></li>
<li>ThreadPool.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所有工作线程的工作模式都一致</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadPool::worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="keyword">static_cast</span>&lt;ThreadPool*&gt;(arg);<span class="comment">//传进来的是一个this指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作队列的循环：空队列时阻塞线程，非空队列时执行任务</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*1. 任务队列为空且线程池没被关闭：阻塞工作线程*/</span></span><br><span class="line">        <span class="keyword">while</span>(pool-&gt;m_taskQ-&gt;<span class="built_in">getTaskCount</span>() == <span class="number">0</span> &amp;&amp; !pool-&gt;m_shutDown)&#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is waiting&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;pool-&gt;m_cond, &amp;pool-&gt;m_mutex);<span class="comment">//阻塞的时候当前线程的锁会被释放，等待被唤醒后会重新获得锁</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//解除阻塞后，判断是否销毁当前线程（由管理者线程控制的，因为如果是管理者唤醒线程而不是Task唤醒的话，说明管理者选中销毁当前空闲线程）</span></span><br><span class="line">            <span class="keyword">if</span>(pool-&gt;m_exitThreads &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//管理者选中销毁当前线程，会通知需要销毁m_exitThreads个线程</span></span><br><span class="line">                pool-&gt;m_exitThreads--;<span class="comment">//需要销毁的线程数减一</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;m_aliveThreads &gt; pool-&gt;m_minThreads)&#123;</span><br><span class="line">                    <span class="comment">//自杀</span></span><br><span class="line">                    pool-&gt;m_aliveThreads--;<span class="comment">//存活线程数减一</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;manger kills thread ID: &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_mutex);<span class="comment">//线程被唤醒重新获得阻塞前的锁，所以需要先解锁再销毁</span></span><br><span class="line">                    pool-&gt;<span class="built_in">threadExit</span>();<span class="comment">//销毁当前线程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*2. 任务队列不为空：运行到当前位置的某个工作线程作为被选中的线程执行任务*/</span></span><br><span class="line">        <span class="comment">//这里是析构函数执行时，将m_shutDown设为true后唤醒线程，所有线程池的线程都会执行到这里实现自杀销毁</span></span><br><span class="line">        <span class="keyword">if</span>(pool-&gt;m_shutDown)&#123;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line">            pool-&gt;<span class="built_in">threadExit</span>();<span class="comment">//销毁当前线程</span></span><br><span class="line">            <span class="comment">//当线程调用 pthread_cond_wait 函数时，它会将自身置于条件变量的等待队列中，并释放之前持有的互斥锁。</span></span><br><span class="line">            <span class="comment">//当满足某个条件时，其他线程可以通过 pthread_cond_signal 或 pthread_cond_broadcast 函数唤醒等待的线程。</span></span><br><span class="line">            <span class="comment">// 一旦线程被唤醒，它会重新获得之前释放的互斥锁，并继续执行后续的操</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程还活着，取&amp;分配任务</span></span><br><span class="line">        Task task = pool-&gt;m_taskQ-&gt;<span class="built_in">takeTask</span>();</span><br><span class="line">        <span class="comment">//忙线程加一</span></span><br><span class="line">        pool-&gt;m_busyThreads++;</span><br><span class="line">        <span class="comment">//线程池解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行Task：每个Task都是独立的，所以对task的操作不需要加锁</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        task.<span class="built_in">function</span>(task.arg);<span class="comment">//回调函数执行任务</span></span><br><span class="line">        <span class="comment">//任务执行完毕</span></span><br><span class="line">        <span class="keyword">delete</span> task.arg;<span class="comment">//释放任务参数内存</span></span><br><span class="line">        task.arg = <span class="literal">nullptr</span>;<span class="comment">//指针置空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务处理结束，更新线程池参数：线程池里的共享数据需要加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is idle&quot;</span> &lt;&lt; std::endl;<span class="comment">//需要放在锁中，否则会出现多个线程同时打印，导致乱序输出</span></span><br><span class="line">        pool-&gt;m_busyThreads--;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程池的管理者线程">3.5 线程池的管理者线程</h4>
<p>管理者线程的工作机制是：<strong>根据线程池中的忙线程数和存活线程数，动态地管理线程池中的线程数量</strong>，manger只要在保证线程数不小于最小值，也不大于最大值的范围内，动态地控制线程数量就行</p>
<p>一个pool中<strong>只需要有唯一的一个管理者线程</strong>，管理者线程的回调函数设为<code>manger</code>，并在<code>manger</code>中实现管理者线程的工作机制：</p>
<ul>
<li><code>manger</code>接受的参数同样是当前线程池对象，因为<code>manger</code>本身是静态函数，所以需要将线程池对象传入</li>
<li>管理者线程根据一定的间隔时间<code>t</code>（代码中设为3s）来轮询线程池的线程情况（每3s判断一次是否进行<strong>新增/销毁线程</strong>）</li>
<li><strong>扩增线程</strong>：当任务数过多，线程池中的<strong>alive线程</strong>较小<strong>不够用</strong>时，创建线程
<ul>
<li>创建线程的条件：任务数task &gt;
存活线程数(表示线程池不够用，需要扩大线程池），且存活线程数 &lt;
最大线程数(表示线程池还能扩大)</li>
<li>管理者线程每次创建线程数量为2（本代码中）</li>
<li>创建线程直接从<strong>线程池数组</strong>中找到一个<strong>空闲的位置</strong>（值为0），直接调用<code>pthread_create</code>创建线程，并更新存活线程数</li>
</ul></li>
<li><strong>销毁线程</strong>：当线程池中<strong>忙的线程数过小</strong>（线程池过于清闲了），且存活线程数大于最小线程数时（说明还没到最小线程数），销毁线程
<ul>
<li>销毁线程的条件：忙线程数*2 &lt;
存活线程数(表示线程池冗余过大)，且存活线程数 &gt;
最小线程数(表示线程池还能缩小)</li>
<li>管理者线程每次销毁线程数量为2（本代码中），需要共享数据<code>m_exitThreads</code>来通知工作线程销毁线程</li>
<li>销毁的方式是再管理者线程中唤醒空闲的线程，此时空闲线程的<code>worker</code>会发现<code>m_exitThreads</code>不为0，就会自杀销毁（也就是上述唤醒<code>worker</code>线程的<strong>第2种情况</strong>）</li>
</ul></li>
<li>ThreadPool.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//管理者线程：动态管理线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">ThreadPool::manger</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool* pool = <span class="keyword">static_cast</span>&lt;ThreadPool*&gt;(arg);</span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;m_shutDown)&#123;</span><br><span class="line">        <span class="comment">//管理者线程每次管理的时间间隔</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出线程池中的相关共享参数，需要加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line">        <span class="keyword">int</span> taskSize = pool-&gt;m_taskQ-&gt;<span class="built_in">getTaskCount</span>();<span class="comment">//获取任务队列中的任务数</span></span><br><span class="line">        <span class="keyword">int</span> aliveNum = pool-&gt;m_aliveThreads;<span class="comment">//获取存活线程数(包含阻塞中和工作中的)：创建线程需要</span></span><br><span class="line">        <span class="keyword">int</span> busyNum = pool-&gt;m_busyThreads;<span class="comment">//获取忙线程数(工作中的线程)：销毁线程需要</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 当任务数过多，线程池中的alive线程较小不够用时，创建线程</span></span><br><span class="line">        <span class="comment">//创建线程的条件：任务数task &gt; 存活线程数(表示线程池不够用，需要扩大线程池），且存活线程数 &lt; 最大线程数(表示线程池还能扩大)</span></span><br><span class="line">        <span class="keyword">if</span>(taskSize &gt; aliveNum &amp;&amp; aliveNum &lt; pool-&gt;m_maxThreads)&#123;</span><br><span class="line">            <span class="comment">// 由于销毁创建线程需要对pool里的线程数组进行操作，所以需要加锁</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//记录本次已扩充的线程数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pool-&gt;m_maxThreads &amp;&amp; count &lt; MangerCtlThreadNum; i++)&#123;<span class="comment">//最多每次只允许扩充MangerCtlThreadNum个线程</span></span><br><span class="line">                <span class="comment">//开始创建线程</span></span><br><span class="line">                <span class="keyword">if</span>(pool-&gt;m_threadIds[i] == <span class="number">0</span>)&#123;<span class="comment">//说明当前数组中的线程还没有被创建（没有存活）</span></span><br><span class="line">                    <span class="built_in">pthread_create</span>(&amp;pool-&gt;m_threadIds[i], <span class="literal">NULL</span>, worker, pool);<span class="comment">//在i处创建线程</span></span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;manger creates thread ID: &quot;</span> &lt;&lt; pool-&gt;m_threadIds[i] &lt;&lt; std::endl;</span><br><span class="line">                    count++;<span class="comment">//创建成功，计数器加一</span></span><br><span class="line">                    pool-&gt;m_aliveThreads++;<span class="comment">//存活线程数加一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 当线程池中忙的线程数过小（线程池冗余过大了），且存活线程数大于最小线程数时（说明还没到最小线程数），销毁线程</span></span><br><span class="line">        <span class="comment">//销毁线程的条件：忙线程数*2 &lt; 存活线程数(表示线程池冗余过大)，且存活线程数 &gt; 最小线程数(表示线程池还能缩小)</span></span><br><span class="line">        <span class="keyword">if</span>(busyNum*<span class="number">2</span> &lt; aliveNum &amp;&amp; aliveNum &gt; pool-&gt;m_minThreads)&#123;</span><br><span class="line">            <span class="comment">// 由于销毁创建线程需要对pool里的线程数组进行操作，所以需要加锁</span></span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line">            pool-&gt;m_exitThreads = MangerCtlThreadNum;<span class="comment">//告知pool对象要销毁多少个线程</span></span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;pool-&gt;m_mutex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//唤醒空闲被阻塞的MangerCtlThreadNum个线程，让这些线程自杀（也就是唤醒线程后让线程worker进入自杀状态）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MangerCtlThreadNum; i++)&#123;</span><br><span class="line">                <span class="built_in">pthread_cond_signal</span>(&amp;pool-&gt;m_cond);<span class="comment">//唤醒线程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pool-&gt;threadExit();//销毁管理者线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程池的测试">4. 线程池的测试</h3>
<p>通过创建<code>10</code>个Task的任务队列来测试线程池的工作情况（重点关注管理者的工作模式）</p>
<p>其中对于<code>10</code>个Task的任务，在每次执行Task任务后都会sleep
<code>2s</code>，所以如果在单线程模式下最少需要<code>20s</code>才能执行完毕</p>
<p>因此我们将<code>main</code>中创建完线程后的sleep时间也设为<code>20s</code>，主要是为了观察采用线程池后的工作效率，同时也能保证<code>main</code>函数不会提前结束，导致线程池资源被提前销毁</p>
<p>根据测试结果我们是可以看到采用线程池后，很快就会执行完所有Task，然后等待一段时间（等到<code>main</code>中的20s延迟完后）整个程序才会结束，线程池的资源才会被销毁，说明<strong>通过线程池确实会节省时间，提高效率</strong></p>
<ul>
<li>test.cpp</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;TaskQueue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ThreadPool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程池中线程的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">taskFunc</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = *(<span class="keyword">int</span>*)arg;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;thread &quot;</span> &lt;&lt; <span class="built_in">pthread_self</span>() &lt;&lt; <span class="string">&quot; is working, num = &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试任务队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testTaskQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TaskQueue taskQ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> *num = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(i);</span><br><span class="line">        <span class="function">Task <span class="title">task</span><span class="params">(taskFunc, num)</span></span>;</span><br><span class="line">        taskQ.<span class="built_in">addTask</span>(task);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Task task = taskQ.<span class="built_in">takeTask</span>();</span><br><span class="line">        task.<span class="built_in">function</span>(task.arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试线程池</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">3</span>, <span class="number">12</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往线程池中添加100个任务，观察线程池的动态增长（管理者模式的工作）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        pool.<span class="built_in">addTask</span>(<span class="built_in">Task</span>(taskFunc, <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);<span class="comment">//睡眠40秒,防止主线程结束后线程池执行销毁，尚未完成任务（等待线程池处理完Task）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// testTaskQueue();//测试任务队列</span></span><br><span class="line">    <span class="built_in">testThreadPool</span>();<span class="comment">//测试线程池</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行：</p>
<p><img src="/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/make_threadPool.png"></p>
<p>测试结果：</p>
<p><img src="/2024/02/07/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88C++%EF%BC%89/run_threadPool.png"></p>
<h3 id="本文线程池代码仓库">5. 本文线程池代码仓库</h3>
<ul>
<li><a href="https://github.com/AkiraZheng/MyWebServer/tree/Demos_of_Webserver">C++线程池ThreadPool</a></li>
</ul>
<h2 id="四阻塞队列的实现">四、阻塞队列的实现</h2>
<p>以<strong>异步日志</strong>的实现为例，阻塞队列中，各个线程<strong>生产者</strong>负责往阻塞队列中<code>push</code>日志消息，<strong>消费者</strong>线程负责从阻塞队列中<code>pop</code>日志消息并写入日志文件</p>
<p><strong>异步日志</strong>中的<strong>消费者</strong>为<strong>日志线程</strong>，因此<strong>日志线程</strong>的<code>worker</code>函数中需要不断地从阻塞队列中取出日志消息并写入日志文件。也就是<code>worker</code>函数作为<strong>消费者</strong><code>pop</code>队列中的数据时，遇到队列为空时需要通过<strong>条件变量阻塞等待</strong>，直到<strong>生产者</strong>线程往队列中<code>push</code>数据后唤醒<strong>日志线程</strong>，继续<code>pop</code>队列中的数据写进日志文件缓冲区中。</p>
<p>具体以<strong>异步日志</strong>为例的<strong>阻塞队列</strong>的实现细节参考本人的另一篇关于WebServer的博客：<a href></a></p>
<h2 id="五线程池work-stealing优化">五、线程池work stealing优化</h2>
<h2 id="未完待续..."><strong>未完待续...</strong></h2>
<h2 id="六reference">六、Reference</h2>
<ul>
<li><a href="https://blog.csdn.net/ACMer_L/article/details/107578636">C/C++手撕线程池（线程池的封装和实现）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/367309864">基于C++11实现线程池</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/444375447">当我谈线程池时我谈些什么——线程池学习笔记</a></li>
</ul>
]]></content>
      <categories>
        <category>WebServer项目（C++）</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络传输层</title>
    <url>/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="一tcp">一、TCP</h1>
<h2 id="tcp的包结构">1.1 TCP的包结构</h2>
<p>TCP常见的字段有：</p>
<ul>
<li>序列号<code>seq</code></li>
<li>确认号<code>ack</code></li>
<li>错误连接<code>RST</code>：重置连接（复位）</li>
<li>窗口大小：接收方的缓冲区大小，进行流量控制</li>
<li>请求建立一个连接<code>SYN</code>：同步序列号</li>
<li>请求关闭一个连接<code>FIN</code>：结束连接</li>
</ul>
<p>TCP四元组：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p>而五元组相比四元组多了协议类型，即<strong>TCP</strong>或<strong>UDP</strong>，其中只要五元组有一个不同，就是不同的通信，因此<strong>TCP和UDP的端口号是不冲突的，允许有TCP端口号==UDP端口号</strong></p>
<p>其中TCP像<strong>三次握手四次挥手</strong>、<strong>ACK确认和序列号</strong>、<strong>重传机制</strong>、<strong>滑动窗口流量控制</strong>、<strong>拥塞控制</strong>等都是保证其<strong>可靠传输</strong>的重要机制</p>
<h2 id="tcp的三次握手">1.2 TCP的三次握手</h2>
<p><strong>1）客户端和服务端建立socket</strong></p>
<p>TCP通信中，客户端创建与服务端的socket连接需要经过以下步骤：</p>
<ul>
<li><p>创建客户端socket</p></li>
<li><p>connect连接服务端socket
而创建用于监听的服务端socket需要经过以下步骤：</p></li>
<li><p><strong>创建</strong>服务端socket文件描述符</p></li>
<li><p><strong>bind</strong>绑定服务端socket</p></li>
<li><p><strong>listen</strong>监听服务端socket</p></li>
<li><p><strong>accept</strong>等待接受客户端socket</p></li>
</ul>
<p>那么理论上最多能支持多少个连接？</p>
<ul>
<li>总理论连接数=IP地址数<em>端口号数=2^32</em>2<sup>16=2</sup>48</li>
</ul>
<p>但是实际上受<strong>文件描述符个数、内存大小、进程数等限制</strong>，导致实际连接数远远小于这个数，一般只支持<strong>65535</strong>个连接</p>
<p><strong>2）TCP的三次握手的状态流转</strong></p>
<p>TCP的三次握手过程如下：</p>
<ul>
<li>第一次握手-客户端：发送<code>SYN+Seq</code>请求连接-&gt;进入<strong>SYN_SENT</strong>状态
<ul>
<li>随机生成客户端的<code>Seq</code>序列号</li>
</ul></li>
<li>第二次握手-服务端：返回<code>SYN+(ACK=Seq_client+1)+Seq</code>确认连接-&gt;进入<strong>SYN_RCVD</strong>状态
<ul>
<li>随机生成服务端的<code>Seq</code>序列号</li>
<li>将该客户端的socket信息加入<strong>半连接队列</strong></li>
</ul></li>
<li>第三次握手-客户端：发送<code>(ACK=Seq_server)+Seq</code>确认连接-&gt;进入<strong>ESTABLISHED</strong>状态
<ul>
<li>在<strong>ESTABLISHED</strong>状态下，如果收到<code>RST</code>则进入<strong>CLOSED</strong>状态</li>
</ul></li>
<li>服务端：接收到<code>ACK+Seq</code>确认连接-&gt;进入<strong>ESTABLISHED</strong>状态
<ul>
<li>将该客户端的socket信息从<strong>半连接队列</strong>移入<strong>全连接队列</strong></li>
</ul></li>
</ul>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_3.png" width="80%"></p>
<p><code>SYN</code>洪泛攻击：攻击方短时间内发送大量<code>SYN</code>请求，导致服务端<strong>半连接队列</strong>满了，无法再接受新的连接，从而导致<strong>拒绝服务攻击</strong></p>
<p>解决方法：</p>
<ul>
<li>增大半连接队列</li>
<li>开启SYN
Cookies绕过半连接队列，将<code>SYN</code>请求的<code>Seq</code>序列号加密后发送给客户端，客户端返回<code>ACK</code>时解密后才能建立连接</li>
</ul>
<p><strong>3）TCP的三次握手的原因</strong></p>
<p><strong>a. 避免历史连接造成资源浪费</strong></p>
<p>如果是两次握手无法阻止<strong>历史重复连接</strong>的问题：</p>
<ul>
<li>客户端给服务端发送<code>SYN</code>请求连接，但是因为<strong>网络原因</strong>导致服务端在客户端重试发送完后还没收到数据（重传的序列号是一样的）</li>
<li>服务端只有两次握手，因此在发送ACK后不知道客户端有没有接收到，就直接进入ESTABLISHED状态建立了连接且允许发送数据，此时只有客户端发送<strong>RST</strong>时该历史连接才能断开</li>
<li>此时客户端会发起一个新的连接</li>
<li>而在这段时间内由于服务端已经建立连接了，所以已经可以给客户端发消息了，这是一种资源浪费</li>
</ul>
<p>三次握手的重新连接过程：</p>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_3_2.png" width="60%"></p>
<p>两次握手的重新连接过程：</p>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_2_2.png" width="60%"></p>
<p><strong>b.
保证通信双方均具备收发能力&amp;&amp;序列号被确认</strong></p>
<p>如果只有两次握手，那么只能保证<strong>服务端具备收发能力</strong>，而<strong>客户端并不一定具备收发能力</strong>；同时也不能保证两方的<strong>序列号</strong>都被确认</p>
<p><strong>4）TCP的三次握手失败分别会发生什么</strong></p>
<ul>
<li>第一次握手丢包：<strong>客户端</strong>启动重试机制</li>
<li>第二次握手丢包：<strong>客户端和服务端</strong>都会重试</li>
<li>第三次握手丢包：<strong>服务端</strong>会重试</li>
</ul>
<h2 id="tcp的四次挥手">1.3 TCP的四次挥手</h2>
<p><strong>1）TCP的四次挥手的状态流转</strong></p>
<p>挥手前<strong>客户端</strong>和<strong>服务端</strong>都处于<strong>ESTABLISHED</strong>状态</p>
<p>TCP的四次挥手过程如下：</p>
<ul>
<li>第一次挥手-客户端：发送<code>FIN</code>请求关闭连接-&gt;进入<strong>FIN_WAIT_1</strong>状态
<ul>
<li>发送<code>FIN</code>并调用<code>close</code>函数，属于<strong>系统调用</strong></li>
</ul></li>
<li>第二次挥手-服务端：接收到<code>FIN</code>请求关闭连接-&gt;发送<code>ACK</code>确认-&gt;进入<strong>CLOSE_WAIT</strong>状态
<ul>
<li>在<strong>CLOSE_WAIT</strong>状态下会发送未发完的数据</li>
<li>发送<code>ACK</code>属于<strong>内核</strong>操作</li>
</ul></li>
<li>第三次挥手-服务端：发送<code>FIN</code>请求关闭连接，并调用close函数关闭连接-&gt;进入<strong>LAST_ACK</strong>状态
<ul>
<li>发送<code>FIN</code>并调用<code>close</code>函数，属于<strong>系统调用</strong></li>
</ul></li>
<li>第四次挥手-客户端：收到服务端的<code>FIN</code>请求关闭连接-&gt;发送<code>ACK</code>确认-&gt;进入<strong>TIME_WAIT</strong>状态
<ul>
<li>在<strong>TIME_WAIT</strong>状态下会等待<strong>2MSL</strong>时间，等待可能丢失的ACK确认</li>
<li>2MSL是为了保证<strong>服务端</strong>收到<strong>客户端</strong>的<strong>ACK</strong>确认，如果<strong>服务端</strong>没有收到<strong>ACK</strong>确认，那么会重传<code>FIN</code>请求关闭连接</li>
<li>TIME_WAIT状态下的socket会等待<strong>2MSL</strong>时间，然后进入<strong>CLOSED</strong>状态</li>
<li>客户端发送<code>ACK</code>确认属于<strong>内核操作</strong></li>
</ul></li>
<li>服务端：收到客户端的<code>ACK</code>确认-&gt;进入<strong>CLOSED</strong>状态</li>
</ul>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_4.png" width="80%"></p>
<p><strong>2）TCP的四次挥手的原因</strong></p>
<p>TCP挥手不能跟握手一样只有三次，相比握手中服务端将<code>SYN+ACK</code>合并成一个步骤，而挥手需要分成两个步骤，因为客户端发送<code>FIN</code>后只是代表不会再发送数据了（还可以接收）</p>
<p>但是服务端可能还有数据没发送完，所以需要将<code>FIN</code>和<code>ACK</code>分开，在<code>FIN</code>和<code>ACK</code>中间，服务端处于<strong>CLOSE_WAIT</strong>状态，这个状态内会发送剩余的数据，然后再发送<code>FIN</code>请求关闭连接</p>
<p>如果只有三次握手，那么服务端发完<code>FIN</code>后也关闭连接无法发送剩余数据了，会导致这部分数据丢失</p>
<p><strong>3）为什么TIME_WAIT状态要等待2MSL</strong></p>
<p>MSL指的是<strong>报文最大生存时间</strong>，也就是说如果超过这个时间代表报文消失在网络中了</p>
<p>将<strong>TIME_WAIT设置为2MSL也就是允许报文丢失一次</strong></p>
<p>客户端发送<strong>ACK</strong>到服务端时<strong>最大报文时间是1MSL</strong>，而当超时消亡时，服务端也发现收不到ACK了，因此会重新发送<strong>FIN</strong>，又需要<strong>最大经过1MSL时间</strong>，所以总共是2MSL</p>
<p>当客户端再次收到服务端第二次发的<code>FIN</code>时<strong>TIME_WAIT时间会重新计时（重置为2MSL）</strong></p>
<p><strong>4）TIME_WAIT过多</strong></p>
<p><strong>TIME_WAIT是主动发起挥手方才会出现的状态</strong></p>
<p><strong>a. 客户端TIME_WAIT过多</strong></p>
<p>客户端TIME_WAIT过多是可以通过<strong>端口复用</strong>解决的，开启<code>tcp_tw_reuse</code>，客户端会在connect的时候找一个TIME_WAIT超过1s的连接进行复用</p>
<p>所以一般我们都建议通过<strong>客户端主动发起挥手</strong>，而不是服务端主动发起挥手</p>
<p><strong>b. 服务端TIME_WAIT过多</strong></p>
<ul>
<li>情况1：使用<strong>短连接</strong>，导致每次服务端响应完后会<strong>主动发起挥手断连</strong></li>
<li>情况2：<strong>长连接满了</strong>，最大长连接数设置得过小，导致连接满了，服务端主动关闭已经连接的，来腾出文件描述符给新新连接</li>
</ul>
<p><strong>5）服务端CLOSE_WAIT过多</strong></p>
<p><strong>CLOSE_WAIT</strong>是在服务端返回<code>FIN</code>且<code>close</code>关闭了连接时才会转成<strong>LAST_ACK</strong>状态等待客户端的<code>ACK</code>确认</p>
<p>因此可以判断<strong>CLOSE_WAIT</strong>过多可能是因为没有调用<code>close</code>关闭连接，导致服务端一直处于<strong>CLOSE_WAIT</strong>状态</p>
<h2 id="tcp的可靠性">1.4 TCP的可靠性</h2>
<p>TCP像<strong>三次握手四次挥手</strong>、<strong>ACK确认和序列号</strong>、<strong>重传机制</strong>、<strong>滑动窗口流量控制</strong>、<strong>拥塞控制</strong>等都是保证其<strong>可靠传输</strong>的重要机制</p>
<h3 id="tcp的滑动窗口与流量控制">1.4.1 TCP的滑动窗口与流量控制</h3>
<p>TCP滑动窗口分为<strong>发送端窗口</strong>和<strong>接收端窗口</strong>，主要作用是<strong>防止发送方发送过快导致接收方无法接收</strong>，并导致<strong>接收方被淹没</strong></p>
<p><strong>滑动窗口内的数据就是缓冲区，可以不用等上一个的ACK</strong>，连续发送<strong>滑动窗口大小的数据</strong></p>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_window.png" width="80%"></p>
<p>发送窗口<code>swnd</code>原则上是约等于接收窗口<code>rwnd</code>的，但是由于发送方维护者拥塞窗口<code>cwnd</code>，因此发送窗口<code>swnd</code>的大小实际上是</p>
<ul>
<li><code>swnd = min(rwnd, cwnd)</code></li>
</ul>
<h3 id="tcp的超时重传与拥塞控制">1.4.2 TCP的超时重传与拥塞控制</h3>
<h4 id="重传">1.4.2.1 重传</h4>
<p><strong>1）超时重传：时间驱动</strong></p>
<p>超时重传就是最朴素的，一个包发送出去后，如果在<strong>一定时间内</strong>没有收到ACK确认，那么就会<strong>重传</strong>这个包；</p>
<p>由于是以<strong>时间为驱动的，因此可能会出现重传较慢的问题</strong></p>
<p>这里有<strong>RTT为数据发送到接收ACK所需的往返时间</strong>，而<strong>RTO为重传超时时间</strong>，一般来说有：</p>
<ul>
<li><code>RTO &gt; RTT</code></li>
</ul>
<p><strong>2）快速重传：数据驱动</strong></p>
<p><strong>发送方收到3个重复的ACK就会进行快速重传</strong>，但是该重传<strong>一个呢？还是重传后面所有的包呢？</strong></p>
<ul>
<li>重传一个：如果下一个包也丢失的话，就要再次等3个相同ACK后才会重传</li>
<li>重传后面所有的包：如果后面的包没丢失，那么会浪费网络资源</li>
</ul>
<p>解决办法：用<code>SACK</code>来解决，即<strong>选择性重传</strong>，只重传丢失的包</p>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_resend.png" width="80%"></p>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_SACK.png" width="80%"></p>
<h4 id="拥塞控制">1.4.2.2 拥塞控制</h4>
<p>拥塞控制一般要经过以下步骤：</p>
<ul>
<li>慢启动（窗口大小指数上升），直到到达<strong>慢启动门限</strong></li>
<li>拥塞避免（窗口大小线性上升）</li>
<li>拥塞发生（<strong>更新慢启动门限、更新拥塞窗口</strong>）
<ul>
<li>方法1：<strong>超时重传</strong>
<ul>
<li>将<strong>慢启动门限</strong>设置为<strong>拥塞窗口的一半</strong></li>
<li>将<strong>拥塞窗口</strong>设置为<strong>1</strong>，会导致发送速度断崖式变慢</li>
<li>从<strong>慢启动</strong>开始<strong>指数</strong>增长
<img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_congestion.png" width="80%"></li>
</ul></li>
<li>方法2：<strong>快速重传</strong>
<ul>
<li>将<strong>慢启动门限</strong>设置为<strong>拥塞窗口的一半</strong></li>
<li>将<strong>拥塞窗口</strong>设置为跟<strong>慢启动门限</strong></li>
<li>从<strong>拥塞避免</strong>开始<strong>线性</strong>增长
<img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_congestion_2.png" width="80%"></li>
</ul></li>
</ul></li>
</ul>
<h2 id="tcp的拆包和粘包">1.5 TCP的拆包和粘包</h2>
<h3 id="拆包">1.5.1 拆包</h3>
<p>一个网络包的最大大小为<strong>MTU</strong>，一般为<strong>1500字节</strong></p>
<p>网络包中除开<strong>IP头和TCP头外</strong>外的数据包称为<strong>MSS</strong>，一般为<strong>1460字节</strong>，MSS中也包含了HTTP整个协议的头和content等内容</p>
<ul>
<li><code>MTU = IP头 + TCP头 + MSS</code></li>
</ul>
<p><img src="/2024/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/TCP_package.png" width="80%"></p>
<p>由于要求数据的最大大小为<strong>MSS</strong>，因此如果数据包大于<strong>MSS</strong>，那么就会<strong>拆包</strong>，将数据包拆分成多个包发送（也就是应用层的一个数据包被拆成多段进行发送）</p>
<h3 id="粘包">1.5.2 粘包</h3>
<p>TCP有一个<strong>Negle算法</strong>，会将多个小包合并成一个大包发送，这样可以减少网络包的数量，提高网络的利用率</p>
<p>但是由于TCP基于字节流是没有数据边界的，因此可能会出现<strong>粘包</strong>问题</p>
<p>解决办法是在<strong>应用层加一些边界（如HTTP、HTTPS协议）</strong></p>
<ul>
<li><strong>定长包</strong>：每个包的长度是固定的，不足的用空格填充</li>
<li><strong>特殊字符隔离</strong>：在每个包的末尾加上特殊字符，如<code>\r\n</code></li>
</ul>
<h1 id="二tcp和udp">二、TCP和UDP</h1>
<h2 id="tcp和udp的区别">2.1 TCP和UDP的区别</h2>
<p><strong>1）可靠性上</strong></p>
<ul>
<li>TCP：面向连接的协议，提供<strong>可靠传输</strong>，通过<strong>序列号</strong>和<strong>ACK确认</strong>机制保证数据的<strong>可靠传输</strong></li>
<li>UDP：无连接的协议，提供<strong>不可靠传输</strong></li>
</ul>
<p><strong>2）传输方式上</strong></p>
<ul>
<li>TCP：<strong>字节流传输</strong>，包没有边界（存在拆包粘包问题）</li>
<li>UDP：<strong>数据报传输</strong>，一个一个包发送的，包之间天然有边界</li>
</ul>
<p><strong>3）传输效率上</strong></p>
<ul>
<li>TCP：由于需要等待连接、等待重传、等待ACK确认等确保可靠性的机制，因此<strong>传输效率比UDP低</strong></li>
<li>UDP：传输效率高</li>
</ul>
<p><strong>4）应用场景</strong></p>
<ul>
<li>TCP：适用于<strong>要求可靠传输</strong>的场景，如<strong>文件传输</strong>、<strong>HTTP</strong>、<strong>HTTPS</strong>等</li>
<li>UDP：适用于<strong>实时性要求高</strong>的场景，如<strong>视频直播</strong>、<strong>语音通话</strong>、<strong>DNS</strong>等
<ul>
<li>如果视频用UDP，丢失数据只会丢失某一瞬间的画面，而TCP会等待重传，导致<strong>卡顿甚至卡死</strong></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络层</title>
    <url>/2024/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<blockquote>
<p>计算机网络层主要关注的就是<strong>IP、路由器、Ping-ICMP</strong>等内容，是<strong>传输层</strong>和<strong>应用层</strong>之间的桥梁，负责<strong>数据包的传输</strong>和<strong>路由选择</strong>等功能</p>
</blockquote>
<h2 id="一ip地址">一、IP地址</h2>
<p>IP用于在网络中<strong>唯一标识和定位网络中的设备</strong>，分为IPv4和IPv6两种，其中IPv4地址为32位(有地址枯竭问题)，IPv6地址为128位</p>
<ul>
<li>IPv4：划分为4个按点分，<strong>每部分8位</strong>，范围为0~255，如<code>255.255.255.0</code></li>
<li>IPv6：划分为8个按冒号分，<strong>每部分16位</strong>，如<code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></li>
</ul>
<p><strong>Mac地址与IP地址的区别：</strong></p>
<p>而Mac地址在数据链路层，是与<strong>网卡硬件</strong>绑定的，不会因为网络变化而变化，而<strong>IP地址是根据连接不同的网络而变化的</strong></p>
<ul>
<li>局域网中：通过Mac地址直接通信
<ul>
<li>mac是用于<strong>局域网设备</strong>通信的</li>
<li>mac地址在<strong>数据链路层</strong></li>
<li><strong>交换机</strong>工作在MAC层，主要实现<strong>局域网内</strong>的数据转发</li>
</ul></li>
<li>互联网中：通过IP地址路由传递信息的
<ul>
<li>IP用于<strong>不同网络之间</strong>的通信</li>
<li>IP地址在<strong>网络层</strong></li>
<li><strong>路由器</strong>工作在IP层，主要实现<strong>不同网络之间</strong>的数据转发</li>
</ul></li>
</ul>
<h2 id="二nat转换">二、NAT转换</h2>
<p>NAT转换协议是在<strong>网络层节约公有IP资源</strong>。</p>
<p>NAT转换可以将<strong>多个私有IP都转换成同一个公有IP</strong>，然后通过<strong>端口号</strong>来区分不同的设备，这样就可以<strong>减少公网IP的使用</strong></p>
<p><img src="/2024/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B1%82/NAT.png" width="70%"></p>
<h2 id="三ping和icmp协议">三、Ping和ICMP协议</h2>
<p>ping是通过<strong>ICMP</strong>协议实现的，通过发送ICMP包给目标主机来测试目标主机是否可到达（ping是不带端口的，也就是包最高到达网络层，所以无法探测某个主机内的某个程序是否可达）</p>
<p><img src="/2024/10/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B1%82/Ping.png" width="100%"></p>
<h2 id="四ddos攻击的预防">四、DDOS攻击的预防</h2>
<p>DDOS攻击是指黑客<strong>短时间内用大量的僵尸机发送请求，耗尽服务器资源</strong>，导致服务器无法正常工作</p>
<ul>
<li>应用层DDOS：DNS洪水攻击</li>
<li>传输层DDOS：SYN洪泛攻击</li>
<li>网络层DDOS</li>
</ul>
<p>预防方法：</p>
<ul>
<li><strong>限制某个IP访问频率</strong>、<strong>设置防火墙规则拉黑一些IP</strong></li>
<li>增加<strong>用户验证</strong></li>
<li>第三方DDOS防护服务</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式0：面对对象的8大设计原理</title>
    <url>/2024/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%848%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p>从<strong>底层</strong>思维来理解，面向对象是<strong>继承、封装、多态</strong>。
从<strong>抽象</strong>思维层面来理解，面向对象能<strong>隔离变化</strong>，将变化带来的影响降到最低。
从<strong>微观</strong>层面来看，面向对象可以实现<strong>各司其职</strong>（采用相同的抽象接口，通过不同的具体类实现不同的功能）</p>
</blockquote>
<blockquote>
<p>使用设计模式的最大优势是能<strong>抵御变化</strong>、实现<strong>代码复用</strong></p>
</blockquote>
<h2 id="一为设计模式原则的理解提供前景代码例子c">一、为设计模式原则的理解提供前景代码例子(C++)</h2>
<h3 id="未优化的代码">1.1 未优化的代码</h3>
<ul>
<li>高层模块：<code>MainForm</code>窗体类 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span>:</span><span class="keyword">public</span> Form&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        vector&lt;Line*&gt; lines;</span><br><span class="line">        vector&lt;Rect*&gt; rects;</span><br><span class="line">        <span class="comment">//画图程序用鼠标表达，用P1、P2表示鼠标的起始点和终点</span></span><br><span class="line">        Point P1;</span><br><span class="line">        Point P2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span><span class="params">(MouseEventArgs e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseUp</span><span class="params">(MouseEventArgs e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPaint</span><span class="params">(PaintEventArgs e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainForm::OnMouseDown</span><span class="params">(MouseEventArgs e)</span></span>&#123;<span class="comment">//当鼠标按下时，记录鼠标两点的位置</span></span><br><span class="line">    P1.x = e.X;</span><br><span class="line">    P1.y = e.Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Form::<span class="built_in">OnMouseDown</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainForm::OnMouseUp</span><span class="params">(MouseEventArgs e)</span></span>&#123;<span class="comment">//当鼠标抬起时，记录鼠标两点的位置</span></span><br><span class="line">    P2.x = e.X;</span><br><span class="line">    P2.y = e.Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rbLine.Checked)&#123;</span><br><span class="line">        lines.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Line</span>(P1, P2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rbRect.Checked)&#123;</span><br><span class="line">        <span class="comment">//P1和P2两点呈对角线，可以确定一个矩形</span></span><br><span class="line">        <span class="keyword">int</span> width = <span class="built_in">abs</span>(P1.x - P2.x);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="built_in">abs</span>(P1.y - P2.y);</span><br><span class="line">        rects.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(P1, width, height));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Refresh</span>();</span><br><span class="line"></span><br><span class="line">    Form::<span class="built_in">OnMouseUp</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainForm::OnPaint</span><span class="params">(PaintEventArgs e)</span></span>&#123;<span class="comment">//当执行Refresh()时，会调用OnPaint()方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//针对直线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        e.Graphics.<span class="built_in">DrawLine</span>(Pens::Black, </span><br><span class="line">        lines[i]-&gt;start.x, </span><br><span class="line">        lines[i]-&gt;start.y, </span><br><span class="line">        lines[i]-&gt;end.x, </span><br><span class="line">        lines[i]-&gt;end.y);<span class="comment">//取vector中的坐标点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//针对矩形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rects.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        e.Graphics.<span class="built_in">DrawRectangle</span>(Pens::Black, </span><br><span class="line">        rects[i]-&gt;left_top;</span><br><span class="line">        rects[i]-&gt;width, </span><br><span class="line">        rects[i]-&gt;height);<span class="comment">//取vector中的坐标点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Form::<span class="built_in">OnPaint</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>底层模块、细节类：<code>Line</code>和<code>Rect</code>操作类
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point start;</span><br><span class="line">    Point end;</span><br><span class="line">    <span class="built_in">Line</span>(Point start, Point end):<span class="built_in">start</span>(start), <span class="built_in">end</span>(end)&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point left_top;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="built_in">Rect</span>(Point left_top, <span class="keyword">int</span> width, <span class="keyword">int</span> height):<span class="built_in">left_top</span>(left_top), <span class="built_in">width</span>(width), <span class="built_in">height</span>(height)&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>未优化代码的流程图 <img src="/2024/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%848%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/1.png" width="80%" height="80%"></li>
</ul>
<h3 id="优化后的代码">1.2 优化后的代码</h3>
<ul>
<li>高层模块：<code>MainForm</code>窗体类 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainForm</span>:</span><span class="keyword">public</span> Form&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        vector&lt;Shape*&gt; shapes;<span class="comment">//针对所有类型（Line和Rect），需要多态性的值一定要用指针，因为可能会有多种派生类型</span></span><br><span class="line">        <span class="comment">//画图程序用鼠标表达，用P1、P2表示鼠标的起始点和终点</span></span><br><span class="line">        Point P1;</span><br><span class="line">        Point P2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MainForm</span>()&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseDown</span><span class="params">(MouseEventArgs e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMouseUp</span><span class="params">(MouseEventArgs e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnPaint</span><span class="params">(PaintEventArgs e)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainForm::OnMouseDown</span><span class="params">(MouseEventArgs e)</span></span>&#123;<span class="comment">//当鼠标按下时，记录鼠标两点的位置</span></span><br><span class="line">    P1.x = e.X;</span><br><span class="line">    P1.y = e.Y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Form::<span class="built_in">OnMouseDown</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainForm::OnMouseUp</span><span class="params">(MouseEventArgs e)</span></span>&#123;<span class="comment">//当鼠标抬起时，记录鼠标两点的位置</span></span><br><span class="line">    P2.x = e.X;</span><br><span class="line">    P2.y = e.Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rbLine.Checked)&#123;</span><br><span class="line">        shapes.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Line</span>(P1, P2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rbRect.Checked)&#123;</span><br><span class="line">        <span class="comment">//P1和P2两点呈对角线，可以确定一个矩形</span></span><br><span class="line">        <span class="keyword">int</span> width = <span class="built_in">abs</span>(P1.x - P2.x);</span><br><span class="line">        <span class="keyword">int</span> height = <span class="built_in">abs</span>(P1.y - P2.y);</span><br><span class="line">        shapes.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Rect</span>(P1, width, height));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">Refresh</span>();</span><br><span class="line"></span><br><span class="line">    Form::<span class="built_in">OnMouseUp</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainForm::OnPaint</span><span class="params">(PaintEventArgs e)</span></span>&#123;<span class="comment">//当执行Refresh()时，会调用OnPaint()方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制时将直线和矩形统一绘制</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        shapes[i]-&gt;<span class="built_in">draw</span>(e.Graphics);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Form::<span class="built_in">OnPaint</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>抽象：<code>Shape</code>抽象方法 &amp;&amp;
<code>Line</code>和<code>Rect</code>类继承于抽象方法 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Graphics g)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point start;</span><br><span class="line">    Point end;</span><br><span class="line">    <span class="built_in">Line</span>(Point start, Point end):<span class="built_in">start</span>(start), <span class="built_in">end</span>(end)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(Graphics g)</span></span>&#123;<span class="comment">//实现自己的绘画</span></span><br><span class="line">        g.<span class="built_in">DrawLine</span>(Pens::Black, </span><br><span class="line">        start.x, </span><br><span class="line">        start.y, </span><br><span class="line">        end.x, </span><br><span class="line">        end.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point left_top;</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">    <span class="built_in">Rect</span>(Point left_top, <span class="keyword">int</span> width, <span class="keyword">int</span> height):<span class="built_in">left_top</span>(left_top), <span class="built_in">width</span>(width), <span class="built_in">height</span>(height)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(Graphics g)</span></span>&#123;<span class="comment">//实现自己的绘画</span></span><br><span class="line">        g.<span class="built_in">DrawRectangle</span>(Pens::Black, </span><br><span class="line">        left_top,</span><br><span class="line">        width, </span><br><span class="line">        height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>未优化代码的流程图 <img src="/2024/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%848%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/2.png" width="80%" height="80%"></li>
</ul>
<h3 id="优化后代码的优点说明">1.3 优化后代码的优点说明</h3>
<ul>
<li><p>假设现在客户需求发生了变化，需要增加一个<code>Circle</code>类，那么在<strong>1.1</strong>中的代码中除了需要增加<code>Circle</code>类外，在<code>MainForm</code>中的代码也需要进行修改，首先vector需要增加一种新类型来存储<code>Circle</code>类，其次在<code>OnMouseUp</code>和<code>OnPaint</code>中也需要增加对<code>Circle</code>类的处理，需要改动的部分很多</p></li>
<li><p>而在<strong>1.2</strong>中的代码中，只需要增加一个<code>Circle</code>类，然后在<code>MainForm</code>的<code>OnMouseUp</code>中增加对<code>Circle</code>类的处理，这样就实现了<strong>隔离变化</strong>，将变化带来的影响降到最低。因为绘制的实现都抽象出draw方法由各个类去实现了，因此也不需要改动<code>OnPaint</code>方法</p></li>
</ul>
<h2 id="二设计模式的八大设计原则">二、设计模式的八大设计原则</h2>
<h3 id="依赖倒置原则dip">1. 依赖倒置原则（DIP）</h3>
<blockquote>
<p>高层模块（稳定）不应该依赖于底层模块（变化），二者都应该依赖于抽象（稳定）。</p>
</blockquote>
<blockquote>
<p>抽象（稳定）不应该依赖于细节（变化），细节（变化）应该依赖于抽象（抽象）。</p>
</blockquote>
<p>从<strong>二</strong>中的代码例子来分析这两句话，可以将代码中的各种类划分为：</p>
<ul>
<li>高层模块：比如<code>MainForm</code>窗体类（稳定）</li>
<li>底层模块、细节类：比如<code>Line</code>和<code>Rect</code>操作类（变化）</li>
<li>抽象：比如<code>Shape</code>抽象方法（稳定）</li>
</ul>
<p><strong>对第一句话（高层模块不应该依赖于底层模块，二者都应该依赖于抽象）的理解：</strong></p>
<ul>
<li><p>当使用<strong>1.1</strong>中未优化的MainForm设计代码时，Line和Rect还未继承于统一接口的基类，那么在<strong>MainForm</strong>中创建相关对象就会<strong>依赖于变化的Line和Rect类</strong>，这样就会导致MainForm的稳定性受到影响。</p></li>
<li><p>而当使用了<strong>1.2</strong>的抽象方法后，MainForm就直接依赖于稳定的抽象方法，而Line和Rect类继承于抽象方法，相当于被<strong>隔离</strong>了，这样MainForm就稳定了，后续两个变化类的改动也不会影响到MainForm的使用</p></li>
</ul>
<p><img src="/2024/02/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F0%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E7%9A%848%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/DIP1.png" width="80%" height="80%"></p>
<p><strong>对第二句话（抽象不应该依赖于细节，细节应该依赖于抽象）的理解：</strong></p>
<ul>
<li><p>在<strong>1.2</strong>中的代码中，抽象方法<code>Shape</code>不依赖于<code>Line</code>和<code>Rect</code>类，<strong>抽象方法提供的接口是稳定的、不变的</strong></p></li>
<li><p>而<code>Line</code>和<code>Rect</code>类依赖于<code>Shape</code>抽象方法提供的接口，这样就实现了抽象不依赖于细节，细节依赖于抽象的设计原则</p></li>
</ul>
<h3 id="开放封闭原则ocp">2. 开放封闭原则（OCP）</h3>
<blockquote>
<p>对<strong>扩展开放</strong>，对<strong>更改封闭</strong>。</p>
</blockquote>
<p><strong>对扩展开发、对更改封闭的理解：</strong></p>
<ul>
<li><p>这里的意思是指<strong>类模块应该是可扩展（被继承）的，但是不可修改（修改源类）的</strong></p></li>
<li><p>举个例子，有个家具加工厂，根据甲方要求生产了一批不防火的家具，后来甲方又要求生产防火家具</p>
<ul>
<li>这时候第一种做法是<strong>全面修改原来的家具生产线</strong>，但是这样会造成大量的修改工作，不符合开闭原则的类(生产原先家具的原始生产线不可修改)</li>
<li>而第二种做法是<strong>继承原来的家具生产线</strong>，然后在新的家具中添加（扩展）防火功能，比如涂上防火材料，这样就是符合对扩展开放，对更改封闭</li>
</ul></li>
<li><p>从上述例子可以看到，不符合OCP原则的话，会导致需要对源代码重新进行<strong>编译、测试、部署</strong>，<strong>改变的代价很高</strong></p></li>
<li><p>OPC要求我们在设计代码时：当<strong>需求变更</strong>的时候要求我们<strong>不要去改原始代码</strong>，而是<strong>去扩展原始代码</strong>，这样就能保证原始代码的稳定性</p></li>
</ul>
<h3 id="单一职责原则srp">3. 单一职责原则（SRP）</h3>
<blockquote>
<p>一个类应该<strong>只有一个引起它变化的原因</strong>
变化的方向隐含着类的责任</p>
</blockquote>
<p><strong>理解：</strong></p>
<ul>
<li><p>这个原则要求我们一个类的设计中不应该太臃肿，比如在一个类中存进了七八十种方法</p></li>
<li><p>在桥模式中，可以感受到这个原则的意义</p></li>
</ul>
<h3 id="liskov替换原则lsp----里氏替换原则">4. Liskov替换原则（LSP） --
里氏替换原则</h3>
<blockquote>
<p>子类必须能够替换它们的基类（IS-A）</p>
</blockquote>
<p><strong>理解：</strong></p>
<ul>
<li><p>这个原则是<strong>IS-A</strong>的另一种说法，意思就是说子类在继承父类是，必须是完全可以替换父类的，也就是说子类需要是可以继承并使用父类的所有公有接口的</p></li>
<li><p>比如当一个子类继承父类时，但是该子类又不可以用到父类中的某些方法，那么当他遇到这种使用父类的方法时就会出现问题，他可能会选择当Client用到这些方法时，选择直接抛出异常，这种就是不符合LSP原则的</p></li>
<li><p>又比如当两个类之间是组合关系时也不应该用继承关系，因为组合关系是<strong>HAS-A</strong>关系，而不是<strong>IS-A</strong>关系</p></li>
</ul>
<h3 id="接口隔离原则isp">5. 接口隔离原则（ISP）</h3>
<blockquote>
<p>不应该强迫客户程序依赖它们不用的方法 要求：接口要尽量小而完备</p>
</blockquote>
<p><strong>理解：</strong></p>
<ul>
<li><p>这个原则要求我们在设计类的公用接口时要谨慎，<strong>不要将一些客户端用不到的，仅有类内部使用的方法放到公用接口中</strong>。这种方法应该放在类的private中</p></li>
<li><p>因为一旦接口被设计成公有接口，客户端就会对这些公有接口产生依赖，这样一旦这些接口发生变化，就可能会导致客户端的代码也需要改动</p></li>
</ul>
<h3 id="优先使用对象组合而不是类继承cop">6.
优先使用对象组合，而不是类继承（COP）</h3>
<blockquote>
<p>类继承通常为<code>白箱复用</code>，对象组合通常为<code>黑箱复用</code></p>
</blockquote>
<p><strong>理解：</strong></p>
<ul>
<li>继承是<strong>强耦合</strong>的，比如父类发生改变，子类也会跟着改变，在某种程度上破坏了类的封装性</li>
<li>组合是<strong>弱耦合</strong>的，对象组合只要求被组合对象具有良好的接口</li>
</ul>
<h3 id="封装变化点">7. 封装变化点</h3>
<blockquote>
<p>封装<strong>变化点</strong>，就是封装那些可能变化的东西</p>
</blockquote>
<p><strong>理解：</strong></p>
<ul>
<li>这个原则要求我们在设计类的时候要<strong>尽量将可能变化的东西封装起来</strong>，比如将变化的东西抽象成一个接口，然后在类中使用这个接口，这样就可以实现<strong>隔离变化</strong>，将变化带来的影响降到最低（当设计者在具体类种进行修改时，对另一侧抽象类不造成影响）</li>
</ul>
<h3 id="针对接口编程而不是针对实现编程">8.
针对接口编程，而不是针对实现编程</h3>
<p><strong>理解：</strong></p>
<ul>
<li>这个原则要求我们在设计时，尽量不要将变量类型声明为某个特定的具体类，而是将其声明为某个接口（比如抽象接口）</li>
<li>这样可以减少代码的耦合</li>
<li>这个原则跟<strong>依赖倒置原则</strong>有一定的关联，一般违背了<strong>依赖倒置原则</strong>就会违背了<strong>针对接口编程，而不是针对实现编程原则</strong></li>
</ul>
<p><strong>举例说明</strong></p>
<ul>
<li>比如在<strong>1.1</strong>中的代码中，如果将<code>Line</code>和<code>Rect</code>类声明为具体类，那么在MainForm中的代码<code>vector&lt;Line*&gt; lines;``vector&lt;Rect*&gt; Rect;</code>就会导致MainForm对具体类的依赖</li>
<li>而如果像<strong>1.2</strong>中的代码一样，将<code>Line</code>和<code>Rect</code>类声明为抽象类<code>Shape</code>，那么MainForm就只依赖于抽象类，在代码中体现为<code>vector&lt;Shape*&gt; shapes;</code>，这样就实现了针对抽象接口Shape编程，而不是针对实现编程</li>
</ul>
<h2 id="三推荐一个讲得很好得设计模式课程">三、推荐一个讲得很好得设计模式课程</h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1Yr4y157Ci">C++设计模式入门</a></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式1：单例模式(C++)</title>
    <url>/2024/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p><a href="https://github.com/AkiraZheng/designPattern/tree/master/designPattern">本文中所有设计模式Github代码</a>
其中本文<strong>单例模式</strong>相关代码在<code>SingletonPattern.h</code>文件中</p>
</blockquote>
<h2 id="一单例模式的实现原理">一、单例模式的实现原理</h2>
<h3 id="什么是单例模式">1. 什么是单例模式</h3>
<p>单例模式是指某一个类在整个程序运行期间（系统生命周期），<strong>只有一个实例</strong>存在，因此要求构造函数是私有的(private)，同时在多线程场景下需要保证线程安全，即多个线程中不会创建多个实例对象。</p>
<h3 id="使用单例模式的优点">2. 使用单例模式的优点</h3>
<p><strong>节省资源：</strong>在内存中只有一个实例，<strong>减少了内存开销</strong>，可以<strong>避免对资源的多重占用</strong></p>
<p><strong>方便控制：</strong>设置全局访问点，严格控制访问范围，防止对象的重复创建，保证对象的唯一性，<strong>保证对象的线程安全</strong></p>
<h3 id="单例模式的应用场景">3. 单例模式的应用场景</h3>
<ul>
<li>要求生产唯一序列号</li>
<li>Web页面的计数器，不用每次刷新都在数据库中加一，使用单例可以在内存中缓存计数器值</li>
<li>创建一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等</li>
</ul>
<h3 id="单例模式的线程安全问题">4. 单例模式的线程安全问题</h3>
<p>一种最粗暴的线程安全方法就是在代码一运行就初始化创建实例</p>
<p>单例模式根据类中实例化对象的不同，可以分为<strong>饿汉式</strong>(线程不安全)和<strong>懒汉式</strong>(线程安全)</p>
<ul>
<li>饿汉式：在类加载时就创建对象实例，线程不安全，无法在多线程中保证单例</li>
<li>懒汉式：在类加载时不创建对象实例，而是在第一次调用时创建对象实例，可以在公有静态成员函数中，在实例化单例对象前进行同步加锁，保证线程安全</li>
</ul>
<h2 id="二单例模式的实现代码c">二、单例模式的实现代码（C++）</h2>
<p>单例模式在代码中的基本UML类图：</p>
<p><img src="/2024/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/Singleton.png" width="50%" heigh="50%"></p>
<p>单例模式代码实现的注意事项：</p>
<ul>
<li>类设计中<strong>构造方法置于私有区域</strong>，以防止外部创建对象</li>
<li>类中定义一个私有静态成员变量，用于指向单例对象
<ul>
<li>类中定义一个公有静态成员函数，用于获取单例对象
<code>static Singleton *getInstance()</code></li>
<li>根据该对象实例化的不同，可以分为<strong>饿汉式</strong>和<strong>懒汉式</strong></li>
</ul></li>
</ul>
<h3 id="饿汉式在类加载时就创建对象实例在代码一运行main之前就初始化创建实例">2.1
<strong>饿汉式：</strong>在类加载时就创建对象实例，在代码一运行main之前就初始化创建实例</h3>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonHungry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonHungry</span>()&#123;&#125;;              <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="keyword">static</span> SingletonHungry *instance; <span class="comment">// 静态成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">SingletonHungry</span>(<span class="keyword">const</span> SingletonHungry &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingletonHungry &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SingletonHungry &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试用</span></span><br><span class="line">    <span class="keyword">int</span> test_num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingletonHungry *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        test_num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> test_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类外定义，main开始执行前，该对象就存在了，本身就是线程安全的，整个程序中只有一个实例</span></span><br><span class="line">SingletonHungry *SingletonHungry::instance = <span class="keyword">new</span> <span class="built_in">SingletonHungry</span>();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSingletonHungry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;origin-&gt;getNum() = &quot;</span> &lt;&lt; SingletonHungry::<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getNum</span>() &lt;&lt; endl;</span><br><span class="line">    SingletonHungry *p1 = SingletonHungry::<span class="built_in">getInstance</span>();</span><br><span class="line">    SingletonHungry *p2 = SingletonHungry::<span class="built_in">getInstance</span>();</span><br><span class="line">    p1-&gt;<span class="built_in">resetNum</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1-&gt;getNum() = &quot;</span> &lt;&lt; p1-&gt;<span class="built_in">getNum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2-&gt;getNum() = &quot;</span> &lt;&lt; p2-&gt;<span class="built_in">getNum</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 = &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 = &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testSingletonHungry</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<h3 id="懒汉式在类加载时不创建对象实例而是在第一次调用时创建对象实例">2.2
<strong>懒汉式：</strong>在类加载时不创建对象实例，而是在第一次调用时创建对象实例</h3>
<h4 id="懒汉式的线程不安全形式">2.2.1 懒汉式的线程不安全形式</h4>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonLazy1</span>()&#123;&#125;;              <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="keyword">static</span> SingletonLazy1 *instance; <span class="comment">// 在类加载时不创建对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">SingletonLazy1</span>(<span class="keyword">const</span> SingletonLazy1 &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SingletonLazy1 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SingletonLazy1 &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> SingletonLazy1 *<span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">SingletonLazy1</span>(); <span class="comment">// 第一次调用时创建对象实例</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">SingletonLazy1 *SingletonLazy1::instance = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSingletonLazy1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SingletonLazy1 *p1 = SingletonLazy1::<span class="built_in">getInstance</span>();</span><br><span class="line">    SingletonLazy1 *p2 = SingletonLazy1::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 = &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 = &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<h4 id="懒汉式的双重检查锁定dcl即-double-checked-locking">2.2.2
懒汉式的双重检查锁定（DCL，即 double-checked locking）</h4>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在声明实例化对象时，使用volatile修饰保证线程安全，否则可能出现指令重排</span></span><br><span class="line"><span class="comment">* 也就是在一个线程内，执行instance = new SingletonLazy2_DCL();时，</span></span><br><span class="line"><span class="comment">  编译器可能会先分配内存空间，再初始化对象，最后将singleton指向分配的内存空间，</span></span><br><span class="line"><span class="comment">* 这样在多线程环境下，其他线程可能会在singleton初始化对象之后，</span></span><br><span class="line"><span class="comment">  指向分配的内存空间之前就访问了singleton，这样其他线程在执行if (instance == nullptr)时，会判断为false，但是此时singleton指向的对象还没指向内存空间，这样实际上其它线程返回的就是一个nuullptr指针，而不是一个实例化的对象</span></span><br><span class="line"><span class="comment">* 实现实例化 singleton = new Singleton() 可以分为3步</span></span><br><span class="line"><span class="comment">* 1.分配内存空间</span></span><br><span class="line"><span class="comment">* 2.初始化对象</span></span><br><span class="line"><span class="comment">* 3.将singleton指向分配的内存空间，避免指令重排</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonLazy2_DCL</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingletonLazy2_DCL</span>()&#123;&#125;;                       <span class="comment">// 构造函数私有化</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">static</span> SingletonLazy2_DCL *instance; <span class="comment">// 必须用volatile修饰</span></span><br><span class="line">    <span class="keyword">static</span> mutex mtx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">volatile</span> <span class="keyword">static</span> SingletonLazy2_DCL *<span class="title">getInstance</span><span class="params">()</span> <span class="comment">// 需要进行同步加锁，保证线程安全</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;                                          <span class="comment">// 第一次检查</span></span><br><span class="line">            mtx.<span class="built_in">lock</span>(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;                              <span class="comment">// 第二次检查,防止多个线程同时进入临界区</span></span><br><span class="line">                instance = <span class="keyword">new</span> <span class="built_in">SingletonLazy2_DCL</span>(); <span class="comment">// 创建实例</span></span><br><span class="line">            &#125;</span><br><span class="line">            mtx.<span class="built_in">unlock</span>(); <span class="comment">// 解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">volatile</span> SingletonLazy2_DCL *SingletonLazy2_DCL::instance = <span class="literal">nullptr</span>;</span><br><span class="line">mutex SingletonLazy2_DCL::mtx;<span class="comment">// 静态成员变量需要在类外初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testSingletonLazy2_DCL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> SingletonLazy2_DCL *p1 = SingletonLazy2_DCL::<span class="built_in">getInstance</span>();</span><br><span class="line">    <span class="keyword">volatile</span> SingletonLazy2_DCL *p2 = SingletonLazy2_DCL::<span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 = &quot;</span> &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 = &quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>
<p>指令重排在多线程下的危害如下：（线程B返回一个未初始化的instance对象）</p>
<p><img src="/2024/01/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F1%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/DCL.png" width="50%" heigh="50%"></p>
<h4 id="懒汉式的stdcall_oncec11保证某个函数在多线程环境中只被调用一次">2.2.3
懒汉式的<code>std::call_once</code>(C++11)，保证某个函数在多线程环境中只被调用一次</h4>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* instance;</span><br><span class="line">    <span class="keyword">static</span> std::once_flag onceFlag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化构造函数</span></span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止拷贝构造和赋值操作</span></span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取单例对象的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(onceFlag, []() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>
<h4 id="c11之后的局部静态变量是线程安全的">2.2.4
C++11之后的局部静态变量是线程安全的</h4>
<p>为了优雅地解决懒汉模式的线程安全问题，《Effective C++》（Item
04）中的提出另一种更优雅的单例模式实现，使用函数内的局部静态对象，这种方法不用加锁和解锁操作。(也就是将静态变量的声明放在函数内部，使其成为<strong>函数内的局部静态变量</strong>，而不是在类private或public中声明)</p>
<p>C++11之后，编译器要求保证局部静态变量的线程安全，所以这种方法不需要加锁也能由编译器自动保证线程安全的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">single</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> single* <span class="title">getinstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">single* <span class="title">single::getinstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> single obj;<span class="comment">//局部静态变量：线程安全的</span></span><br><span class="line">    <span class="keyword">return</span> &amp;obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三reference">三、Reference</h2>
<ol type="1">
<li><a href="https://blog.csdn.net/unonoi/article/details/121138176">【C++】C++
单例模式总结（5种单例实现方法）</a></li>
<li><a href="https://blog.csdn.net/trackxiaoxin321/article/details/110749781">C++设计模式之单例模式详解（懒汉模式、饿汉模式、双重锁）</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式2：工厂方法模式(C++)</title>
    <url>/2024/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p><a href="https://github.com/AkiraZheng/designPattern/tree/master/designPattern">本文中所有设计模式Github代码</a>
其中本文<strong>工厂方法模式-简单工厂</strong>相关代码在<code>FactoryMethod_SimpleFactory.h</code>文件中
本文<strong>工厂方法模式-工厂方法</strong>相关代码在<code>FactoryMethod.h</code>文件中</p>
</blockquote>
<blockquote>
<p>工厂方法中，一般一个应用中每一个工厂系列只需要一个ConcreteFactory类的实例，因此设计工厂类时，通常将其设计为单例模式</p>
</blockquote>
<h2 id="一简单工厂">一、简单工厂</h2>
<h3 id="什么是简单工厂">1. 什么是简单工厂</h3>
<p>简单工厂中，设计的核心思想是<strong>将对象的创建和使用分离</strong>，即将对象的创建交给工厂类（非抽象类），而将对象的使用交给客户端。</p>
<p>在<strong>简单工厂</strong>设计中，工厂类采用通常使用<strong>switch-case</strong>语句来根据不同的条件创建不同的对象，这样的设计是<strong>不符合开闭原则</strong>的，因为每次添加新的产品都需要修改工厂类的代码(在switch-case语句中加入新产品的create代码)，代码灵活性很差。</p>
<p>因此需要将简单工厂的设计升级为工厂方法模式，在工厂类中使用纯虚函数方法(createProduct方法)将其设计成抽象类。</p>
<blockquote>
<p>开闭原则：对扩展开放、对修改关闭；
也就是说，我们可以添加代码，但是添加代码的时候<strong>不能够对现有的代码进行修改</strong></p>
</blockquote>
<h3 id="简单工厂的代码">2. 简单工厂的代码</h3>
<ul>
<li>代码UML类图
<img src="/2024/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/SimpleFactory.png" width="90%" heigh="90%"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*产品类的设计：抽象基类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>&#123;</span></span><br><span class="line">    <span class="comment">// 产品基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string name):_phone_name(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Phone</span>()&#123;&#125;; <span class="comment">//基类应该被声明为虚析构函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _phone_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iphone</span>:</span><span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iphone</span>(string name):<span class="built_in">Phone</span>(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I have a phone named: &quot;</span> &lt;&lt; _phone_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaWei</span>:</span><span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HuaWei</span>(string name):<span class="built_in">Phone</span>(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I have a phone named: &quot;</span> &lt;&lt; _phone_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*工厂类的设计：非抽象类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span>&#123;</span></span><br><span class="line">    <span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">phone_type</span>&#123;</span></span><br><span class="line">        IPHONE,</span><br><span class="line">        HUAWEI</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> IPHONE:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Iphone</span>(<span class="string">&quot;iphone&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> HUAWEI:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HuaWei</span>(<span class="string">&quot;huawei&quot;</span>);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*测试函数*/</span></span><br><span class="line"><span class="comment">/*测试函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFactory_simpleFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PhoneFactory factory;</span><br><span class="line">    Phone* p1 = factory.<span class="built_in">createPhone</span>(PhoneFactory::IPHONE);</span><br><span class="line">    Phone* p2 = factory.<span class="built_in">createPhone</span>(PhoneFactory::HUAWEI);</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p2-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二工厂方法模式">二、工厂方法模式</h2>
<ol type="1">
<li><p>工厂方法相较于简单工厂的改进</p>
<ul>
<li>简单工厂中，<strong>产品基类</strong>是<strong>抽象</strong>的，而<strong>工厂类</strong>是<strong>非抽象</strong>的，这样的设计是不符合开闭原则的</li>
<li>工厂模式将<strong>工厂基类</strong>也设计成一个<strong>抽象</strong>的，并针对不同的产品类型设计不同的<strong>工厂派生类</strong>，这样在用户使用的时候可以很有目的性地选择对应的工厂派生类进行初始化，而不是简单工厂中的switch-case语句的随机性选择。</li>
</ul></li>
<li><p>工厂方法的缺点</p>
<ul>
<li>工厂方法模式的缺点是<strong>每增加一个产品，就需要增加一个产品工厂类</strong>，这样会导致工厂类的数量增加，增加了系统的复杂度。</li>
<li>工厂方法中的工厂类<strong>只有一个create方法</strong>，因此当产品不断增加时，需要的工厂派生类也不断增加，这样不利于管理，因此需要将工厂方法模式升级为<strong>抽象工厂模式</strong>。</li>
</ul></li>
</ol>
<h2 id="三工厂方法模式的实现代码c">三、工厂方法模式的实现代码（C++）</h2>
<blockquote>
<p>tips:使用智能指针需要引入头文件<code>#include &lt;memory&gt;</code>，使用普通指针<strong>new</strong>之后记得<strong>delete</strong></p>
</blockquote>
<ul>
<li>代码UML类图
<img src="/2024/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F2%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/FactoryMethod.png" width="90%" heigh="90%"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*产品类的设计：抽象基类*/</span></span><br><span class="line"><span class="comment">//1. 产品抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>&#123;</span></span><br><span class="line">    <span class="comment">// 产品基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string name):_phone_name(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Phone</span>()&#123;&#125;; <span class="comment">//基类应该被声明为虚析构函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _phone_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2. 产品派生具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iphone</span>:</span><span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Iphone</span>(string name):<span class="built_in">Phone</span>(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I have a phone named: &quot;</span> &lt;&lt; _phone_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaWei</span>:</span><span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">HuaWei</span>(string name):<span class="built_in">Phone</span>(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I have a phone named: &quot;</span> &lt;&lt; _phone_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：在工厂抽象类设计时，具体工厂一一对应用于new一个具体产品，当具体工厂类创建时，不同具体产品要求的的参数不同时，可以将参数也设计成一个抽象基类，这样在具体工厂类中可以根据不同的参数创建不同的产品。
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*工厂类的设计：抽象基类*/</span></span><br><span class="line"><span class="comment">//1. 工厂抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span>&#123;</span></span><br><span class="line">    <span class="comment">// 工厂类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Phone* <span class="title">createPhone</span><span class="params">(string name)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PhoneFactory</span>()&#123;&#125;; <span class="comment">//基类应该被声明为虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//2. 工厂派生具体类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IphoneFactory</span>:</span><span class="keyword">public</span> PhoneFactory&#123;</span><br><span class="line">    <span class="comment">// 工厂派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Iphone</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaWeiFactory</span>:</span><span class="keyword">public</span> PhoneFactory&#123;</span><br><span class="line">    <span class="comment">// 工厂派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">(string name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HuaWei</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*测试函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testFactory_factoryMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;PhoneFactory&gt; <span class="title">iPhoneFactory</span><span class="params">(<span class="keyword">new</span> IphoneFactory())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;PhoneFactory&gt; <span class="title">huaweiFactory</span><span class="params">(<span class="keyword">new</span> HuaWeiFactory())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Phone&gt; <span class="title">iphone</span><span class="params">(iPhoneFactory-&gt;createPhone(<span class="string">&quot;iphone&quot;</span>))</span></span>;<span class="comment">//通过单独的Iphone工厂创建对应产品</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Phone&gt; <span class="title">huawei</span><span class="params">(huaweiFactory-&gt;createPhone(<span class="string">&quot;huawei&quot;</span>))</span></span>;<span class="comment">//通过单独的HuaWei工厂创建对应产品</span></span><br><span class="line">    iphone-&gt;<span class="built_in">show</span>();</span><br><span class="line">    huawei-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四reference">四、Reference</h2>
<ol type="1">
<li><a href="https://blog.csdn.net/m0_46308273/article/details/117126962">C++工厂模式（简单工厂、工厂方法、抽象工厂）</a></li>
<li><a href="https://github.com/youngyangyang04/kama-DesignPattern/blob/main/DesignPattern/2-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.md">工厂方法模式</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式3：抽象工厂模式(C++)</title>
    <url>/2024/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p><a href="https://github.com/AkiraZheng/designPattern/tree/master/designPattern">本文中所有设计模式Github代码</a>
其中本文<strong>抽象工厂模式</strong>相关代码在<code>AbstractFactory.h</code>文件中</p>
</blockquote>
<h2 id="一抽象工厂模式">一、抽象工厂模式</h2>
<h3 id="什么是抽象工厂模式">1. 什么是抽象工厂模式</h3>
<p>抽象工厂模式是指<strong>提供一个创建一系列相关或相互依赖对象的接口</strong>，而无需指定它们具体的类。</p>
<p>抽象工厂模式是工厂方法模式的升级版：工厂方法中，一个工厂只能生产<strong>一种</strong>产品，当需要生产多种相关的产品时，如手机生产厂商<strong>既生产手机又生产手机壳</strong>，这时就需要使用抽象工厂模式，将手机和手机壳的生产分别交给两个工厂，再将工厂细分为具体的产品。</p>
<h3 id="抽象工厂模式优缺点">2. 抽象工厂模式优缺点</h3>
<h4 id="优点">优点</h4>
<ul>
<li><p>抽象工厂模式可以在<strong>不修改</strong>具体工厂类的情况下引入<strong>新的产品</strong>，即<strong>增加新的产品族</strong>，满足开闭原则</p></li>
<li><p>抽象工厂模式可以保证由<strong>同一个工厂类创建的产品</strong>之间的兼容性</p></li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li><p>抽象工厂模式的<strong>扩展性</strong>是有限的，<strong>增加新的产品族</strong>时，需要修改抽象工厂类，不符合开闭原则</p></li>
<li><p>客户(Client)必须知道抽象工厂的所有具体工厂类，才能根据需求创建对应的工厂实例</p></li>
</ul>
<h3 id="抽象工厂模式设计原理">3. 抽象工厂模式设计原理</h3>
<ul>
<li>依赖倒置原则：高层模块不应该依赖于底层模块，两者都应该依赖于抽象
<ul>
<li>这里的高层模块是指客户端，底层模块是指具体产品类，抽象工厂中客户端依赖于抽象工厂类，而不是具体工厂类，因此当工厂类产品系列更换时，只需要更换具体工厂类，客户端不需要修改代码</li>
</ul></li>
<li>开闭原则：对扩展开放、对修改关闭
<ul>
<li>当引入新的产品时，只需要增加对应产品的具体工厂类，而不需要修改抽象工厂类</li>
</ul></li>
<li>接口隔离原则：使用多个专门的接口，而不使用单一的总接口
<ul>
<li>抽象工厂模式中，每个具体工厂类都有自己的接口，而不是使用单一的总接口</li>
</ul></li>
</ul>
<h3 id="简单工厂工厂方法抽象工厂的区别">4.
简单工厂、工厂方法、抽象工厂的区别</h3>
<ul>
<li><p>简单工厂模式：一个工厂方法创建所有具体产品</p></li>
<li><p>工厂方法模式：一个工厂方法创建一个具体产品</p></li>
<li><p>抽象工厂模式：一个工厂方法可以创建一类具体产品</p></li>
</ul>
<h2 id="二抽象工厂模式的实现代码c">二、抽象工厂模式的实现代码（C++）</h2>
<ul>
<li>代码UML类图</li>
</ul>
<p><img src="/2024/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F3%EF%BC%9A%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/AbstractFactory.png" width="100%" heigh="100%"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*手机产品类的设计*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span>&#123;</span></span><br><span class="line">    <span class="comment">// 产品基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>(string name):_phone_name(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Phone</span>()&#123;&#125;; <span class="comment">//基类应该被声明为虚析构函数</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string _phone_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone_Iphone</span>:</span><span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone_Iphone</span>(string name):<span class="built_in">Phone</span>(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;手机工厂生产具体产品: &quot;</span> &lt;&lt; _phone_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone_Huawei</span>:</span><span class="keyword">public</span> Phone&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone_Huawei</span>(string name):<span class="built_in">Phone</span>(name)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;手机工厂生产具体产品: &quot;</span> &lt;&lt; _phone_name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*手机壳产品类的设计*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneShell</span>&#123;</span></span><br><span class="line">    <span class="comment">// 产品基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PhoneShell</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">PhoneShell</span>()&#123;&#125;; <span class="comment">//基类应该被声明为虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneShell_Iphone</span>:</span><span class="keyword">public</span> PhoneShell&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PhoneShell_Iphone</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;手机壳工厂生产具体产品: Iphone壳&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneShell_Huawei</span>:</span><span class="keyword">public</span> PhoneShell&#123;</span><br><span class="line">    <span class="comment">// 产品派生类</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="built_in">PhoneShell_Huawei</span>()&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;手机壳工厂生产具体产品: Huawei壳&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*工厂类的设计*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span>&#123;</span></span><br><span class="line">    <span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Phone* <span class="title">createPhone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PhoneShell* <span class="title">createPhoneShell</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractFactory</span>()&#123;&#125;; <span class="comment">//基类应该被声明为虚析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory_Iphone</span>:</span><span class="keyword">public</span> AbstractFactory&#123;</span><br><span class="line">    <span class="comment">// 具体苹果工厂类</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Phone_Iphone</span>(<span class="string">&quot;Iphone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PhoneShell* <span class="title">createPhoneShell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PhoneShell_Iphone</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory_Huawei</span>:</span><span class="keyword">public</span> AbstractFactory&#123;</span><br><span class="line">    <span class="comment">// 具体华为工厂类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Phone* <span class="title">createPhone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Phone_Huawei</span>(<span class="string">&quot;Huawei&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PhoneShell* <span class="title">createPhoneShell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">PhoneShell_Huawei</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*测试函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbstractFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">iphoneFactory</span><span class="params">(<span class="keyword">new</span> PhoneFactory_Iphone())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;AbstractFactory&gt; <span class="title">huaweiFactory</span><span class="params">(<span class="keyword">new</span> PhoneFactory_Huawei())</span></span>;</span><br><span class="line">    <span class="function">unique_ptr&lt;Phone&gt; <span class="title">iphone</span><span class="params">(iphoneFactory-&gt;createPhone())</span></span>;<span class="comment">//通过单独的Iphone工厂创建手机产品</span></span><br><span class="line">    <span class="function">unique_ptr&lt;PhoneShell&gt; <span class="title">iphoneShell</span><span class="params">(iphoneFactory-&gt;createPhoneShell())</span></span>;<span class="comment">//通过单独的Iphone工厂创建手机壳产品</span></span><br><span class="line">    <span class="function">unique_ptr&lt;Phone&gt; <span class="title">huawei</span><span class="params">(huaweiFactory-&gt;createPhone())</span></span>;<span class="comment">//通过单独的HuaWei工厂创建手机产品</span></span><br><span class="line">    <span class="function">unique_ptr&lt;PhoneShell&gt; <span class="title">huaweiShell</span><span class="params">(huaweiFactory-&gt;createPhoneShell())</span></span>;<span class="comment">//通过单独的HuaWei工厂创建手机壳产品</span></span><br><span class="line">    iphone-&gt;<span class="built_in">show</span>();</span><br><span class="line">    iphoneShell-&gt;<span class="built_in">display</span>();</span><br><span class="line">    huawei-&gt;<span class="built_in">show</span>();</span><br><span class="line">    huaweiShell-&gt;<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三reference">三、Reference</h2>
<ol type="1">
<li><a href="https://blog.csdn.net/m0_46308273/article/details/117126962">C++工厂模式（简单工厂、工厂方法、抽象工厂）</a></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式4：代理模式(C++)</title>
    <url>/2024/02/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F4%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p><a href="https://github.com/AkiraZheng/designPattern/tree/master/designPattern">本文中所有设计模式Github代码</a>
其中本文<strong>代理模式</strong>相关代码在<code>ProxyPattern.h</code>文件中</p>
</blockquote>
<h2 id="一代理模式基础">一、代理模式基础</h2>
<h3 id="代理模式的使用场景">1. 代理模式的使用场景</h3>
<blockquote>
<p>当某些对象由于某些原因，<strong>不能直接访问另一个对象</strong>，需要<strong>通过一个代理对象来间接访问</strong>时，可以使用代理模式。</p>
</blockquote>
<blockquote>
<p>某些原因指的是比如：对象创建的开销大、某些操作需要安全控制、需要访问进程外的对象等。</p>
</blockquote>
<blockquote>
<p>在<strong>分布式系统</strong>中，代理模式的使用极其广泛，例如在分布式系统中，客户端和服务器端的交互，客户端无法直接访问服务器端的对象，需要通过代理对象来访问服务器端的对象。</p>
</blockquote>
<h3 id="代理模式的定义">2. 代理模式的定义</h3>
<p>代理模式是一种结构型设计模式，它可以<strong>为其他对象提供一种代理以控制对这个对象的访问</strong></p>
<p>代理类和被代理类<strong>有相同的接口</strong>（继承同一个基类），代理类主要负责为被代理类预处理消息、过滤消息、把消息转发给被代理类，以及事后处理消息等。</p>
<h2 id="二代理模式的实现c">二、代理模式的实现(C++)</h2>
<p>在没有使用代理模式时，Client有一个需求是需要new一个RealSubject对象，然后调用其方法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Isubject</span>&#123;</span></span><br><span class="line">    <span class="comment">// 抽象基类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>:</span><span class="keyword">public</span> Isubject&#123;</span><br><span class="line">    <span class="comment">// 真实主题类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;RealSubject::Request()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>&#123;</span></span><br><span class="line">    Isubject* _subject;</span><br><span class="line">    <span class="comment">// 客户端</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Client</span>()&#123;</span><br><span class="line">            _subject = <span class="keyword">new</span> <span class="built_in">RealSubject</span>();<span class="comment">//客户端需要使用一个RealSubject对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">            _subject-&gt;<span class="built_in">Request</span>();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中中，我们可以看到，Client需要new一个RealSubject对象，然后调用其方法。但是由于某些原因，Client是无法实现直接new一个RealSubject对象</p>
<p>那么这个时候需要通过<strong>一个代理对象Proxy</strong>来间接访问RealSubject对象</p>
<p>在代理模式中，<strong>代理类Proxy</strong>和<strong>被代理类RealSubject</strong>都<strong>继承自同一个基类Isubject</strong>，这样可以保证代理类和被代理类有相同的接口。Proxy就可以在这个接口上实现对RealSubject的一系列代理操作</p>
<p>Proxy在这个接口上可以创建一个RealSubject对象，然后调用其方法，Client通过Proxy来间接访问RealSubject对象；也可能在如<strong>分布式</strong>的场景下，Proxy在这个接口上可以通过网络访问RealSubject对象，然后调用其方法，Client通过Proxy来间接访问RealSubject对象。因此Proxy这个接口的实现方式是复杂多变的，这里介绍设计模式，因此将其简化了，旨在理解它的实现流程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Isubject</span>&#123;</span></span><br><span class="line">    <span class="comment">// Proxy和RealSubject共同继承的抽象基类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span>:</span><span class="keyword">public</span> Isubject&#123;</span><br><span class="line">    <span class="comment">// 真实主题类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;RealSubject::Request()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span>:</span><span class="keyword">public</span> Isubject&#123;</span><br><span class="line">    <span class="comment">// 代理类</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//实现一系列复杂的代理操作，来对RealSubject进行访问</span></span><br><span class="line">            <span class="comment">//有些框架会用自动工具来生成代理</span></span><br><span class="line">            <span class="comment">//不同代理类的内部实现粒度和方法都是相差很大的，但是具体实现思想是一致的（Proxy和RealSubject用相同的接口）</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span>&#123;</span></span><br><span class="line">    Isubject* _subject;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Client</span>()&#123;</span><br><span class="line">            _subject = <span class="keyword">new</span> <span class="built_in">Proxy</span>();<span class="comment">//客户端需要使用一个Proxy对象</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">DoTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">            _subject-&gt;<span class="built_in">Request</span>();<span class="comment">//通过Proxy类间接访问RealSubject对象</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里Proxy和RealSubject共同继承的抽象基类Isubject，以通过同一个接口名的接口来实现Client实际想实现的对RealSubject的访问操作，好处是Client不用同时记住代理类和实际类的接口名，只需要知道抽象类的接口名就行，这种方法可以使客户端感觉是在对RealSubject进行操作。这种设计也是<strong>符合设计模式的开闭原则</strong>的，即对扩展开放，对修改关闭。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式5：模板方法</title>
    <url>/2024/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p><a href="https://github.com/AkiraZheng/designPattern/tree/master/designPattern">本文中所有设计模式Github代码</a>
其中本文<strong>模板方法</strong>相关代码在<code>TemplateMethodPattern.h</code>文件中</p>
</blockquote>
<h2 id="一模板方法基础">一、模板方法基础</h2>
<h3 id="模板方法的提出">1. 模板方法的提出</h3>
<blockquote>
<p>对于某项具体任务，模板方法模式常常拥有<strong>稳定的整体操作结构</strong>，但各个<strong>子步骤</strong>的具体实现可能<strong>各不相同</strong>（改变的）。那么如何在稳定的操作结构前提下，灵活<strong>应变各个子步骤的变化</strong>或者晚期实现需求？</p>
</blockquote>
<h3 id="模板方法的设计思想代码实现c">2.
模板方法的设计思想&amp;&amp;代码实现（C++）</h3>
<p>已知在程序开发中，框架开发人员（程序库开发人员）常常会提供一些<strong>稳定的操作结构和方法</strong>，而一些可变的具体的操作步骤则由<strong>应用开发人员</strong>来实现。这种情况下，框架开发人员可以使用<strong>模板方法模式</strong>来实现</p>
<h4 id="模板方法使用场景示例">2.1 模板方法使用场景示例</h4>
<p>假设我们需要设定一系列<strong>步骤step1~step5</strong>来实现某项功能，其中<strong>step1、step3、step5</strong>的实现是<strong>稳定的</strong>，可以在<strong>程序库lib开发</strong>中实现</p>
<p>但是<strong>step2和step4</strong>的实现是<strong>不稳定</strong>的，需要在<strong>应用开发</strong>中实现</p>
<p>而<strong>整体的step1~step5</strong>的步骤顺序和使用框架是<strong>稳定</strong>的</p>
<p><img src="/2024/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/step.png"></p>
<h4 id="未使用模板方法的代码实现思路">2.2
未使用模板方法的代码实现思路</h4>
<p>当我们没有采用模板方法模式时，我们会在<strong>程序库lib开发</strong>中提供<strong>step1、step3、step5</strong>的<strong>稳定</strong>实现，然后在<strong>应用开发</strong>中提供<strong>step2和step4</strong>的<strong>不稳定</strong>实现。最后在main程序中实现<strong>step1~step5</strong>的调用来实现具体功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序库开发人员</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Library::step1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Library::step3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Library::step5()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">step2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Application::step2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Application::step4()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Library lib;</span><br><span class="line">    Application app;</span><br><span class="line"></span><br><span class="line">    lib.<span class="built_in">step1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(app.<span class="built_in">step2</span>())&#123;<span class="comment">//step2的实现是不稳定的</span></span><br><span class="line">        lib.<span class="built_in">step3</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        app.<span class="built_in">step4</span>();<span class="comment">//step4的实现是不稳定的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lib.<span class="built_in">step5</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法属于<strong>早绑定</strong>的实现方式，在<strong>结构化</strong>的设计思维，也就是<strong>晚实现的应用程序人员开发程序</strong>去调用<strong>更早实现的lib库</strong></p>
<p><img src="/2024/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/early_bind.png"></p>
<p>这种实现方法是有缺点的：对于稳定的<strong>step1~step5</strong>的调用是<strong>分散</strong>的，<strong>不利于维护</strong></p>
<h4 id="使用模板方法的代码实现思路">2.3 使用模板方法的代码实现思路</h4>
<p>解决上述问题的方法思路是：</p>
<p>将<strong>稳定的</strong>main函数中的<strong>整体步骤实现</strong>也放在稳定的程序库lib中，然后在应用开发中实现不稳定的步骤</p>
<p>由于lib库中也需要用到app的实现，因此我们可以将两个不稳定的函数<strong>作为lib库的虚函数</strong>，交由<strong>应用程序开发人员继承实现</strong></p>
<p>这样在main中直接创建一个lib库的多态指针，然后调用lib的<strong>整体实现步骤框架函数</strong>就可以</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 程序库开发人员</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Library</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Library::step1()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Library::step3()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Library::step5()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">step1</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step2</span>())&#123;<span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">            <span class="built_in">step3</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">step4</span>();<span class="comment">//支持变化 ==&gt; 虚函数的多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">step5</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">step2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">step4</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 应用程序开发人员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span>:</span><span class="keyword">public</span> Library</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">step2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Application::step2()&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Application::step4()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Library* plib = <span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">    plib-&gt;<span class="built_in">run</span>();</span><br><span class="line">    <span class="keyword">delete</span> plib;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法属于<strong>晚绑定</strong>的实现方式，是<strong>面向对象开发</strong>的设计思维，也就是<strong>早实现的lib库</strong>通过开发稳定的算法骨架（Run函数），并将一些步骤延迟（延迟也就是虚函数）到<strong>晚实现的应用程序开发人员</strong>去实现</p>
<p><img src="/2024/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F5%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/late_bind.png"></p>
<h2 id="二总结">二、总结</h2>
<ul>
<li><p>在面向对象的设计中，我们要将<strong>稳定的代码</strong>写成<strong>非虚函数</strong>，将<strong>不稳定</strong>的代码写成<strong>虚函数</strong>，这样可以实现<strong>稳定代码的复用</strong>，<strong>不稳定代码的延迟实现</strong></p></li>
<li><p>设计模式的假设是必须有一个稳定点，那么当所有代码都是不稳定的时候，就不适合使用设计模式了</p></li>
<li><p><strong>设计模式</strong>最大的特点是在<strong>变化和稳定</strong>中间寻找隔离点，将变化的部分通过虚函数隔离出来，使得稳定的部分不受影响</p></li>
<li><p>虚函数是面向对象里面最核心的晚绑定实现技术</p></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>部署colab利用GPU资源训练深度学习模型</title>
    <url>/2022/03/13/%E9%83%A8%E7%BD%B2colab%E5%88%A9%E7%94%A8GPU%E8%B5%84%E6%BA%90%E8%AE%AD%E7%BB%83%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>深度学习模型需要GPU加持提高训练速度，但是目前GPU和许多云端租借的GPU价格昂贵，因此本文将用谷歌团队的colab实现免费GPU的使用，满足深度学习的个人学习需求</p>
<h1 id="以下链接为部署原文">以下链接为部署原文</h1>
<p>参考网站： <a href="https://blog.csdn.net/u011119817/article/details/108519389">Colab基本使用方法及配置</a></p>
<h1 id="目前所用到的代码功能">目前所用到的代码功能</h1>
<p>1、查看GPU资源</p>
<p><font color="white"></font></p>
<pre><code># 查看GPU资源
!nvidia-smi</code></pre>
<p></p>
<p>2、连接谷歌云端硬盘</p>
<p><font color="white"></font></p>
<pre><code># 连接谷歌云端硬盘
from google.colab import drive
drive.mount(&#39;/content/drive&#39;)</code></pre>
<p></p>
<p>3、查看库版本</p>
<p><font color="white"></font></p>
<pre><code># 查看版本
import scipy
scipy.__version__</code></pre>
<p></p>
<p>4、 pip安装库</p>
<p><font color="white"></font></p>
<pre><code># pip安装库
!pip install scipy==1.2.1</code></pre>
<p></p>
<p>5、运行代码-训练模型</p>
<p><font color="white"></font></p>
<pre><code># 运行代码
import os
path = &quot;/content/drive/MyDrive/srcnn-tensorflow-image-master&quot; 
os.chdir(path)
os.listdir(path)
!python main.py</code></pre>
<p></p>
<p>6、部署github项目到colab</p>
<blockquote>
<p><a href="https://blog.csdn.net/weixin_47306605/article/details/123921943?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-123921943-blog-121534768.235%5Ev43%5Econtrol&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">参考链接</a></p>
</blockquote>
<h1 id="解决colab每12h断连的问题">解决Colab每12h断连的问题</h1>
<p>每60分钟自动运行代码刷新，解除90分钟断开限制.</p>
<p>使用方法：colab页面按下 <strong>F12</strong>或者 Ctrl+Shift+I (mac按
Option+Command+I)
在<strong>console（控制台）</strong>输入以下代码并回车.</p>
<p><strong>复制以下代码粘贴在浏览器console！！不要关闭浏览器以免失效</strong></p>
<pre><code>function ClickConnect()&#123;
  colab.config
  console.log(&quot;Connnect Clicked - Start&quot;); 
  document.querySelector(&quot;#top-toolbar &gt; colab-connect-button&quot;).shadowRoot.querySelector(&quot;#connect&quot;).click();
  console.log(&quot;Connnect Clicked - End&quot;);
&#125;;
setInterval(ClickConnect, 60000)</code></pre>
]]></content>
      <tags>
        <tag>环境配置</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式6：策略模式</title>
    <url>/2024/02/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F6%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<blockquote>
<p><a href="https://github.com/AkiraZheng/designPattern/tree/master/designPattern">本文中所有设计模式Github代码</a>
其中本文<strong>策略模式</strong>相关代码在<code>StrategyPattern.h</code>文件中</p>
</blockquote>
<h2 id="一策略模式基础">一、策略模式基础</h2>
<h3 id="策略模式的提出">1. 策略模式的提出</h3>
<blockquote>
<p>在代码构建过程中，某些<strong>对象的算法可能有多种实现</strong>（例如不同的排序算法、查找算法等），我们可以根据环境或者条件的不同选择不同的算法来完成任务。
如果<strong>将这些算法都封装到对象中</strong>，将会使对象变得很复杂，有时候支持不需要的算法也是一种<strong>负担</strong>。
那么如何<strong>在运行时根据环境或者条件的不同选择不同的算法</strong>来完成任务？</p>
</blockquote>
<h3 id="策略模式的设计思想代码实现c">2.
策略模式的设计思想&amp;&amp;代码实现（C++）</h3>
<h4 id="策略模式使用场景示例">2.1 策略模式使用场景示例</h4>
<p>假设我们需要实现一个<strong>不同国家的税率计算算法</strong>，我们需要面对不同国家具有不同税率的问题</p>
<h4 id="未使用策略模式的代码实现思路">2.2
未使用策略模式的代码实现思路</h4>
<p>当我们没有采用策略模式时，我们会在<strong>一个类</strong>中提供<strong>不同国家的税率计算算法</strong>，然后在main程序中实现<strong>不同国家的税率计算算法</strong>的调用来实现具体功能</p>
<p>在这种情况下，我们可能会想到通过枚举方法来代表不同的国家，然后在类中通过if-else语句来判断不同国家的税率计算算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 未使用策略模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TexType</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CN_TAX,</span><br><span class="line">    US_TAX,</span><br><span class="line">    JP_TAX</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TexType type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == CN_TAX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == US_TAX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type == JP_TAX)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>但是很多情况下，业务需求变化是很快的，我们可能随时需要增加对新国家的税率计算算法，这样的话，我们就需要修改<code>SalesOrder</code>类，也要改变枚举值，这样的话，我们就违反了<strong>开闭原则</strong>，所以我们需要使用策略模式来解决这个问题</p>
<p>策略模式通常还需要结合<strong>工厂模式</strong>来使用，这样可以更好的解耦</p>
<h4 id="使用策略模式的代码实现思路">2.3 使用策略模式的代码实现思路</h4>
<p>当我们采用策略模式时，我们会在<strong>一个类</strong>中提供一个<strong>抽象的策略类</strong>，然后在<strong>不同国家的税率计算算法</strong>中继承这个抽象的策略类，然后在main程序中实现<strong>不同国家的税率计算算法</strong>的调用来实现具体功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用策略模式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//将税率计算算法抽象为一个虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaxStrategy</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span> <span class="keyword">public</span> TaxStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JPTax</span> :</span> <span class="keyword">public</span> TaxStrategy</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;<span class="comment">//提供一个抽象的策略类的多态指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SalesOrder</span>(TaxStrategy* strategy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy-&gt;<span class="built_in">Calculate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SalesOrder</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SalesOrder* order = <span class="keyword">new</span> <span class="built_in">SalesOrder</span>(<span class="keyword">new</span> <span class="built_in">CNTax</span>());<span class="comment">//new CNTax()这里可以通过工厂模式将其抽象出来</span></span><br><span class="line">    cout &lt;&lt; order-&gt;<span class="built_in">CalculateTax</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> order;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，我们只需要添加一个继承自<code>TaxStrategy</code>的新类，不需要修改<code>SalesOrder</code>类，这样就符合了<strong>开闭原则</strong></p>
<h4 id="策略模式结合简单工厂抽象化">2.4 策略模式结合简单工厂抽象化</h4>
<p>在上述代码中，我们可以看到<code>new CNTax()</code>这里可以通过简单工厂方法将其抽象出来，这样可以更好的解耦</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategyFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> TaxStrategy* <span class="title">CreateTaxStrategy</span><span class="params">(TexType type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (type)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> CN_TAX:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">CNTax</span>();</span><br><span class="line">        <span class="keyword">case</span> US_TAX:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">USTax</span>();</span><br><span class="line">        <span class="keyword">case</span> JP_TAX:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">JPTax</span>();</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SalesOrder* order = <span class="keyword">new</span> <span class="built_in">SalesOrder</span>(TaxStrategyFactory::<span class="built_in">CreateTaxStrategy</span>(CN_TAX));</span><br><span class="line">    cout &lt;&lt; order-&gt;<span class="built_in">CalculateTax</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> order;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就可以通过工厂模式将<code>new CNTax()</code>这里抽象出来，这样可以更好的解耦，当然<code>TaxStrategyFactory</code>的实现还可以进一步设计成抽象接口，将其改造为工厂方法模式，这里就不再赘述</p>
<h2 id="二总结">二、总结</h2>
<ul>
<li><p>策略模式使得<strong>算法可以独立于客户程序</strong>（稳定，如SalesOrder）而变化（不稳定、扩展，如CNTax、USTax、JPTax）</p></li>
<li><p>策略模式提供一系列可变的算法，客户程序在运行时只需要<strong>关心接口</strong>，不需要关心算法的内部实现细节</p></li>
<li><p>在代码中当出现<strong>if-else</strong>语句 or
<strong>switch-case</strong>语句时，一般就是<strong>需要使用策略模式</strong>的时候了（使用策略模式抽象化代替if-else语句
or
switch-case语句）(只有在if-else是绝对不变的情况下可以不用将其优化为策略模式，比如一周只有7天，这种确定情况下就不需要优化为策略模式)</p></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>重装系统后Hexo博客部署教程</title>
    <url>/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="前言">前言</h1>
<p>本文针对已经在别的电脑或系统上搭建过Hexo博客，准备重新在新电脑或系统上搭建回之前的博客，也就是说，之前已经在gthub账号上有建立过博客仓库了。</p>
<p>在重新搭建前保证自己以前的blog文件夹中以下文件有被拷贝备份下来：</p>
<table>
<thead>
<tr>
<th style="text-align: left;">文件夹/文件</th>
<th style="text-align: left;">拷贝内容</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">/blog目录下的文件</td>
<td style="text-align: left;">除landscape外的.yml文件</td>
</tr>
<tr>
<td style="text-align: left;">/blog目录下的文件</td>
<td style="text-align: left;">package.json文件</td>
</tr>
<tr>
<td style="text-align: left;">/blog目录下的文件夹</td>
<td style="text-align: left;">scaffolds、source、themes三个文件夹</td>
</tr>
</tbody>
</table>
<p>零基础建立、搭载博客可以参考b站视频：</p>
<p><a href="https://www.bilibili.com/video/BV1cW411A7Jx?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">手把手教你搭建属于自己的hexo+github博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">手把手教你从0开始搭建自己的个人博客
|无坑版视频教程| hexo</a></p>
<p><a href="https://blog.csdn.net/muzihuaner/article/details/113880520">Hexo博客搭建与部署</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/606083588">hexo&amp;github
搭建博客（保姆级）</a></p>
<blockquote>
<p>注意：若是在<strong>Git Bash
here</strong>中输入hexo执行指令，则不需要输入<strong>hexo
-s</strong>，直接输入<strong>hexo s</strong>即可</p>
</blockquote>
<h1 id="博客重新搭载操作">博客重新搭载操作</h1>
<h2 id="一软件下载">一、软件下载</h2>
<ul>
<li><p>到<a href="https://nodejs.org/en/">nodejs官网</a>下载<strong>nodejs</strong>软件并安装</p>
<p>cmd中输入<code>node -v</code>确认版本及确认已安装完毕</p></li>
<li><p>下载<a href="https://gitforwindows.org/"><strong>Git</strong></a>软件并安装</p>
<p>cmd中输入<code>git</code>确认版本及确认已安装完毕</p></li>
</ul>
<h2 id="二建立本机与github的联系">二、建立本机与github的联系</h2>
<ul>
<li><p>Git下载完后，双击安装Git目录下的<strong>git-bash.exe</strong>，输入<code>ssh-keygen -t rsa -C "github对应的邮箱账号"</code>，然后直接回车3次（无脑回车即可），将会生产本机对应的SSH号存于C盘Users上的<strong>id_rsa.pub</strong>文件中（如果找不到该文件，可以下载Everything软件直接搜索文件名，可以快速找到文件的位置）</p></li>
<li><p>用记事本打开id_rsa文件，Ctrl+A全选复制文件的全部内容</p></li>
<li><p>重新建立github与本机的联系</p>
<ul>
<li><p>打开github的<strong>settings</strong>，点击<strong>SSH and GPG
keys</strong>，点击<strong>New SSH
key</strong>创建github与新系统的联系</p></li>
<li><p>其中<strong>title</strong>填写github的用户名即可，<strong>key</strong>填写在id_rsa.pub中复制的文件内容，也就是SSH号，完成后点击<strong>Add
SSH key</strong>即可</p></li>
</ul></li>
<li><p>打开cmd输入<code>npm install hexo-cli -g</code>安装hexo</p>
<ul>
<li>mac先通过sudo su进入root用户，再全局安装hexo</li>
<li>mac用sudo指令，否则会有权限问题<code>sudo npm install -g hexo-cli</code>安装hexo</li>
<li><a href="https://blog.csdn.net/laosao_66/article/details/135880270">npm安装hexo时更换镜像源</a>
<ul>
<li><code>npm config set registry http://registry.npm.taobao.org</code></li>
</ul></li>
</ul></li>
<li><p>新建blog文件夹，之后的博客搭载将全部在该文件夹中进行，如果出现什么错误不要慌，把这个文件夹干掉重新建立再次进行下面的步骤即可</p>
<ul>
<li><p>cmd中进入对应的盘(如<code>D:</code>)，进而进入新建的blog文件夹（如<code>cd MyBlog\blog</code>）</p></li>
<li><p>输入<code>hexo init</code>(若是将以前可正常运行的完整blog路径拷贝下来，里面已有环境在，则不需要进行此步骤)</p></li>
<li><p>输入<code>npm install</code></p></li>
<li><p>最后输入<code>hexo s</code>，复制链接（我这里cmd给的链接是<code>http://localhost:4000</code>），到浏览器浏览该链接可以看到最简单的hexo博客界面</p></li>
<li><p>将<strong>前言</strong>中备份的旧博客文件及文件夹全部复制到新的<strong>blog文件夹</strong>中，替换新blog文件夹的内容</p></li>
<li><p>继续在blog路径的cmd下输入<code>npm install hexo-deployer-git --save</code>安装环境</p></li>
<li><p>按需添加博客加密<code>npm install hexo-blog-encrypt</code></p>
<ul>
<li>参考：<a href="https://blog.csdn.net/qq_42951560/article/details/122552109">【Hexo】静态博客设置文章加密访问</a></li>
</ul></li>
</ul></li>
<li><p>之后便可以继续用<code>hexo s</code>查看hexo博客，此时的博客已经恢复成旧博客的内容了</p></li>
</ul>
<h2 id="三部署博客到github上">三、部署博客到github上</h2>
<ul>
<li><p>记得操作时用<code>hexo clean</code>清理环境，如果出现问题也可以重新打开cmd</p>
<ul>
<li><p>cmd中进入对应的盘(如<code>D:</code>)，进而进入新建的blog文件夹（如<code>cd MyBlog\blog</code>）</p></li>
<li><p>输入<code>hexo g</code>生成博客</p></li>
<li><p>输入<code>hexo d</code>提交博客部署到github中</p>
<ul>
<li><code>hexo d</code>这个过程可能会出现各种错误，如果git
config类型的提示则在博客路径的cmd中输入<code>git config --global user.email "github对应的邮箱账号"</code>、回车后继续输入<code>git config --global user.name "github用户名"</code>，之后再次<code>hexo d</code>部署博客，在弹窗中输入github账号密码搭建联系即可（注意，密码不能填入github的密码，而是填入Token，否则会报错）
<ul>
<li><p>Token的位置：<code>Setting</code>-&gt;<code>Devloper Settting</code>-&gt;<code>Personal access tokens</code></p></li>
<li><p>创建Token的方式：</p>
<p><img src="/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/creat_token.png" width="%50" height="%50"></p>
<p><img src="/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/creat_token2.png" width="%50" height="%50"></p></li>
<li><p>在博客的<code>_config.yml</code>文件中修改<code>repo</code>项为<code>https://AkiraZheng:拿到的token@github.com/AkiraZheng/AkiraZheng.github.io.git</code></p></li>
</ul></li>
<li><code>hexo d</code>这个过程可能会出现各种错误，FATAL中如果出现code:
128错误，很可能是网络问题无法打开github仓库，这是可以关闭cmd挂个梯子后再进行部署</li>
</ul></li>
<li><p>提交后若出现"Please tell me who you
are"，则根据提示输入<code>git config --global user.email "you@example.com"</code>和<code>git config --global user.name "Your Name"</code>(如"1428384878@qq.com"和"AkiraZheng")</p></li>
</ul></li>
<li><p>至此，hexo博客的重新建立联系已经完成了，此时可以浏览自己的博客网站，新的博客网站将与新系统相关联</p></li>
<li><p>注意：如果多端从git上拉项目的话，需要先建立空文件夹完成<code>hexo init</code>等操作建立好环境，然后再根据下面链接中的<code>二：(推荐)在搭建完成博客之后将多端同步加入</code>拉取git上的项目</p>
<ul>
<li><a href="https://zomfice.github.io/2018/02/25/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA-%E4%B8%89-%E5%A4%9A%E8%AE%BE%E5%A4%87%E5%90%8C%E6%AD%A5/">hexo多端同步管理</a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// git初始化</span><br><span class="line">git init</span><br><span class="line">// 添加仓库地址</span><br><span class="line">git remote add origin https://github.com/用户名/仓库名.git</span><br><span class="line">// 新建分支并切换到新建的分支</span><br><span class="line">git checkout -b 分支名</span><br></pre></td></tr></table></figure>
<ul>
<li>执行完命令后，在sourceTree中拉取本地这个文件夹，就能更方便地进行更换分支等操作了</li>
</ul></li>
</ul></li>
</ul>
<h2 id="四引入mathjax公式">四、引入mathjax公式</h2>
<p><strong>首先，如果blog源码还没开启过mathjax</strong>:</p>
<p>由于<code>archer</code>主题中已经配置了mathjax，但是默认是<code>false</code>，因此需要先在<code>_config.yml</code>同目录下的<code>_config.archer.yml</code>中将<code>mathjax: false</code>改为<code>mathjax: true</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">3.2</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>
<p>如果已经修改完<code>_config.archer.yml</code>文件，那么就需要开始配置<code>npm</code>环境了：</p>
<ol type="1">
<li>卸载默认渲染引擎</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>系统上安装 <code>pandoc</code> 和渲染引擎插件</li>
</ol>
<ul>
<li><p>检查 Pandoc 是否已安装</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pandoc -v</span><br></pre></td></tr></table></figure></p>
<p>如果未安装 <code>Pandoc</code>，可以使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install pandoc  <span class="comment"># MacOS</span></span><br><span class="line">sudo apt install pandoc  <span class="comment"># Linux</span></span><br></pre></td></tr></table></figure></li>
<li><p>blog目录下配置npm环境：安装 <code>hexo-renderer-pandoc</code></p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure></p></li>
</ul>
<blockquote>
<p>参考：<a href="https://github.com/fi3ework/hexo-theme-archer?tab=readme-ov-file#%E5%90%AF%E7%94%A8-latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">启用
LaTeX 数学公式</a></p>
</blockquote>
<h2 id="五实现在vscode的terminal中使用hexo指令">五、实现在vscode的Terminal中使用hexo指令</h2>
<p>当通过上述步骤搭载完博客后，包括在blog中也<strong>配置好npm环境和hexo环境后</strong>，可以通过下述步骤实现<strong>在vscode的Terminal中使用hexo指令</strong>，这样就不需要每次都通过在文件夹中打开cmd或者Git
Bash中输入hexo指令了</p>
<ul>
<li>首先将blog文件夹拖入VSCode中（如本文中的<code>MyBlog\blog</code>文件夹）</li>
<li>然后在VSCode中点击<code>Terminal</code>-&gt;<code>New Terminal</code>
<img src="/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/vscode_newTerminal.jpg" width="80%" height="80%"></li>
<li>在新打开的Terminal中输入hexo指令，如<code>hexo s</code>，这时可能会出现报错
<img src="/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/vscode_error.png" width="80%" height="80%"></li>
<li>不要慌，这里是因为在此系统中禁止执行脚本，那么我们就应该先<strong>把脚本执行权限打开</strong>
<ul>
<li>Win10下以<strong>管理员身份</strong>运行<strong>PowerShell</strong>
<img src="/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/vscode_powershell.png" width="50%" height="50%"></li>
<li>输入<code>Set-ExecutionPolicy</code>，回车，检查脚本执行权限是否被打开了，如果是<code>Restricted</code>则说明脚本执行权限没有被打开
<img src="/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/vscode_powershell2.png" width="100%" height="100%"></li>
<li>执行：<code>set-ExecutionPolicy RemoteSigned</code>
需要开启，所以选择<code>Y</code>，回车
<img src="/2022/02/03/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E5%90%8EHexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%95%99%E7%A8%8B/vscode_powershell3.png" width="100%" height="100%"></li>
<li>以上打开权限的方法参考<a href="https://www.cnblogs.com/hdlan/p/14452703.html">hexo运行报无法加载文件</a></li>
</ul></li>
<li>至此，我们已经完成了配置，可以重启VSCode，然后打开Terminal，输入<code>hexo s</code>或其它指令，这时就可以正常运行hexo指令了</li>
<li><strong>Point：</strong>当在Terminal中启动<code>hexo s</code>后，在浏览器中输入<code>http://localhost:4000</code>即可查看博客网站，这时在VSCode中进行博客的编写、修改、部署等操作,保存更改后回到<strong>浏览器刷新即可看到更改后的效果</strong></li>
</ul>
<h2 id="六关于archer主题的相关配置">六、关于Archer主题的相关配置</h2>
<p><a href="https://github.com/fi3ework/hexo-theme-archer/wiki/">Archer主题配置</a>指南在github网站中</p>
<p>修改主题时修改<code>./blog</code>文件夹中的<code>_config.archer.yml</code>而不是thems中的</p>
<ul>
<li><p>启用字数统计及阅读时间</p>
<p>hexo目录下执行</p>
<p><code>npm i --save hexo-wordcount</code></p></li>
<li><p>启用全局搜索功能-Algolia 搜索（在Archer官方文档中有）</p>
<ul>
<li><p>hexo目录下安装<code>hexo-generator-searchdb</code>插件</p>
<p><code>npm install hexo-generator-searchdb --save</code></p></li>
</ul></li>
<li><p>关闭目录自动编号</p>
<ul>
<li><p>打开Archer主题文件夹中的<code>/layout/layout.ejs</code></p></li>
<li><p>将</p>
<p><code>&lt;%- toc(page.content, &#123;class: 'toc', list_number: true&#125;) %&gt;</code></p></li>
<li><p>替换成</p>
<p><code>&lt;%- toc(page.content, &#123;class: 'toc', list_number: false&#125;) %&gt;</code></p></li>
</ul></li>
</ul>
<h1 id="后记-hexo博客编写相关问题合集">后记-hexo博客编写相关问题合集</h1>
<h2 id="解决部署到github仓库时出现连接仓库超时问题">1.
解决部署到github仓库时出现连接仓库超时问题</h2>
<p>所有hexo指令操作都在hexo博客目录下右键点击Git
bush下进行指令操作成功率会高很多！！</p>
<p>还有记得部署到github前进行<code>hexo clean</code>操作，降低出现bug的几率</p>
<ul>
<li><p>解决方法</p>
<ul>
<li><p>在执行<code>hexo d</code>前先在默认浏览器中打开github网站</p></li>
<li><p>在Git
bush中输入<code>git config --global https.proxy</code>设置代理</p></li>
<li><p>在Git
bush中输入<code>git config --global --unset https.proxy</code>取消代理</p></li>
<li><p>在Git
bush中正常输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>提交代码即可</p></li>
</ul></li>
</ul>
<h2 id="解决部署到github仓库时fatal出现code-128错误">2.
解决部署到github仓库时FATAL出现code: 128错误</h2>
<p>所有hexo指令操作都在hexo博客目录下右键点击Git
bush下进行指令操作成功率会高很多！！</p>
<p>还有记得部署到github前进行<code>hexo clean</code>操作，降低出现bug的几率</p>
<ul>
<li><p>解决方法一</p>
<ul>
<li><p>删掉blog中的.deploy_git文件夹，<code>rm -rf .deploy_git/</code></p></li>
<li><p>cmd中输入<code>git config --global core.autocrlf false</code></p></li>
<li><p>cmd中输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p></li>
</ul></li>
<li><p>解决方法二</p>
<ul>
<li><p>删掉blog中的.deploy_git文件夹，<code>rm -rf .deploy_git/</code></p></li>
<li><p>cmd中输入<code>npm install hexo-deployer-git</code></p></li>
<li><p>cmd中输入<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></p></li>
</ul></li>
<li><p>解决办法三</p>
<ul>
<li>太久没使用hexo可能会导致hexo与本地电脑的连接失效，此时转到<a href="#二、建立本机与github的联系">二、建立本机与github的联系</a></li>
</ul></li>
</ul>
<h2 id="用sublime-text3软件实现markdown文件在浏览器中实时更新显示">3.
用Sublime Text3软件实现Markdown文件在浏览器中实时更新显示</h2>
<p>MarkdownPreview + LiveReload</p>
<ul>
<li><p>Sublime中安装插件的办法</p>
<ul>
<li><p>组合键<code>Ctrl+Shift+P</code> 调出命令面板</p></li>
<li><p>输入<code>Package Control: Install Package</code>，回车</p></li>
<li><p>在搜索框中输入要安装的包名（一个一个，不能同时安多个）</p></li>
</ul></li>
<li><p>MarkdownPreview</p>
<ul>
<li><p>根据插件安装方法安装MarkdownPreview插件</p></li>
<li><p>设置浏览器浏览快捷键为<code>alt+m</code>，在Preferences -&gt; Key
Bindings打开的文件的右侧栏的中括号中添加一行代码：</p></li>
</ul>
<p><code>&#123; "keys": ["alt+m"], "command": "markdown_preview", "args": &#123;"target": "browser", "parser":"markdown"&#125;  &#125;</code></p></li>
<li><p>LiveReload实现实时更新</p>
<ul>
<li><p>根据插件安装方法安装LiveReload插件</p></li>
<li><p>组合键<code>Ctrl+Shift+P</code>
输入<code>LiveReload: Enable/disable plug-ins</code>, 回车, 选择
<code>Simple Reload with delay (400ms)或者Simple Reload</code>，两者的区别仅仅在于后者没有延迟。</p></li>
</ul></li>
</ul>
<p>Sublime实现Markdown实时更新参考文章：<a href="https://blog.csdn.net/qq_20011607/article/details/81370236">Sublime
Text3 的 Markdown 实时预览全面总结</a></p>
<h2 id="解决本地图片上传问题">4. 解决本地图片上传问题</h2>
<ul>
<li><p>在_config.yml配置文件中配置项<strong>post_asset_folder</strong>设为true</p>
<p>之后再用<code>hexo new post_name</code>命令都会自动在**source/_post**文件夹中会生成对应的图片文件夹，此时图片文件夹中的图片资源可以用相对路径来引用</p></li>
<li><p>在hexo文件夹打开Git bush输入</p>
<p><code>npm install https://github.com/7ym0n/hexo-asset-image --save</code></p></li>
<li><p>保证图片都保存在同名的文件夹中</p></li>
<li><p>文章的.md文件可以采用两种方式引用、插入图片</p>
<ul>
<li><p>第一种为<code>![图片描述](图片的文件名)</code>，比如<code>![test](1.png)</code></p></li>
<li><p>第二种为<code>&lt;img src="图片的文件名"&gt;</code>，比如<code>&lt;img src="1.png" width="80%" height="80%"&gt;</code></p></li>
</ul></li>
</ul>
<p>解决hexo本地图片插入问题参考文章：<a href="https://blog.csdn.net/qq_36408085/article/details/104117319">Hexo+Github博客：网站内图片不能正常显示，但本地文件可以显示</a></p>
<h2 id="hexo新建文章">5. Hexo新建文章</h2>
<p><code>hexo n text1</code>，注：text1可以改为文章名称</p>
<h2 id="是否开代理问题">6. 是否开代理问题</h2>
<ul>
<li>参考文章<a href="https://zhuanlan.zhihu.com/p/636418854">解决 Github
port 443 : Timed out</a></li>
</ul>
<h2 id="themes是clone的导致push时文件夹出现箭头丢失">7.
themes是clone的导致push时文件夹出现箭头（丢失）</h2>
<ul>
<li>参考文章<a href="https://www.jianshu.com/p/28e61a24d847">Git
解决github文件夹有向右的白色箭头并且不能打开</a></li>
</ul>
]]></content>
      <categories>
        <category>重装-环境配置-计算机</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发系统设计</title>
    <url>/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="一海量数据">一、海量数据</h1>
<h2 id="处理海量数据">1.1 处理海量数据</h2>
<p>在需要对海量数据进行处理时，常常会有<strong>时间</strong>上的需求、<strong>内存空间不足</strong>等问题，</p>
<ul>
<li><p>时间上：加快处理速度</p>
<p>时间上可以通过<strong>算法</strong> &amp;
<strong>数据结构</strong>来提高处理速度，如<strong>哈希、Trie树</strong>等</p></li>
<li><p>空间上：打破内存限制</p>
<p>采用<strong>分而治之</strong>的思想，分批处理</p></li>
</ul>
<p>一般提高海量数据系统性能（时间、空间）的框架为：</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/time_storage_xmind.png"></p>
<h2 id="分而治之解决分割数据问题">1.2 分而治之：解决分割数据问题</h2>
<p>一般解决的场景是，比如<strong>海量日志查找</strong>、<strong>海量数据求TopK</strong>、<strong>海量数据频次统计</strong>、<strong>大文件排序存储</strong>等问题。</p>
<p>一般这种问题有大差不差的解决思路（<strong>分而治之</strong>），即将数据分割成小块，然后分别处理，最后合并结果。</p>
<ul>
<li>分：<code>hash</code>映射</li>
<li>各分块处理：<code>hash-map</code>统计、排序、求TopK
<ul>
<li>统计频次：<code>hash-map</code>统计</li>
<li>各块单独排序：堆/快排/归并</li>
<li>TopK：从各块中选取每个模块的TopK</li>
</ul></li>
<li>合并：归并</li>
</ul>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/split_bigData.png" width="80%"></p>
<h3 id="怎么分--哈希计算">1.2.1 怎么分？- 哈希计算</h3>
<p>一般对于海量数据排序、求频次tok等问题，内存无法一次性装入所有数据进行处理，所以我们选择将数据分成N部分，保证每一部分都可以单独在内存中处理。</p>
<p>由于数据是<strong>无序</strong>的，所以如果采用简单的分割，可能会导致<strong>相同的数据不在同一部分</strong>，从而导致<strong>分块数据的统计结果并不正确</strong></p>
<p>举个例子，我们要对海量数据求TopK，如果我们采用简单的分割，从各个部分中求TopK，最后合并求最终实际的TopK，可能会导致当前这部分数据的非TopK数据跟其他部分的数据合并后可以成为TopK数据的情况，从而导致统计结果不正确。</p>
<p>所以我们需要<strong>哈希计算</strong>，将相同的数据哈希到同一部分，这样就可以保证相同的数据在同一部分，从而保证统计结果的正确性。</p>
<h4 id="分布式负载均衡">分布式负载均衡</h4>
<p>在分布式系统中，我们需要将数据分布到不同的服务器上，这样可以<strong>保证每台服务器的负载均衡</strong>，提高系统的性能。</p>
<p>一般在实现分布式<strong>负载均衡</strong>时，我们首选会采用<strong>一致性哈希</strong>算法，这样可以保证当服务器数量发生变化时，数据的分布变化较小，从而保证系统的稳定性。（避免缓存雪崩现象）</p>
<h4 id="哈希计算">哈希计算</h4>
<p>哈希计算是将数据映射到一个固定的范围内，这样可以保证相同的数据映射到同一部分，从而保证数据的正确性。</p>
<h4 id="哈希碰撞">哈希碰撞</h4>
<p>因为哈希结果是有值域范围（有限的），所以哈希碰撞是<strong>不可避免</strong>的，但是我们可以通过<strong>哈希冲突解决</strong>的方法来解决这个问题。</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/hash_collision.png" width="80%"></p>
<p>解决哈希碰撞的方法一般有两种：</p>
<ul>
<li><p><strong>开放地址法--不常用</strong>：当哈希值发生冲突时，会继续寻找下一个空位置，直到找到空位置为止</p></li>
<li><p><strong>拉链法</strong>：将哈希值相同的数据放在同一个链表中，这样可以保证相同的数据在同一部分</p>
<p>拉链法如下所示：</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/hash_collision2.png" width="80%"></p></li>
</ul>
<h4 id="哈希查找的时间复杂度">哈希查找的时间复杂度</h4>
<table>
<thead>
<tr>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">查找时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">哈希表</td>
<td style="text-align: center;"><code>O(1)</code></td>
</tr>
<tr>
<td style="text-align: center;">哈希碰撞严重</td>
<td style="text-align: center;">退化为<code>O(n)</code></td>
</tr>
</tbody>
</table>
<h4 id="a.-普通哈希计算hashdatan">a. 普通哈希计算hash(data)%N</h4>
<p>哈希计算的特点是<strong>相同的数据哈希值相同</strong>，所以当我们进行<code>hash(data)</code>时，相同的数据会有相同的计算结果，我们再确保这些相同计算结果的数据都放在同一部分即可。</p>
<p>之后怎么进行数据划分呢？</p>
<p>如果我们有N台服务器/需要将数据分出N部分，普通哈希计算会将<strong>哈希值通过取模（求对N的余数）</strong>分布在<code>0-N</code>之间，余数为<code>n</code>的数据就放在第<code>n</code>部分，这样通过哈希计算保证相同的数据取余后结果相同，也就是在同一部分。</p>
<h4 id="b.-一致性哈希hashdata232">b. 一致性哈希hash(data)%(2^32)</h4>
<p>按照普通哈希计算，如果我们有N台服务器，当<strong>服务器数量发生变化</strong>时，数据的分布会发生变化，所有数据都要<strong>重新计算哈希值</strong>，然后进行<strong>数据迁移</strong>。</p>
<p>而解决这个问题的最好方法就是<strong>一致性哈希</strong></p>
<p><strong>1）实现-哈希环</strong></p>
<p>一致性哈希将<strong>数据hash(data)</strong>、<strong>服务器hash(IP or
Mac)</strong>都映射到一个<strong>哈希环</strong>上，通过对<strong>2^32</strong>取模，将数据映射到特定哈希环上。</p>
<p>通过顺时针查找，找到第一个大于等于<strong>该数据data哈希值</strong>的服务器，将数据放在这台服务器上。也就是环中某个区间的数据存在于某台服务器上。</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/consistent_hash.png" width="60%"></p>
<p>当服务器数量发生变化时，只需要对<strong>部分数据</strong>进行迁移，而不是全部数据。</p>
<p>如当删除一台服务器时，只需要将该服务器的数据迁移到下一台服务器即可，不需要进行大量数据的迁移。</p>
<p><strong>2）实现-虚拟节点</strong></p>
<p>在前面的一致性哈希中还存在一个问题，即<strong>数据分布不均匀</strong>，因为服务器的数量有限，如果两个服务器的哈希值在环中很靠近，那么会有一台服务器的数据很多，另一台服务器的数据很少，导致数据分布不均匀。</p>
<p>一致性哈希的实现中，为了保证数据的均匀分布，我们会采用<strong>虚拟节点</strong>的方式，将每台服务器映射到多个虚拟节点上，这样可以保证数据的均匀分布。</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/consistent_hash2.png" width="60%"></p>
<h3 id="各分块怎么处理">1.2.2 各分块怎么处理？</h3>
<p>根据不同需求，我们可以采用不同的处理方式，如<strong>求频次</strong>-&gt;<strong>排序</strong>-&gt;<strong>求TopK</strong>、<strong>海量数据去重</strong>等。</p>
<h4 id="求频次hash-map统计">求频次：hash-map统计</h4>
<p>求频次的问题，我们可以采用<strong>hash-map</strong>的方式，将数据映射到哈希表(<code>key:data,value:count</code>)中，然后统计频次。</p>
<p><strong>时间复杂度</strong>：</p>
<p><strong>有序hash-map</strong>的底层实现是<strong>红黑树</strong>，时间复杂度为<code>n*O(logn)</code></p>
<p><strong>无序hash-map、set</strong>的底层实现是<strong>拉链法</strong>，时间复杂度为<code>O(1)</code>、<code>O(n)</code></p>
<table>
<thead>
<tr>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">有序hash-map</td>
<td style="text-align: center;"><code>n*O(logn)</code></td>
</tr>
<tr>
<td style="text-align: center;">无序hash-map</td>
<td style="text-align: center;"><code>O(1)</code>、<code>O(n)</code></td>
</tr>
</tbody>
</table>
<h4 id="排序堆快排归并">排序：堆/快排/归并</h4>
<p>排序的问题，我们可以采用<strong>堆排序</strong>、<strong>快排</strong>、<strong>归并</strong>等方式时间复杂度较小的算法，将数据进行排序。</p>
<p>一般采用<strong>堆排序</strong>维护一个<strong>大小为K的小根堆</strong>，然后将数据插入堆中，当堆的大小超过K时，将堆顶元素删除，这样可以保证堆中的元素是TopK。</p>
<p><strong>时间复杂度</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">描述</th>
<th style="text-align: center;">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">堆排序</td>
<td style="text-align: center;"><code>O(nlogk)</code></td>
</tr>
<tr>
<td style="text-align: center;">快速排序</td>
<td style="text-align: center;"><code>O(nlogn)</code></td>
</tr>
<tr>
<td style="text-align: center;">归并排序</td>
<td style="text-align: center;"><code>O(nlogn)</code></td>
</tr>
</tbody>
</table>
<h4 id="求topk从各块中选取topk">求TopK：从各块中选取TopK</h4>
<p>对于最经典的从海量数据中求TopK的问题，我们可以从各分块中排序后先<strong>分别求TopK</strong>，最后<strong>合并求最终的TopK</strong>。</p>
<h4 id="海量数据去重">海量数据去重</h4>
<p>海量数据去重主要有两种方法：</p>
<ul>
<li><strong>hash-set</strong>
<ul>
<li>将数据映射到哈希表中，经计算后只有唯一值</li>
<li>可以快速定位数据是否存在，时间复杂度为<code>O(1)</code></li>
<li>缺点是需要<strong>额外的空间</strong>来存储数据（空间换时间）</li>
</ul></li>
<li><strong>Trie树</strong>
<ul>
<li>将数据映射到Trie树中，相同前缀的数据只存储一次，通过共享前缀来节省空间</li>
<li>定位时需要遍历Trie树，时间复杂度为<code>max(O(n*len),O(n*lgk))</code>（len为字符串长度，k为需要求的最频繁前k位）</li>
<li>缺点是<strong>空间复杂度</strong>较高，但是可以<strong>压缩存储</strong>，节省空间</li>
</ul></li>
</ul>
<h3 id="怎么合并--归并">1.2.3 怎么合并？- 归并</h3>
<p>合并还有个问题，就是如果<strong>大文件</strong>本身就不能一次性读入内存，那么对于<strong>多个分块</strong>的数据肯定也不能一次性读入内存。这里还是采用<strong>归并</strong>的方法，但是在进行两两归并时，我们需要<strong>将内存划分成3个缓冲区</strong>来动态实现归并。</p>
<ul>
<li>将内存分为<strong>3</strong>块，2块用来存放<strong>需要归并的分块</strong>的数据，1块用来存放<strong>合并后的数据</strong></li>
<li>从分块中读取数据，然后<strong>归并</strong>到<strong>合并块</strong>中</li>
<li>当<strong>合并块满</strong>时，将数据写入磁盘，然后继续读取数据</li>
<li>当<strong>分块空</strong>时，继续读取分块下一部分的数据</li>
</ul>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/merge_bigData1.jpg" width="60%"></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/merge_bigData2.jpg" width="60%"></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/merge_bigData3.jpg" width="60%"></p>
<h3 id="举例">1.2.4 举例</h3>
<p><strong>1）有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节内存限制大小是1M。返回频数最高的100个词</strong></p>
<p>由于内存限制，我们依然无法直接将大文件的所有词一次读到内存中。因此，同样可以采用<strong>分治策略</strong>，把一个大文件分解成多个小文件，<strong>保证每个文件的大小小于
1MB（需要分成大约5000个）</strong>，求各个小文件的Top100，进而直接将单个小文件读取到内存中进行处理。</p>
<ul>
<li>分：分而治之/hash映射
<ul>
<li>顺序读取文件，对于每个词x，取<code>hash(x)%5000</code></li>
<li>然后把该值存到5000个小文件(记为x0,x1…...x4999)中。这样每个文件大概是200k左右。</li>
<li>如果其中有的小文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。</li>
</ul></li>
<li>处理：hash_map统计
<ul>
<li>对每个小文件，采用<code>trie树/hash_map</code>等统计每个文件中出现的词以及相应的频率。</li>
<li>堆/归并排序</li>
<li>取出出现频率最大的<code>100</code>个词(可以用含100个结点的最小堆)后</li>
<li>再把100个词及相应的频率存入文件，这样又得到了5000个文件</li>
</ul></li>
<li>合：归并
<ul>
<li>最后就是把这5000个文件进行<strong>归并</strong>(类似于归并排序)的过程了</li>
</ul></li>
</ul>
<p><strong>2）海量日志数据，提取出某日访问百度次数最多的那个IP</strong></p>
<p>百度作为国内第一大搜索引擎，每天访问它的<strong>IP数量巨大</strong>，如果想一次性把所有IP数据装进内存处理，则内存容量明显不够，故针对数据太大，内存受限的情况，可以<strong>把大文件转化成(取模映射)小文件</strong>，从而大而化小，逐个处理。
换言之，先映射，而后统计，最后排序。</p>
<ul>
<li>分：分而治之/hash映射
<ul>
<li>首先把这一天访问百度日志的所有IP提取出来</li>
<li>然后逐个写入到一个大文件中</li>
<li>接着采用映射的方法，比如<code>%1000</code>，把整个大文件映射为1000个小文件</li>
</ul></li>
<li>处理：hash_map统计
<ul>
<li>当大文件转化成了小文件，那么我们便可以采用<code>hash_map(ip, value)</code>来分别对1000个小文件中的IP进行频率统计，再找出每个小文件中出现频率最大的IP</li>
<li>堆/快速排序</li>
<li>找出那个频率最大的IP</li>
</ul></li>
<li>合：归并
<ul>
<li>最后，再对这1000个频率最大的IP进行归并排序，找出那个频率最大的IP</li>
</ul></li>
</ul>
<p>Hash取模是一种<strong>等价映射</strong>，不会存在同一个元素分散到不同小文件中去的情况，即这里采用的是<code>%1000</code>算法，那么<strong>同一个IP在hash后，只可能落在同一个文件中</strong>，不可能被分散的。</p>
<p><strong>3）给定a、b两个文件，各存放50亿个ur，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的ur?</strong></p>
<p>可以估计每个文件大小为<code>5Gx64=320G</code>，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。</p>
<ul>
<li>分：分而治之/hash映射
<ul>
<li><strong>遍历文件a</strong>，对每个url求取
<code>hash(URL)% 1000</code>，然后根据所取得的值将url分别存储到1000个小文件(记为a1-a999)中。这样每个小文件的大约为300M</li>
<li><strong>遍历文件b</strong>，同样对每个url求取
<code>hash(URL)% 1000</code>，然后根据所取得的值将url分别存储到1000个小文件(记为b1-b999)中</li>
<li>这样处理后，所有可能相同的url都在对应的小文件(即<strong>a1 对应
b1</strong>，a2 对应b2..，a999 对应
b999)中，<strong>不对应的小文件不可能有相同的url</strong></li>
</ul></li>
<li>处理+合并：hash_map统计
<ul>
<li>首先对A的小文件在<code>hash_set</code>中进行去重操作</li>
<li>然后查找B的小文件是否有url在刚才构建的<code>hash_set</code>中</li>
<li>如果是，那么就是共同的url，存到文件里面就可以了</li>
</ul></li>
</ul>
<blockquote>
<p>参考：<a href="https://blog.csdn.net/weixin_45683778/article/details/136694740">何为一致性哈希</a></p>
</blockquote>
<h1 id="二高并发分布式系统设计基础">二、高并发分布式系统设计基础</h1>
<p>面对高并发场景，我们通常有两种大解决方向：</p>
<ul>
<li>垂直方向：提升单机能力
<ul>
<li>这种方式主要是通过<strong>硬件升级</strong>，如<strong>购买多核高频机器，大内存，大容量磁盘</strong>等</li>
<li><strong>软件优化</strong>，如<strong>多线程</strong>、<strong>异步</strong>、<strong>缓存</strong>等</li>
<li>但是这种方式有<strong>瓶颈</strong>，即<strong>硬件成本高</strong>，以及当硬件达到一定程度时，提升单机性能的效果会<strong>递减</strong>。</li>
</ul></li>
<li>水平方向：分布式集群
<ul>
<li>这种方式主要是通过<strong>多台机器</strong>，通过<strong>微服务解耦</strong>将数据分布到不同的机器上，从而提升系统的性能
<ul>
<li>架构层次分层</li>
<li>业务服务划分</li>
</ul></li>
<li>这种方式<strong>成本低</strong>，<strong>可扩展性强</strong>，但是<strong>复杂度高</strong>，需要考虑<strong>数据一致性</strong>、<strong>负载均衡</strong>等问题</li>
</ul></li>
</ul>
<p>当前最常见的高并发系统设计是<strong>分布式系统设计</strong>，即将数据分布到不同的机器上，通过<strong>负载均衡</strong>、<strong>一致性哈希</strong>等技术来提升系统的性能。因此后面我们主要讲的就是<strong>水平方向分布式</strong>场景下的设计理念和框架。</p>
<p>一般我们在分布式系统设计中，主要关注以下几个方面：</p>
<ul>
<li><strong>池化技术：内存池、线程池、连接池</strong></li>
<li><strong>负载均衡：保证用户分流</strong></li>
<li><strong>缓存：提高响应速度</strong>
<ul>
<li><strong>分布式锁</strong></li>
</ul></li>
<li><strong>数据库存储</strong>
<ul>
<li><strong>分布式事务</strong></li>
</ul></li>
<li><strong>消息队列</strong></li>
<li><strong>限流：控制并发访问量，避免过载</strong></li>
<li><strong>熔断</strong></li>
<li><strong>降级：保证核心功能</strong></li>
</ul>
<p>整体并发架构如下：</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/concurrent_architecture.jpg" width="80%"></p>
<h2 id="分布式cap理论">2.1 分布式CAP理论</h2>
<p>CAP理论是分布式系统设计中的一个重要理论，它指出在分布式系统中，<strong>一致性（Consistency）、可用性（Availability）、分区容错性（Partition
tolerance）</strong>三者不可兼得，<strong>只能同时满足其中两个</strong>。</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/CAP.png" width="50%"></p>
<ul>
<li><strong>一致性C</strong>
<strong>所有节点</strong>在同一时间的数据是<strong>一致</strong>的，即<strong>等同于所有节点访问同一份最新的数据副本</strong></li>
<li><strong>可用性A</strong>
<strong>客户的每个请求</strong>都能够得到<strong>非错响应</strong>，但是但是不保证获取的数据为最新数据</li>
<li><strong>分区容错性P</strong>
<ul>
<li><strong>系统</strong>能够<strong>容忍网络分区</strong></li>
<li>针对<strong>一致性的容错性</strong>：当不要求保证<strong>一致性</strong>时，每个节点使用<strong>本地数据</strong>，在同一时间内可能出现<strong>全局不一致</strong>，但是一段时间后<strong>最终一致</strong></li>
<li>针对<strong>可用性的容错性</strong>：必须保证<strong>一致性</strong>，但是<strong>不保证可用性</strong>，即<strong>允许部分服务停止</strong>，直到<strong>网络分区</strong>解决</li>
</ul></li>
</ul>
<p><strong>1）CA系统：单点集群</strong></p>
<p>对于业务扩展性不强、并发性要求不高的系统，我们可以采用<strong>单点集群</strong>的方式同时保证<strong>一致性</strong>和<strong>可用性</strong></p>
<p>场景：<strong>银行系统</strong>、<strong>图书馆管理系统</strong></p>
<p><strong>2）CP系统：放弃高可用性（高性能）</strong></p>
<p>对于对<strong>一致性</strong>要求较高的系统，我们可以采用<strong>放弃可用性</strong>的方式来保证<strong>一致性</strong></p>
<p>一旦遇到<strong>分区故障</strong>，就要允许放弃<strong>一部分业务</strong>，通常性能不高</p>
<p>场景：火车票售票系统、redis</p>
<p><strong>3）AP系统：最终一致性</strong></p>
<p>某些场景下对<strong>一致性</strong>要求不高，我们可以采用<strong>最终一致性</strong>的方式来保证<strong>绝对可用性</strong></p>
<p>通常很多分布式系统都是采用<strong>AP</strong>来实现的（买票时看到有几张余票，但是买的时候告诉你没有了，当再次刷新发现确实没票）</p>
<p>场景：<strong>电商系统</strong>、<strong>社交系统（博客，微博）</strong>、<strong>搜索引擎</strong></p>
<h2 id="系统并发指标">2.2 系统并发指标</h2>
<ul>
<li><strong>TPS</strong>：一台服务器每秒能处理的<strong>事务数</strong>
<ul>
<li>一个客户端请求就是一个事务</li>
</ul></li>
<li><strong>QPS</strong>：一台服务器每秒能响应的<strong>查询次数</strong>
<ul>
<li>一个客户端请求可能有多个查询，所以<strong>QPS</strong>是<strong>TPS</strong>的<strong>倍数</strong>，QPS&gt;=TPS</li>
</ul></li>
</ul>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/QPS_TPS.png" width="30%"></p>
<ul>
<li><p><strong>并发数</strong>：系统<strong>同时</strong>承载的并发用户数</p></li>
<li><p><strong>响应时间</strong>：系统<strong>响应一个请求</strong>的时间</p></li>
</ul>
<h2 id="分布式负载均衡-1">2.3 分布式负载均衡</h2>
<p>负载均衡是为了满足多台服务器情况下的<strong>高可用</strong>需求，通过<strong>负载均衡（）</strong>可以将<strong>请求分发到不同的服务器实例上</strong>，从而提高系统的性能。</p>
<p>负载均衡通过不断向<strong>后端服务器</strong>发送<strong>心跳检测</strong>，来检测服务器的<strong>健康状态</strong>，从而保证<strong>负载均衡的准确性</strong>。</p>
<p>负载均衡有<strong>硬件负载均衡</strong>和<strong>软件负载均衡</strong>两种方式：</p>
<ul>
<li><strong>硬件负载均衡</strong>性能好，但是可扩展性差，成本高</li>
<li><strong>软件负载均衡</strong>性能一般，但是可扩展性强，成本低</li>
</ul>
<p>目前常见的三种软件负载均衡：</p>
<ul>
<li><strong>基于DNS负载均衡</strong>：通过<strong>地理位置</strong>or加权，根据IP映射到不同服务器</li>
<li><strong>基于网络层负载均衡</strong>：基于<strong>IP地址和端口号</strong>来分发流量</li>
<li><strong>基于应用层负载均衡</strong>：解包HTTP请求的特性（如请求头、URL、主机名等）来分发<strong>不同业务请求</strong>到<strong>不同后端服务器</strong></li>
</ul>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/LB2.png" width="80%"></p>
<p>一般大型服务器系统中，会同时包含这三种均衡方式</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/LB.png" width="50%"></p>
<h3 id="dns负载均衡">2.3.1 DNS负载均衡</h3>
<p>DNS对某个域名进行<strong>IP映射</strong>，DNS负载均衡通过<strong>DNS解析</strong>将<strong>域名解析</strong>到<strong>多个不同的IP地址</strong>，然后将解析后的IP地址返回给客户端，从而实现<strong>负载均衡</strong>。能够对网站加载进行加速</p>
<p>做为第一层的负载均衡，它能根据不同地理位置的用户返回<strong>离用户最近的服务器</strong>，减少中间的网络传输延迟和丢包率</p>
<p>但是由于DNS解析是<strong>有缓存</strong>的（包括本地DNS缓存、客户端缓存等），所以<strong>DNS负载均衡</strong>无法确保各地服务器<strong>负载均匀</strong></p>
<p><strong>DNS负载均衡的实现策略</strong></p>
<p><strong>1）轮询策略</strong></p>
<p>DNS服务器中维护一个<strong>服务器列表</strong>，每次请求时按照<strong>轮询</strong>的方式返回<strong>服务器列表</strong>中的<strong>下一个服务器IP</strong>，也就是N台服务器的IP按照顺序返回给不同的客户端</p>
<p>缺点：无法根据各个服务器的<strong>负载情况</strong>和<strong>地理位置</strong>来返回服务器IP</p>
<p><strong>2）地理位置策略</strong></p>
<p>DNS服务器通过<strong>解析</strong>判断客户端请求的<strong>来源IP地址</strong>，然后将请求解析到<strong>地理位置最近</strong>的或者<strong>网络延迟最低</strong>的服务器</p>
<p><strong>3）权重策略</strong></p>
<p>每个服务器IP都有一个<strong>权重值</strong>，根据<strong>权重值</strong>来返回<strong>服务器IP</strong></p>
<p>权重值可以根据<strong>服务器负载情况</strong>、<strong>地理位置</strong>等来设置</p>
<p><strong>4）智能DNS</strong></p>
<p>DNS可以通过：</p>
<ul>
<li><strong>心跳</strong>监测服务器是否故障（定期向注册的服务器发送探测请求HTTP、TCP、ICMP等）</li>
<li>通过<strong>服务器监测工具</strong>定期收集注册服务器的<strong>性能数据</strong></li>
<li>根据<strong>性能数据</strong>来<strong>动态调整</strong>服务器的<strong>权重值</strong></li>
<li>结合<strong>地理位置</strong>和<strong>动态权重值</strong>返回<strong>最优服务器IP</strong></li>
</ul>
<h3 id="网络层应用层负载均衡nginx">2.3.2
网络层&amp;应用层负载均衡：Nginx</h3>
<p><strong>Nginx</strong>具有<strong>web服务器</strong>、<strong>负载均衡</strong>、<strong>反向代理</strong>等功能，是一个<strong>高性能</strong>的<strong>HTTP</strong>和<strong>反向代理</strong>服务器。</p>
<p><strong>Nginx</strong>是一种基于应用层的<strong>软件负载均衡</strong>，通常根据解析的<strong>URL</strong>来<strong>反向代理转发请求</strong></p>
<p><strong>Nginx</strong>的<strong>负载均衡</strong>有<strong>轮询</strong>、<strong>加权轮询</strong>、<strong>IP哈希</strong>、<strong>最少连接</strong>等策略</p>
<p><strong>1）IP哈希</strong></p>
<p>根据<strong>客户端IP地址</strong>的<strong>哈希值</strong>来<strong>分配</strong>请求，这样可以保证<strong>同一个IP</strong>的请求<strong>始终</strong>分配到<strong>同一个服务器</strong>上</p>
<p><strong>2）最少连接</strong></p>
<p>将请求分配到<strong>连接数最少</strong>的服务器上，这样可以保证<strong>负载均衡</strong>，但是<strong>性能</strong>可能会受到<strong>影响</strong></p>
<h2 id="分布式缓存">2.4 分布式缓存</h2>
<p>在高并发场景下，缓存机制可以<strong>有效缓解实例服务器和数据库压力</strong>、<strong>提高网页访问速度</strong></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Cache-type.png" width="80%"></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Cache-problem.png" width="80%"></p>
<h3 id="本地客户端缓存">2.4.1 本地客户端缓存</h3>
<p>常用于缓存<strong>实时性不敏感</strong>、<strong>静态网页</strong>，如在大促期间提前将一些<strong>js/css/image</strong>文件缓存至本地，避免在大促期间再次请求</p>
<p>本地客户端缓存可以通过<strong>HTTP缓存机制</strong>来实现</p>
<ul>
<li>强制缓存
<ul>
<li><code>Expires</code>字段：绝对时间</li>
<li><code>Cache-Control</code>字段：倒计时时间</li>
</ul></li>
<li>协商缓存
<ul>
<li><code>Last-Modified</code>字段：当前缓存对应的最后修改时间</li>
<li><code>E-tag</code>字段：当前缓存资源的<strong>哈希值</strong></li>
</ul></li>
<li>混合缓存</li>
</ul>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/HTTP_cache_2.jpg" width="70%"></p>
<h3 id="cdn-内容分发网络">2.4.2 CDN-内容分发网络</h3>
<p>CDN是由专门的机构在世界各地建立<strong>边缘服务器</strong>，用户通过DNS域名解析获取<strong>最近的CDN服务器</strong>，从该CDN服务器上获取资源而不是直接从实例服务器获取，大大加快了请求响应速度。</p>
<p>同时由于CDN替实例服务器分流了，所以还可以大大<strong>减少带宽</strong>（虽然还需要向CDN服务商付费）</p>
<p>CDN中的缓存内容：</p>
<ul>
<li>静态网页资源</li>
<li>动态网页API接口</li>
</ul>
<p>CDN缓存机制主要有两种：</p>
<ul>
<li><strong>主动推送</strong>（push）：服务器主动将缓存push给CDN</li>
<li><strong>拉去机制</strong>（pull）：客户端首次访问CDN中不存在的资源，CDN主动从源服务器中获取数据并存储在CDN节点上</li>
</ul>
<h3 id="反向代理缓存">2.4.3 反向代理缓存</h3>
<p>反向代理服务器如<code>Nginx</code>除了上面提到的负载均衡外，还可以通过<strong>配置</strong>具有<strong>缓存</strong>功能，也是存储<strong>静态资源</strong>，返回给用户时从缓存中拿，不再向源服务器请求</p>
<h3 id="redis缓存">2.4.4 redis缓存</h3>
<p>Redis缓存是指分散存储在服务器上，在<strong>内存中进行计算的缓存</strong>，相比磁盘中的数据库具有<strong>更快的响应速度</strong></p>
<p>Redis是一种高性能的<strong>键值key-value存储</strong>系统，用其<strong>快速的读写能力</strong>和<strong>一致性哈希算法</strong>实现数据分片和<strong>负载均衡</strong>（通过一致性哈希算法分配给集群中的某个缓存）</p>
<p><strong>redis集群缓存带来的问题</strong></p>
<p>1）缓存穿透</p>
<p>问题：</p>
<ul>
<li>请求<strong>缓存和数据库都没有</strong>的数据 都去访问数据库 -&gt;
数据库崩溃、服务器宕机</li>
</ul>
<p>解决：</p>
<ul>
<li><strong>布隆过滤器</strong>：将数据库中的数据映射到布隆过滤器中，当请求来临时，先通过布隆过滤器判断是否存在，不存在则直接返回</li>
<li><strong>空值缓存</strong>：将数据库中不存在的数据也存入缓存(设为空值)</li>
</ul>
<p>2）缓存击穿</p>
<p>问题：</p>
<ul>
<li><strong>单个热点key失效</strong> 都去访问数据库 -&gt;
数据库崩溃、服务器宕机</li>
</ul>
<p>解决：</p>
<ul>
<li><strong>热点数据永不过期</strong>：将热点数据设置为永不过期，当失效时，立即更新</li>
<li><strong>互斥锁</strong>：当热点数据失效时，通过互斥锁来保证只有一个线程去访问数据库，其他线程等待</li>
<li><strong>多级缓存</strong></li>
</ul>
<p>3）缓存雪崩</p>
<p>问题：</p>
<ul>
<li><strong>大量key同时失效</strong> 都去访问数据库 -&gt;
数据库崩溃、服务器宕机</li>
<li>服务器宕机： 采用普通哈希算法导致所有Key同时失效 -&gt;
都去访问数据库 -&gt; 数据库崩溃</li>
</ul>
<p>解决：</p>
<ul>
<li><strong>缓存失效时间随机</strong>：将缓存失效时间设置为随机时间，<strong>避免同时失效</strong></li>
<li><strong>多级缓存</strong></li>
</ul>
<p>4）数据一致性</p>
<p>缓存一致性指的是<strong>缓存与DB</strong>之间的数据一致性</p>
<p>需要保证<strong>始终一直</strong>或<strong>最终一致</strong></p>
<p>常用的解决方法是</p>
<ul>
<li>缓存的分布式锁</li>
<li>DB数据库的分布式事务</li>
</ul>
<p>数据一致性的两种方法将在后面详细介绍</p>
<h2 id="分布式消息队列">2.5 分布式消息队列</h2>
<p>在高并发场景下，<strong>同步</strong>的请求处理方式往往会导致系统<strong>响应时间变长</strong>和<strong>资源消耗增加</strong>。</p>
<p>因此我们可以采用<strong>异步</strong>的方式，将<strong>耗时的操作</strong>或<strong>复杂的业务逻辑</strong>异步化处理，并将<strong>结果通过消息队列传递</strong>，可以实现<strong>解耦</strong>和异步化处理，在只需要<strong>最终一致性</strong>的场景下，很适合用来配合做流控。</p>
<p><strong>分布式缓存</strong>在<strong>读多写少</strong>的场景性能优异，对于<strong>写操作较多</strong>的场景可以采用<strong>消息队列</strong>集群，它可以很好地做写请求异步化处理，实现<strong>削峰填谷</strong>的效果。</p>
<p>业界有很多著名的消息中间件，比如ZeroMQ，rabbitMQ，kafka等。</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/MessageQueue.png"></p>
<h3 id="消息队列的优点">2.5.1 消息队列的优点</h3>
<p><strong>1）异步</strong></p>
<p>如果我们按照同步的处理方式来设计，比如设计一个<strong>用户注册</strong>功能，会经过<strong>用户注册-&gt;短信通知-&gt;增加积分</strong>三个串行同步步骤，这种方式的话，总耗时是<strong>三个步骤的总和</strong>。</p>
<p>总耗时：10ms+100ms+100ms=210ms</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/message_queue1.png" width="60%"></p>
<p>而如果在中间加上一层<strong>消息队列</strong>实现异步并行处理，那么总耗时将只剩下<strong>用户注册</strong>这一步，因为通过异步方式，用户注册后消息队列就可以返回，后面的<strong>两个耗时步骤</strong>直接与消息队列通信拉取信息。用户不需要阻塞在那等待耗时步骤完成。</p>
<p>总耗时：10ms</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/message_queue2.png" width="60%"></p>
<p><strong>2）业务解耦</strong></p>
<p>业务解耦是在<strong>异步</strong>的基础上实现的，如果是同步的话，<strong>用户注册</strong>和<strong>短信通知</strong>是<strong>紧耦合</strong>的，如果<strong>短信通知</strong>出现问题，那么<strong>用户注册</strong>也会受到影响。</p>
<p>而使用了<strong>消息队列</strong>实现异步后，消息发送方和接收方不直接联系，各个业务之间也相对独立，不会因为<strong>某个业务</strong>的<strong>宕机</strong>影响到<strong>其他业务</strong></p>
<p><strong>3）削峰填谷</strong></p>
<p>举个例子，在高并发场景下，假设1min内有30W个请求（<code>30W/min</code>），而后端业务服务器只能处理<code>1W/min</code>，那么超量的请求可能会导致服务器宕机。</p>
<p>加入我们在请求和处理方中间加上一层<strong>消息队列</strong>，消息队列只做简单的数据接收任务，能处理<code>100W/min</code>，此时由后端服务器主动向消息队列拉去任务就可以控制后端服务器不过载，达到控制流量的作用。</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/liuliang.png" width="70%"></p>
<h3 id="消息队列优化设计">2.5.2 消息队列优化设计</h3>
<p>根据简陋版本消息队列的各种问题，可以进行优化来提高可用性及性能</p>
<p>根据Kafka的设计理念来剖析优化方向</p>
<p><strong>1）MQ数据堆积</strong></p>
<p>MQ中数据堆积本质是消费者消费能力差，可以通过<strong>增加消费者线程</strong>，也就是多消费者模式，同理也可以添加多生产者提高吞吐量</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/multiConsumers.jpg" width="60%"></p>
<p><strong>2）多生产者和多消费者竞争MQ</strong></p>
<p><strong>分Topic</strong></p>
<p>将消息队列根据<strong>不同主题Topic</strong>分为<strong>多个MQ</strong>减少冲突等待</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/multiTopic.jpg" width="60%"></p>
<p><strong>Topic的Partition分区</strong></p>
<p>单个Topic中还可以再细分成<strong>多个Partition分区</strong>，每个消费者对应一个Partition分区，从而<strong>降低多线程竞争</strong></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/multiPartition.jpg" width="60%"></p>
<p><strong>3）高性能</strong></p>
<p>将多个Partition分布在不同机器上，每个机器称为<strong>broker</strong></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/multiBroker.jpg" width="60%"></p>
<p><strong>4）高可用</strong></p>
<p>单个broker如果宕机了，该部分的功能将无法继续进行，因此可以设计<strong>leader-follower</strong>的集群方式</p>
<p><strong>leader</strong>负责读写数据，<strong>follower</strong>负责复制数据，当<strong>leader</strong>宕机时可以从<strong>follower</strong>中选举出新的<strong>leader</strong></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/leader-follower.jpg" width="60%"></p>
<p><strong>5）持久化</strong></p>
<p>数据放在内存中有宕机丢失的风险，因此数据还应该具备<strong>持久化到磁盘</strong>的能力</p>
<p>同时为了防止磁盘溢出，还应该设置<strong>过期时间</strong></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/savetodisk.jpg" width="60%"></p>
<p>根据不同的优化策略，形成了不同的<strong>消息队列中间件</strong>，可以根据需求和中间件的优缺点选择合适的方案：</p>
<table>
<tr>
<th style="text-align: center;">
中间件
</th>
<th style="text-align: center;">
RabbitMQ
</th>
<th style="text-align: center;">
RocketMQ
</th>
<th style="text-align: center;">
Kafka
</th>
</tr>
<tr>
<th style="text-align: center;">
性能
</th>
<td style="text-align: center;">
6000/单机
</td>
<td style="text-align: center;">
12000/单机
</td>
<td style="text-align: center;">
100W/单机
</td>
</tr>
<tr>
<th style="text-align: center;">
持久化
</th>
<td style="text-align: center;">
都支持（性能下降）
</td>
<td style="text-align: center;">
天生支持
</td>
<td style="text-align: center;">
天生支持
</td>
</tr>
<tr>
<th style="text-align: center;">
多语言
</th>
<td style="text-align: center;">
主流都
</td>
<td style="text-align: center;">
Java
</td>
<td style="text-align: center;">
主流都
</td>
</tr>
<tr>
<th style="text-align: center;">
综合
</th>
<td style="text-align: center;">
高可用、管理界面、集群不支持动态扩展
</td>
<td style="text-align: center;">
简单易用、适合大规模，但只支持Java
</td>
<td style="text-align: center;">
天生分布式、性能最好，但运维困难、带宽要求大
</td>
</tr>
</table>
<h3 id="rabbitmq设计">2.5.3 RabbitMQ设计</h3>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/RabbitMQDesign.png"></p>
<p>RabbitMQ中主要涉及的模块元素有：</p>
<ul>
<li><strong>Producer生产者</strong>：负责<strong>生产和发送消息</strong>，一般是直接与<strong>交换机</strong>连接</li>
<li><strong>Connection连接</strong>：生产者与Broker的连接、Broker与消费者的连接</li>
<li><strong>virtual
Host虚拟机</strong>：一个Broker可以有多个虚拟机，每个虚拟机实现一种业务，虚拟机之间数据互相隔离</li>
<li><strong>Exchange交换机</strong>：生产者将消息发送到交换机，交换机根据<strong>路由规则</strong>将消息发送到<strong>某个队列</strong></li>
<li><strong>Queue队列</strong>：存储消息的<strong>缓冲区</strong></li>
<li><strong>Comsumer消费者</strong>：负责<strong>接收和处理消息</strong>
<ul>
<li>多个消费者绑定同一个队列可以通过<strong>消息轮询</strong>的方式进行分发</li>
</ul></li>
</ul>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/RabbitMQ.jpg"></p>
<p><strong>1）消息丢失</strong></p>
<p>RabbitMQ的消息丢失主要有三种情况：</p>
<ul>
<li><strong>生产者丢失</strong>：发送者发送失败，可能是<strong>网络</strong>原因
<ul>
<li>通过<strong>消息确认机制Comfirm</strong>接收<strong>ACK或NACK</strong>以及重传来实现，确保消息投递到了queue中</li>
</ul></li>
<li><strong>Broker丢失</strong>：消息未发送存储到queue中可能就出现<strong>Broker宕机</strong>等原因丢失
<ul>
<li>通过<strong>持久化</strong>来实现</li>
</ul></li>
<li><strong>消费者丢失</strong>：消息接收也可能因为<strong>网络或者处理失败</strong>等原因丢失
<ul>
<li>通过<strong>ACK事务机制</strong>来实现。消费者成功处理完后才会发送<strong>ACK</strong>告知Broker可以删除该条消息</li>
</ul></li>
</ul>
<p><strong>2）消息重复</strong></p>
<p>消息可能出现重复消费的原因：</p>
<ul>
<li><strong>生产者重复推送</strong></li>
<li><strong>Broker收到ACK后还未删除就宕机</strong>：重启后会再次发送该消息给消费者</li>
<li><strong>消费者处理完后未发送ACK就宕机</strong>：重启后MQ超时没收到ACK会重新推送该条消息给消费者处理</li>
</ul>
<p>解决方法：</p>
<p><strong>插入去重表</strong>：消费去重表可以是MySQL存储，也可以是Redis存储</p>
<ul>
<li>收到消息后先查询去重表，如果存在则不处理，否则将该消息插入去重表再进行处理</li>
<li>处理完再将该消息状态更改为已处理</li>
</ul>
<p><strong>3）消息顺序</strong></p>
<p>除非采用单线程消费，否则<strong>消息顺序</strong>无法保证，但是可以尽量保证消息顺序</p>
<ul>
<li>同一个<strong>queue</strong>中的消息是顺序的</li>
<li>Exchange路由器指定分发同样的key到某个queue中</li>
<li><strong>queue</strong>中增加一些机制，只有某个操作收到ACK后才分发下一个</li>
</ul>
<h3 id="kafka设计">2.5.4 Kafka设计</h3>
<p>Kafkade的设计架构在前面<strong>优化</strong>部分已经有大致提及了</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/KafkaStruct.jpg"></p>
<p>所以接下来还是将重心放在<strong>Kafka</strong>怎么解决<strong>消息丢失</strong>、<strong>消息重复</strong>、<strong>消息顺序</strong>三大问题</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/KafkaDesign.png"></p>
<p><strong>1）消息丢失</strong></p>
<ul>
<li><strong>生产者丢失</strong>：发送者发送失败，可能是<strong>网络</strong>原因
<ul>
<li>通过<strong>消息确认机制Comfirm</strong>接收<strong>ACK或NACK</strong>以及回调重传来实现，确保消息投递到了queue中</li>
</ul></li>
<li><strong>Broker丢失</strong>：消息未发送存储到queue中可能就出现<strong>Broker宕机</strong>等原因丢失
<ul>
<li>通过<strong>持久化</strong>来实现</li>
<li>Kafka对每个<strong>Partition</strong>提供了<strong>leader-follower</strong>的副本机制方式，当<strong>leader</strong>宕机时可以从<strong>follower</strong>中选举出新的<strong>leader</strong></li>
</ul></li>
<li><strong>消费者丢失</strong>：消息接收也可能因为<strong>网络或者处理失败</strong>等原因丢失
<ul>
<li>通过<strong>ACK事务机制</strong>来实现。消费者成功处理完后才会发送<strong>ACK</strong>告知Broker可以删除该条消息</li>
</ul></li>
</ul>
<p><strong>2）消息重复</strong></p>
<p>Kafka的消息队列中通过<strong>offset</strong>来标记消息的位置，消费者消费完后会自动提交<strong>offset</strong>来避免重复消费，但是依然这也导致了如果<strong>消费者宕机</strong>，重启后消息队列可能触发了超时重传导致重复消费。</p>
<p>在这个背景下，避免消息重复处理的方式跟RabbitMQ一样，可以通过<strong>插入去重表</strong>来实现：</p>
<p>解决方法：</p>
<p><strong>插入去重表</strong>：消费去重表可以是MySQL存储，也可以是Redis存储</p>
<ul>
<li>收到消息后先查询去重表，如果存在则不处理，否则将该消息插入去重表再进行处理</li>
<li>处理完再将该消息状态更改为已处理</li>
</ul>
<p><strong>3）消息顺序</strong></p>
<p><strong>为什么会出现消息顺序问题呢？</strong></p>
<p>Kafka的消息队列中，<strong>同一个Partition</strong>中的消息是有序的，但是<strong>不同Partition</strong>中的消息是<strong>无序</strong>的，因此如果<strong>同一个业务</strong>的消息被<strong>路由分发到不同Partition</strong>中，那么就会出现<strong>消息消费顺序不是消息发送顺序</strong>的问题。</p>
<p>解决方法：</p>
<p>基于这个背景，可以采用<strong>自定义路由</strong>的方式，将<strong>同一个业务（指定的key）</strong>的消息<strong>路由到同一个Partition</strong>中，再指定某个消费者线程去<strong>定向取</strong>某个Patition分区的消息，从而保证消息的顺序性。</p>
<ul>
<li><strong>自定义路由</strong>：通过<strong>自定义路由</strong>将<strong>同一个业务（按照key取模）</strong>的消息<strong>路由到同一个Partition</strong>中</li>
<li><strong>指定消费者</strong>：指定某个消费者线程去<strong>定向取某个Patition分区</strong>的消息</li>
</ul>
<p><strong>6）主从数据一致性</strong></p>
<p>前面提到Kafka会通过<strong>leader-follower</strong>的副本机制来减少数据丢失，这里的数据存储涉及<strong>MySQL</strong>或<strong>Redis</strong>数据库</p>
<ul>
<li>MySQL下的数据一致性：通过<strong>Follower</strong>节点拉取<strong>Leader</strong>的<strong>binlog</strong>日志，然后<strong>同步</strong>到<strong>Follower</strong>节点</li>
<li>Redis下的数据一致性：主-从-从方式，主节点写入数据后，从节点同步数据，再从从节点同步到其他从节点</li>
</ul>
<p><strong>5）leader-follower下的选举问题：ISR</strong></p>
<p>Kafka中的<strong>leader-follower</strong>机制是指<strong>leader</strong>负责读写数据，<strong>follower</strong>负责复制数据，当<strong>leader</strong>宕机时可以从<strong>follower</strong>中选举出新的<strong>leader</strong></p>
<p>但是在<strong>leader-follower</strong>机制下，<strong>follower</strong>可能会出现<strong>数据同步滞后</strong>的问题，导致<strong>数据不一致</strong>。</p>
<p>为了解决这个问题，Kafka中引入了<strong>ISR</strong>机制，在<strong>ISR</strong>中维护一个集合，该集合是代表<strong>存储最新数据离leader最近的follower</strong>，只有<strong>ISR</strong>中的<strong>follower</strong>才能被选举为<strong>leader</strong></p>
<p>因此采用ISR的好处主要有两个：</p>
<ul>
<li><strong>提高宕机后重选leader的效率</strong>：只有ISR中的follower才能被选举为leader，提高了选举效率</li>
<li><strong>避免数据丢失</strong>：因为ISR中节点的数据和leader节点的数据是最接近的</li>
</ul>
<h2 id="分布式数据库">2.6 分布式数据库</h2>
<p>传统的数据库系统是<strong>单机数据库</strong>，在高并发场景下，单机数据库可能会出现<strong>性能瓶颈</strong>，面对这种需求，我们一般有<strong>纵向扩展</strong>和<strong>横向扩展</strong>两种方式。</p>
<ul>
<li><strong>纵向扩展</strong>：提高单机数据库的性能，如<strong>增加CPU</strong>、<strong>增加内存</strong>、<strong>增加硬盘</strong>等
<ul>
<li>成本过高，不适合现在海量数据的场景</li>
</ul></li>
<li><strong>横向扩展</strong>：通过<strong>分布式数据库</strong>来实现，将数据分布在多个节点上，从而提高系统的性能
<ul>
<li>适合海量数据的场景，需要考虑<strong>数据库容灾</strong>、<strong>数据一致性</strong>等问题</li>
</ul></li>
</ul>
<p>这里主要讨论怎么解决<strong>数据库容灾</strong>问题</p>
<p>数据库容灾是指在<strong>数据库宕机</strong>或<strong>数据丢失</strong>时，能够<strong>快速恢复</strong>数据，保证系统的<strong>高可用性</strong></p>
<p>一般出现故障的原因主要有三大类：</p>
<ul>
<li><strong>服务器主机故障</strong>：服务器过载宕机、网络故障等</li>
<li><strong>机房故障</strong>：机房电力系统出现问题、火灾等</li>
<li><strong>地域故障</strong>：发生地震、火灾等</li>
</ul>
<p>出现这些问题最需要解决的就是<strong>系统恢复</strong>、<strong>保证数据不丢失</strong></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/avoidProblem.png" width="60%"></p>
<p><strong>1）主从数据库备份</strong></p>
<p>通过<strong>主从复制技术</strong>、<strong>binglog</strong>等技术实现同步</p>
<p><strong>2）数据分片</strong></p>
<p>将数据根据<strong>业务需求</strong>，通过分片键如<strong>用户ID</strong>、<strong>订单ID</strong>等决定哪个数据库集群存储特定数据</p>
<p><strong>3）数据一致性</strong></p>
<p>通过<strong>分布式事务</strong>、<strong>分布式锁</strong>等技术来保证数据一致性</p>
<p><strong>4）防止过载</strong></p>
<p>通过前面讲到的<strong>负载均衡</strong>、<strong>限流</strong>等技术来保证系统不会因为过载而宕机</p>
<p><strong>5）读写分离</strong></p>
<p>应用中的<strong>读操作</strong>远远多于<strong>写操作</strong>，可以通过<strong>读写分离</strong>来减轻数据库的压力</p>
<p>写操作：主数据库</p>
<p>读操作：从数据库</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/readSlaveWriteMaster.jpg"></p>
<h2 id="分布式事务和分布式锁">2.7 分布式事务和分布式锁</h2>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/dataAll.png" width="80%"></p>
<p>这两种方式都是为了保证<strong>MySQL</strong>和<strong>Redis</strong>数据一致性的</p>
<p>服务器在响应读数据请求时，会先从<strong>Redis</strong>中读取数据，如果<strong>Redis</strong>中没有数据，再从<strong>MySQL</strong>中读取数据，然后将数据返回给客户端。</p>
<p>而对于<strong>写数据</strong>则有多种更新方式（建议采用删除Redis而不是更新修改Redis）：</p>
<ul>
<li><p><strong>先更新Redis再更新MySQL</strong>：如果先更新Redis，那么如果MySQL更新失败回滚，还要再次回滚Redis</p></li>
<li><p><strong>先更新MySQL再更新Redis</strong>：如果先更新MySQL，那么当<strong>线程1</strong>被最新的<strong>线程2</strong>抢占CPU资源后，会出现线程2的数据先写入缓存，线程2的数据后写入数据库，导致缓存存的不是最新数据</p></li>
<li><p><strong>先删除Redis再更新MySQL</strong>：也会有数据不一致问题（通过<strong>延迟双删</strong>来解决）
<img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/deleteUpdate.png" width="60%"></p></li>
<li><p><strong>先更新MySQL再删除Redis</strong>：目前比较有效的方式
<img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/updateDelete.png" width="60%"></p></li>
</ul>
<p>而由于分布式数据库有<strong>读写分离</strong>的设计，所以会有概率出现从数据库还没来得及更新，就被请求读取了，导致缓存与数据库数据不一致的问题</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/DistributedTransaction.jpg" width="60%"></p>
<p>这里的解决办法是加上一层消息队列保证顺序性。</p>
<h3 id="分布式锁">2.7.1 分布式锁</h3>
<p>传统的<strong>同步锁</strong>是<strong>单机锁</strong>，只能保证在单机下多线程的同步</p>
<p>而在<strong>分布式</strong>场景下，多个服务器之间的<strong>同步</strong>就需要<strong>分布式锁</strong>来实现，否则还会出现类似<strong>超卖</strong>现象</p>
<p>主流分布式锁有：</p>
<ul>
<li>Redis：通过<strong>setnx</strong>设置键值对，如果返回1则表示加锁成功，否则设置失败
<ul>
<li>要记得加上锁过期时间，避免造成死锁
<img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/RedisLock.jpg" width="60%"></li>
<li>过期时业务还没执行完怎么办？---<strong>添加一个线程每n秒判断服务器是否在线</strong>、<strong>给锁加一个唯一ID（UUID）</strong></li>
<li>以上设计方式实际上可以通过<strong>Redisson</strong>来一步实现(lua脚本)
<img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Redisson.jpg" width="60%"></li>
</ul></li>
<li>Zookeeper：通过<strong>临时节点</strong>来实现分布式锁
<ul>
<li>通过<strong>创建临时节点</strong>来实现分布式锁，如果<strong>创建成功</strong>则表示加锁成功，否则加锁失败</li>
<li>通过<strong>监听节点</strong>来实现<strong>锁释放</strong>，当节点被删除时，其他节点可以重新加锁</li>
</ul></li>
</ul>
<h3 id="分布式事务">2.7.2 分布式事务</h3>
<p><strong>事务</strong>是为了保证一组操作<strong>要么全部成功，要么全部失败</strong>，保证数据的<strong>原子性</strong>、<strong>一致性</strong>、<strong>隔离性</strong>和<strong>持久性</strong></p>
<p>而在分布式场景下，多个不同业务是异步的，怎么保证一个业务失败后，其它业务也回滚呢？</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/DistributedTransaction2.jpg" width="60%"></p>
<p><strong>1）两阶段提交2PC</strong></p>
<p><strong>事务参与者</strong>：多种业务的事务执行者</p>
<p><strong>事务协调者</strong>：负责协调各个事务参与者的事务执行</p>
<p>2PC两个阶段是由<strong>事务协调者</strong>来协调的：</p>
<ul>
<li><strong>准备阶段</strong>：
<ul>
<li>事务协调者向所有事务参与者发送<strong>prepare准备</strong>请求</li>
<li>各个事务参与者执行事务操作</li>
<li>如果事务参与者执行成功，则返回<strong>ACK</strong>，否则返回<strong>NACK</strong></li>
</ul></li>
<li><strong>提交阶段</strong>：
<ul>
<li>若正常收到所有<strong>事务参与者</strong>的<strong>ACK</strong>，则事务协调者向所有事务参与者发送<strong>commit提交</strong>请求</li>
<li>某个事务迟迟没有返回<strong>ACK</strong>，则事务协调者会<strong>回滚</strong>所有事务参与者的事务</li>
</ul></li>
</ul>
<p>缺点：造成所有事务参与者<strong>阻塞</strong>，<strong>性能</strong>较差</p>
<p><strong>2）三阶段提交3PC</strong></p>
<p>相比2PC，3PC在<strong>准备阶段</strong>前多了一个<strong>可否提交询问CanCommit</strong>阶段，也就是先判断<strong>事务服务器是否存活</strong>，避免资源浪费</p>
<ul>
<li><strong>可否提交询问CanCommit</strong>：
<ul>
<li>事务协调者向所有事务参与者发送<strong>CanCommit询问</strong>请求</li>
<li>事务参与者执行事务操作</li>
<li>如果事务参与者执行成功，则返回<strong>ACK</strong>，否则返回<strong>NACK</strong></li>
</ul></li>
<li><strong>准备阶段</strong></li>
<li><strong>提交阶段</strong></li>
</ul>
<p>缺点：依然存在事务进行时的全局阻塞</p>
<h2 id="分布式限流">2.8 分布式限流</h2>
<p>在<strong>秒杀</strong>等超高并发场景下，为了保证系统的<strong>稳定性</strong>，需要适当降低<strong>用户体验</strong>来平衡系统的<strong>压力</strong></p>
<p>一般可以通过<strong>拒绝服务</strong>、<strong>服务降级</strong>、<strong>特权VIP处理</strong>、<strong>限流</strong>等方式来实现</p>
<p>经典的限流算法有4种：<strong>计数器方式</strong>、<strong>滑动窗口</strong>、<strong>漏桶</strong>、<strong>令牌桶</strong></p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/LimitFlow.png" width="60%"></p>
<h3 id="计数器方式">2.8.1 计数器方式</h3>
<p>计数器方式是最简单的限流算法，通过<strong>固定一个计数器阈值</strong>来记录<strong>单位时间</strong>内允许的<strong>请求次数</strong></p>
<p>当在这段时间内某一刻总请求次数超过<strong>阈值</strong>时，则后面这段时间内将就拒绝服务</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/Counter.png" width="60%"></p>
<p>缺点：在两个相隔时间段内可能瞬间请求次数过多，导致<strong>瞬间流量</strong>过大</p>
<h3 id="滑动窗口">2.8.2 滑动窗口</h3>
<p>在<strong>计数器方式</strong>的基础上，将大时间段再细分为<strong>小时间段</strong>，通过<strong>滑动窗口</strong>来动态累计请求次数</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/SlidingWindow.jpg" width="60%"></p>
<h3 id="漏桶">2.8.3 漏桶</h3>
<p>漏桶算法是一种<strong>固定容量</strong>的<strong>漏桶</strong>缓存消息，消费者对桶的消费速率相对固定，而生产者的生产速率不固定，但是有容量限制，当桶满时，生产者将拒绝请求，从而实现限流</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/LeakyBucket.png" width="60%"></p>
<h3 id="令牌桶">2.8.4 令牌桶</h3>
<p>令牌桶的<strong>容量不固定</strong>，而是通过<strong>中间人</strong>按照一定速率往桶中<strong>放入令牌token</strong>，有点类似于空闲时段<strong>攒钱</strong>，在<strong>繁忙时段</strong>可以<strong>花钱</strong>，所以相比<strong>漏桶</strong>算法，在面对大流量时可以快速处理</p>
<p>当请求来临时，先从桶中<strong>取出令牌</strong>，如果<strong>有令牌</strong>则处理请求，否则拒绝请求</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/TokenBucket.png" width="60%"></p>
<h2 id="分布式熔断和降级">2.9 分布式熔断和降级</h2>
<p>熔断与降级的区别：熔断可能会调用降级机制，但是降级不会调用熔断机制</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/CircuitBreakerAndDegrade.png" width="60%"></p>
<h3 id="熔断">2.9.1 熔断</h3>
<p>在某些情况下，系统<strong>大量下游节点出现异常</strong>，那么会影响整个系统的<strong>稳定性</strong></p>
<p>而熔断（Circuit
Breaking）是面向不稳定服务场景设计的，它能最大限度避免下游服务不稳定对上游服务带来的影响。</p>
<p>当<strong>某个下游业务不稳定时</strong>，可以通过<strong>熔断</strong>机制先把不稳定的服务<strong>熔断</strong>，然后<strong>降级</strong>处理</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/CircuitBreaker.png" width="60%"></p>
<p>熔断判断方法：</p>
<ul>
<li><strong>异常率</strong>：当<strong>异常率</strong>超过一定阈值时，就会触发熔断</li>
<li><strong>响应超时率</strong>：当<strong>响应超时率</strong>超过一定阈值时，就会触发熔断</li>
</ul>
<h2 id="降级">2.9.2 降级</h2>
<p>降级是为了解决<strong>资源不足</strong>和<strong>访问量过大</strong>的问题，通过<strong>降低牺牲一些业务（停某些业务）或流程（强一致性变最终一致）</strong>来保证系统的<strong>稳定性</strong></p>
<p>降级的方式有：</p>
<ul>
<li><strong>停止某些业务</strong>：比如在<strong>秒杀</strong>高并发场景下，可以<strong>停止注册</strong>业务</li>
<li><strong>强一致性变最终一致性</strong>：比如在<strong>秒杀</strong>高并发场景下，可以<strong>降级</strong>为<strong>最终一致性</strong></li>
</ul>
<h2 id="uuid-雪花算法">2.10 UUID-雪花算法</h2>
<p>UUID是由<strong>32个16进制</strong>数字，也就是<strong>16<sup>32=2</sup>128</strong>128位组成的，一般是<strong>全球唯一</strong>，是通过<strong>雪花算法（生成分布式全局唯一ID的算法）</strong>生成的</p>
<p>UUID的产生一般与<strong>时间戳</strong>、<strong>网卡MAC地址</strong>、<strong>随机数</strong>等有关</p>
<p>优点：<strong>全球唯一</strong>、<strong>不重复</strong></p>
<p>缺点：<strong>无序</strong>、<strong>存储空间大</strong>、<strong>字符串存储，查询效率低</strong></p>
<blockquote>
<p>参考：<a href="https://mbd.baidu.com/newspage/data/landingsuper?rs=3122157695&amp;ruk=qiRiJMGafDiNgx10N6x2lQ&amp;urlext=%7B%22cuid%22%3A%22luHda_icH8_KPHtLYaSIflaqBil6uBuCluvsalixS8_v8SiE_aSau08sHaJUfQulE6HmA%22%7D&amp;isBdboxFrom=1&amp;pageType=1&amp;sid_for_share=&amp;context=%7B%22nid%22%3A%22news_9293703006842681579%22,%22sourceFrom%22%3A%22search%22%7D">架构设计之道：高并发架构设计</a></p>
<p>参考：<a href="https://blog.csdn.net/lixinkuan328/article/details/95535691">分布式之CAP原则详解</a></p>
<p>参考：<a href="https://mbd.baidu.com/ug_share/mbox/4a83aa9e65/share?product=smartapp&amp;tk=3fdf4dfbc1f1d088d6a696bbd8b2aa5a&amp;share_url=https%3A%2F%2Fyebd1h.smartapps.cn%2Fpages%2Fblog%2Findex%3FblogId%3D128606461%26_swebfr%3D1%26_swebFromHost%3Dbaiduboxapp&amp;domain=mbd.baidu.com">面试场景题积累汇总</a></p>
<p>参考：<a href="https://blog.itpub.net/70024922/viewspace-3005053/">高并发架构设计（三大利器：缓存、限流和降级）</a></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/431149128">深入消息队列MQ，看这篇就够了！</a></p>
</blockquote>
<h1 id="三常见的分布式系统设计场景">三、常见的分布式系统设计场景</h1>
<h2 id="秒杀系统设计">3.1 秒杀系统设计</h2>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/SecondKillStruct.png" width="80%"></p>
<p>整体架构主要包括<strong>Redis预扣库存</strong>、<strong>Kafka异步下单</strong>、<strong>MySQL扣除实际库存</strong>、<strong>前端跳转支付</strong>等步骤，一般的流程为<strong>请求-&gt;限流组件-&gt;Redis预扣-&gt;库存服务</strong></p>
<p>具体流程如下：</p>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/SecondKill.png" width="80%"></p>
<h3 id="限流">3.1.1 限流</h3>
<p>限流一般是在接入系统前进行的预处理，一般由专门的<strong>限流组件</strong>在<strong>网关</strong>端实现，通过<strong>令牌桶</strong>、<strong>漏桶</strong>等算法来实现</p>
<p>当请求超过一定阈值时，就会触发<strong>限流</strong>，返回<strong>请求太多</strong>的提示来拒绝请求服务</p>
<h3 id="redis预扣库存">3.1.2 Redis预扣库存</h3>
<p>Redis预扣库存主要有以下的步骤：</p>
<ul>
<li><strong>预扣库存（管理订单名额）+限额</strong>：用户请求到达后，先从<strong>Redis</strong>中<strong>预扣库存</strong>，如果<strong>库存不足</strong>则返回<strong>库存不足</strong>的提示</li>
<li><strong>LUA保证原子性</strong>：通过<strong>LUA脚本</strong>来保证<strong>预扣库存</strong>的<strong>原子性</strong>，避免<strong>超卖</strong>的问题</li>
<li><strong>状态记录逻辑</strong>：secNum（uuid）做为key来存储状态信息</li>
</ul>
<h3 id="kafka异步下单">3.1.3 Kafka异步下单</h3>
<p>Redis预扣除后，怎么把实际的订单消息传给<strong>MySQL</strong>进行<strong>实际订单生成</strong>和<strong>库存扣除</strong>呢？</p>
<p><strong>1）直接打到MySQL</strong></p>
<p>由于Redis已经进行预扣除，只有拿到<strong>入场券</strong>的订单才能交给MySQL，如果此时<strong>商品秒杀库存总额</strong>只有几百或者几千，那么直接打到MySQL也是可以的</p>
<p>但是如果<strong>商品秒杀库存总额</strong>有几十万、几百万，那么直接打到MySQL就会导致<strong>MySQL</strong>的<strong>压力</strong>过大，因此需要<strong>异步下单</strong></p>
<p><strong>2）Kafka异步下单</strong></p>
<p>Kafka中存储<strong>订单消息</strong>交给MySQL消费，通过同一商品在<strong>同一分区</strong>中，保证<strong>订单生成</strong>的<strong>顺序性</strong></p>
<p>消费队列的数据主要包括：<strong>订单ID</strong>、<strong>用户ID</strong>、<strong>商品ID</strong>、<strong>商品数量</strong>、<strong>商品价格</strong>等信息</p>
<h3 id="mysql扣除实际库存">3.1.4 MySQL扣除实际库存</h3>
<p><strong>1）扣除库存</strong></p>
<p>MySQL中的<strong>商品库存</strong>是<strong>实际库存</strong>，通过<strong>商品ID</strong>来<strong>扣除库存</strong></p>
<p><strong>2）订单生成</strong></p>
<p>通过<strong>订单ID</strong>、<strong>用户ID</strong>、<strong>商品ID</strong>、<strong>商品数量</strong>、<strong>商品价格</strong>等信息来生成<strong>订单</strong></p>
<p><strong>3）订单状态</strong></p>
<p>订单生成后，需要<strong>更新订单状态</strong>，比如<strong>已支付</strong>、<strong>未支付</strong>等状态</p>
<h3 id="前端跳转支付">3.1.5 前端跳转支付</h3>
<p>订单生成后，需要<strong>跳转支付</strong>，通过<strong>支付宝</strong>、<strong>微信</strong>等支付方式来完成支付</p>
<p>支付完成后，需要<strong>更新订单状态</strong>为<strong>已支付</strong>，同时<strong>扣除用户余额</strong>等操作</p>
<h3 id="更新redis库存">3.1.6 更新Redis库存</h3>
<p>支付完成后，需要<strong>更新Redis库存</strong>，将<strong>预扣库存</strong>更新为<strong>实际库存</strong></p>
<h2 id="扫码登录设计">3.2 扫码登录设计</h2>
<h3 id="token">3.2.1 token</h3>
<p><strong>token</strong>是指<strong>令牌</strong>，是一种<strong>身份验证</strong>的方式，通过<strong>token</strong>来<strong>验证用户身份</strong>，<strong>保护用户隐私</strong></p>
<p>我们通常在网页中登陆一次后，下次访问不需要再次登陆，就是通过<strong>token</strong>来实现的：</p>
<ul>
<li><strong>token生成</strong>：通过<strong>用户ID</strong>、<strong>时间戳</strong>、<strong>密钥</strong>等信息生成<strong>token</strong></li>
<li><strong>token验证</strong>：
<ul>
<li>通过<strong>token</strong>来验证用户身份，如果<strong>token</strong>过期或者不正确则需要重新登陆</li>
<li>由于token中的value包含设备信息，所以就算被窃取也很难保证设备信息一致</li>
</ul></li>
</ul>
<h3 id="扫码登录设计思路">3.2.2 扫码登录设计思路</h3>
<p><img src="/2024/05/01/%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/scanLogin.png" width="80%"></p>
<ul>
<li>获取二维码
<ul>
<li>PC端：携带设备信息-&gt;请求后端二维码ID</li>
<li>后端Redis：产生二维码ID（状态为：待扫码）-&gt;关联二维码ID和设备信息-&gt;返回二维码ID</li>
</ul></li>
<li>显示二维码
<ul>
<li>PC端：前端展示二维码</li>
<li>PC端：开始不断轮询后端二维码ID状态</li>
</ul></li>
<li>登录扫码
<ul>
<li>移动端：扫码获得二维码ID-&gt;发起扫码请求</li>
<li>后端Redis：根据二维码ID关联用户ID（状态改为：待确认）-&gt;生成临时token-&gt;返回临时token</li>
<li>PC端：轮询到状态改变，显示用户对应头像（等待移动端确认）</li>
</ul></li>
<li>确认登录
<ul>
<li>移动端：确认登录-&gt;携带临时token-&gt;请求后端</li>
<li>后端Redis：删除临时token-&gt;根据用户ID生成token-&gt;二维码关联用户ID（状态改为：已激活）</li>
<li>PC端：轮询到状态改变，获取token并登录</li>
</ul></li>
</ul>
<h3 id="扫码登录设计-1">3.2.3 扫码登录设计</h3>
<h4 id="数据结构">3.2.3.1 数据结构</h4>
<p>采用Redis做为存储，为了保证原子性，需要通过<strong>Lua</strong>来操作</p>
<p>以<code>key-value</code>的形式存储数据：</p>
<table>
<tr>
<th style="text-align: center; font-weight: bold;">
key
</th>
<td>
二维码ID
</td>
</tr>
<tr>
<th rowspan="4" style="text-align: center; font-weight: bold;">
value(Json)
</th>
<td>
accountID
</td>
</tr>
<tr>
<td>
deviceInfo(设备ID、设备MAC、地理位置...)
</td>
</tr>
<tr>
<td>
status(待扫码、待确认、待激活)
</td>
</tr>
<tr>
<td>
pctoken
</td>
</tr>
</table>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">//qrID</span></span><br><span class="line">    <span class="attr">&quot;qrIDxxx&quot;</span>:&#123;</span><br><span class="line">        <span class="attr">&quot;accountID&quot;</span>:<span class="string">&quot;dsfsd1231321f&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;deviceInfo&quot;</span>:&#123;</span><br><span class="line">            <span class="attr">&quot;deviceID&quot;</span>:<span class="string">&quot;sdfsfaldfhfshlfhds&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;deviceType&quot;</span>:<span class="string">&quot;mac&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;position&quot;</span>:<span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;status&quot;</span>: <span class="number">3</span>,<span class="comment">//激活</span></span><br><span class="line">        <span class="attr">&quot;pcToken&quot;</span>:<span class="string">&quot;xxxxxxxx&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="临时token作用安全性">3.2.3.1 临时token作用（安全性）</h4>
<p>临时token是为了绑定扫码的<strong>移动端设备</strong>，这样就算<strong>token</strong>被<strong>截获</strong>，也无法<strong>登录</strong>，因为<strong>token</strong>是<strong>绑定设备</strong>的</p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
  </entry>
</search>
